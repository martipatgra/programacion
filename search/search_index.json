{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programaci\u00f3n Aqu\u00ed puedes encontrar los apuntes del m\u00f3dulo de Programaci\u00f3n , que se imparte en el primer curso del ciclo formativo de grado superior de Desarrollo de Aplicaciones Multiplataforma. La duraci\u00f3n del m\u00f3dulo es de 256 horas lectivas, a raz\u00f3n de 8 horas semanales . Se ha planificado bas\u00e1ndose en 4 sesiones de 2 horas lectivas por semana. Resultados de aprendizaje y criterios de evaluaci\u00f3n Reconoce la estructura de un programa inform\u00e1tico, identificando y relacionando los elementos propios del lenguaje de programaci\u00f3n utilizado. Criterios de evaluaci\u00f3n Se han identificado los bloques que componen la estructura de un programa inform\u00e1tico. Se han creado proyectos de desarrollo de aplicaciones Se han utilizado entornos integrados de desarrollo. Se han identificado los distintos tipos de variables y la utilidad espec\u00edfica de cada uno. Se ha modificado el c\u00f3digo de un programa para crear y utilizar variables. Se han creado y utilizado constantes y literales. Se han clasificado, reconocido y utilizado en expresiones los operadores del lenguaje. Se ha comprobado el funcionamiento de las conversiones de tipo expl\u00edcitas e impl\u00edcitas. Se han introducido comentarios en el c\u00f3digo. Escribe y prueba programas sencillos, reconociendo y aplicando los fundamentos de la programaci\u00f3n orientada a objetos. Escribe y depura c\u00f3digo, analizando y utilizando las estructuras de control del lenguaje. Desarrolla programas organizados en clases analizando y aplicando los principios de la programaci\u00f3n orientada a objetos. Realiza operaciones de entrada y salida de informaci\u00f3n, utilizando procedimientos espec\u00edficos del lenguaje y librer\u00edas de clases. Escribe programas que manipulen informaci\u00f3n seleccionando y utilizando tipos avanzados de datos. Desarrolla programas aplicando caracter\u00edsticas avanzadas de los lenguajes orientados a objetos y del entorno de programaci\u00f3n. Utiliza bases de datos orientadas a objetos, analizando sus caracter\u00edsticas y aplicando t\u00e9cnicas para mantener la persistencia de la informaci\u00f3n. Gestiona informaci\u00f3n almacenada en bases de datos relacionales manteniendo la integridad y consistencia de los datos. Unidades did\u00e1cticas / Temporalizaci\u00f3n A continuaci\u00f3n se muestran las unidades did\u00e1cticas y una estimaci\u00f3n temporal de cada una de ellas. El curso est\u00e1 dividido en 10 unidades did\u00e1cticas distribuidas en tres trimestres. Primera evaluaci\u00f3n Compuesta por las 5 primeras unidades, donde se estudiar\u00e1n los aspectos b\u00e1sicos de la programaci\u00f3n orientada a objetos usando el lenguaje de programaci\u00f3n Java . Unidad T\u00edtulo Sesiones Horas 1 Elementos de un programa inform\u00e1tico 10 20 2 Estructuras b\u00e1sicas de control 13 26 3 Programaci\u00f3n orientada a objetos. Clases y Objetos 12 24 4 Arrays 9 18 5 Herencia y polimorfismo 14 28 Segunda evaluaci\u00f3n Incluye 3 unidades y se profundizar\u00e1 en aspectos de codificaci\u00f3n como colecciones de Java, interfaces de usuario, reflections, expresiones regulares, etc. Unidad T\u00edtulo Sesiones Horas 6 Colecciones 15 30 7 Programaci\u00f3n avanzada 10 20 8 Interfaces de usuario 16 32 Tercera evaluaci\u00f3n Por \u00faltimo se aprender\u00e1n t\u00e9cnicas de lectura y escritura y persistencia de la informaci\u00f3n en ficheros y bases de datos. Unidad T\u00edtulo Sesiones Horas 9 Persistencia de la informaci\u00f3n 13 26 10 Bases de datos 16 32 Instrumentos de calificaci\u00f3n La nota de cada evaluaci\u00f3n se calcula mediante: 30% Trabajo en Clase / Actividades Se eval\u00faan todas las actividades realizadas en clase y en casa. Las actividades se eval\u00faan mediante tareas de Aules con calificaciones comprendidas entre 0 y 3 puntos: 0: No entregada. 1: Entregada pero soluci\u00f3n err\u00f3nea o incompleta. 2: Entregada y soluci\u00f3n aceptable, aunque tiene alg\u00fan apartado incompleto. 3: Entregada y soluci\u00f3n correcta. Las actividades/pr\u00e1cticas son fundamentales para aprobar la asignatura. Cualquier actividad que se detecte copia ser\u00e1 puntuada con 0. 70% Actividad de evaluaci\u00f3n. Se deben aprobar ambas partes por separado. La nota final se calcula mediante la media de cada una de las evaluaciones.","title":"Inicio"},{"location":"#programacion","text":"Aqu\u00ed puedes encontrar los apuntes del m\u00f3dulo de Programaci\u00f3n , que se imparte en el primer curso del ciclo formativo de grado superior de Desarrollo de Aplicaciones Multiplataforma. La duraci\u00f3n del m\u00f3dulo es de 256 horas lectivas, a raz\u00f3n de 8 horas semanales . Se ha planificado bas\u00e1ndose en 4 sesiones de 2 horas lectivas por semana.","title":"Programaci\u00f3n"},{"location":"#resultados-de-aprendizaje-y-criterios-de-evaluacion","text":"Reconoce la estructura de un programa inform\u00e1tico, identificando y relacionando los elementos propios del lenguaje de programaci\u00f3n utilizado. Criterios de evaluaci\u00f3n Se han identificado los bloques que componen la estructura de un programa inform\u00e1tico. Se han creado proyectos de desarrollo de aplicaciones Se han utilizado entornos integrados de desarrollo. Se han identificado los distintos tipos de variables y la utilidad espec\u00edfica de cada uno. Se ha modificado el c\u00f3digo de un programa para crear y utilizar variables. Se han creado y utilizado constantes y literales. Se han clasificado, reconocido y utilizado en expresiones los operadores del lenguaje. Se ha comprobado el funcionamiento de las conversiones de tipo expl\u00edcitas e impl\u00edcitas. Se han introducido comentarios en el c\u00f3digo. Escribe y prueba programas sencillos, reconociendo y aplicando los fundamentos de la programaci\u00f3n orientada a objetos. Escribe y depura c\u00f3digo, analizando y utilizando las estructuras de control del lenguaje. Desarrolla programas organizados en clases analizando y aplicando los principios de la programaci\u00f3n orientada a objetos. Realiza operaciones de entrada y salida de informaci\u00f3n, utilizando procedimientos espec\u00edficos del lenguaje y librer\u00edas de clases. Escribe programas que manipulen informaci\u00f3n seleccionando y utilizando tipos avanzados de datos. Desarrolla programas aplicando caracter\u00edsticas avanzadas de los lenguajes orientados a objetos y del entorno de programaci\u00f3n. Utiliza bases de datos orientadas a objetos, analizando sus caracter\u00edsticas y aplicando t\u00e9cnicas para mantener la persistencia de la informaci\u00f3n. Gestiona informaci\u00f3n almacenada en bases de datos relacionales manteniendo la integridad y consistencia de los datos.","title":"Resultados de aprendizaje y criterios de evaluaci\u00f3n"},{"location":"#unidades-didacticas-temporalizacion","text":"A continuaci\u00f3n se muestran las unidades did\u00e1cticas y una estimaci\u00f3n temporal de cada una de ellas. El curso est\u00e1 dividido en 10 unidades did\u00e1cticas distribuidas en tres trimestres.","title":"Unidades did\u00e1cticas / Temporalizaci\u00f3n"},{"location":"#primera-evaluacion","text":"Compuesta por las 5 primeras unidades, donde se estudiar\u00e1n los aspectos b\u00e1sicos de la programaci\u00f3n orientada a objetos usando el lenguaje de programaci\u00f3n Java . Unidad T\u00edtulo Sesiones Horas 1 Elementos de un programa inform\u00e1tico 10 20 2 Estructuras b\u00e1sicas de control 13 26 3 Programaci\u00f3n orientada a objetos. Clases y Objetos 12 24 4 Arrays 9 18 5 Herencia y polimorfismo 14 28","title":"Primera evaluaci\u00f3n"},{"location":"#segunda-evaluacion","text":"Incluye 3 unidades y se profundizar\u00e1 en aspectos de codificaci\u00f3n como colecciones de Java, interfaces de usuario, reflections, expresiones regulares, etc. Unidad T\u00edtulo Sesiones Horas 6 Colecciones 15 30 7 Programaci\u00f3n avanzada 10 20 8 Interfaces de usuario 16 32","title":"Segunda evaluaci\u00f3n"},{"location":"#tercera-evaluacion","text":"Por \u00faltimo se aprender\u00e1n t\u00e9cnicas de lectura y escritura y persistencia de la informaci\u00f3n en ficheros y bases de datos. Unidad T\u00edtulo Sesiones Horas 9 Persistencia de la informaci\u00f3n 13 26 10 Bases de datos 16 32","title":"Tercera evaluaci\u00f3n"},{"location":"#instrumentos-de-calificacion","text":"La nota de cada evaluaci\u00f3n se calcula mediante: 30% Trabajo en Clase / Actividades Se eval\u00faan todas las actividades realizadas en clase y en casa. Las actividades se eval\u00faan mediante tareas de Aules con calificaciones comprendidas entre 0 y 3 puntos: 0: No entregada. 1: Entregada pero soluci\u00f3n err\u00f3nea o incompleta. 2: Entregada y soluci\u00f3n aceptable, aunque tiene alg\u00fan apartado incompleto. 3: Entregada y soluci\u00f3n correcta. Las actividades/pr\u00e1cticas son fundamentales para aprobar la asignatura. Cualquier actividad que se detecte copia ser\u00e1 puntuada con 0. 70% Actividad de evaluaci\u00f3n. Se deben aprobar ambas partes por separado. La nota final se calcula mediante la media de cada una de las evaluaciones.","title":"Instrumentos de calificaci\u00f3n"},{"location":"about/","text":"About Patricia Mart\u00ed p.marti2@edu.gva.es Bibliograf\u00eda y webgraf\u00eda https://docs.oracle.com/en/java/ Java, Java, Java- Object-Oriented Problem Solving - Third Edition R. Morelli and R. Walde","title":"About"},{"location":"about/#about","text":"Patricia Mart\u00ed p.marti2@edu.gva.es","title":"About"},{"location":"about/#bibliografia-y-webgrafia","text":"https://docs.oracle.com/en/java/ Java, Java, Java- Object-Oriented Problem Solving - Third Edition R. Morelli and R. Walde","title":"Bibliograf\u00eda y webgraf\u00eda"},{"location":"shortcuts/","text":"Atajos de teclado para IntelliJ En proceso.","title":"Atajos de teclado para IntelliJ"},{"location":"shortcuts/#atajos-de-teclado-para-intellij","text":"En proceso.","title":"Atajos de teclado para IntelliJ"},{"location":"ud1/121conceptosbasicos/","text":"JAVA Java es un lenguaje de programaci\u00f3n orientado a objetos. Fue creado por James Gosling en 1995. Oracle lo compr\u00f3. Es un lenguaje indepediente de la plataforma donde va a ser ejecutado, esto significa, que una vez que se compila (.class tambi\u00e9n llamado bytecode) puede ser transportado a diferentes plataformas (Windows, MacOS, Linux) para ser ejecutado. \u00bfC\u00f3mo se hace esto? Utilizando la JVM (Java Virtual Machine). La JVM coge los bytecode compilados y los interpreta dependiendo del OS para poder ser ejecutado. Por tanto, el bytecode siempre es el mismo, pero lo que genera la JVM cambiar\u00e1 para cada SO. Tambi\u00e9n existen otros t\u00e9rminos muy famosos relacionados con Java como JRE y JDK. JRE Java Runtime Environment . La m\u00e1quina virtual de Java est\u00e1 incluida en el JRE. Se utiliza para ejecutar aplicaciones Java en el SO, por tanto si queremos desplegar una aplicaci\u00f3n en Java, necesitamos tener instalado previamente el JRE para esa m\u00e1quina y plataforma. JDK Java Development Kit . Es m\u00e1s pesado que el JRE, contiene todas las herramientas para programar y compilar las clases Java en bytecode, por tanto cuando desarrollamos clases Java necesitamos el JDK. Adem\u00e1s incluy el JRE. Versiones Java La \u00faltima versi\u00f3n de Java se conoce como LTS Release (Long Term Support), y es JAVA 11 LTS ( la LTS 17 estar\u00e1 disponible 14 de Septiembre 2021). Nosotros para el prop\u00f3sito de este curso usaremos Java 11. \u00bfPorqu\u00e9 Java? Naci\u00f3 en 1995 y todav\u00eda sigue siendo uno de los lenguajes m\u00e1s usados a nivel mundial. Su capacidad de escribirlo y ejecutarlo en cualquier plataforma: \"Write once, run anywhere\" . Desde que naci\u00f3 han salido muchas releases de gran importancia, el lenguaje sigue evolucionando con nuevas funcionalidades. Tiene un comunidad muy grande de c\u00f3digo abierto, documentaci\u00f3n y tutoriales. Es usado por muchas compa\u00f1\u00edas de software, por tanto se ofertan muchos empleos de desarrolladores Java.","title":"Conceptos b\u00e1sicos del lenguaje"},{"location":"ud1/121conceptosbasicos/#java","text":"Java es un lenguaje de programaci\u00f3n orientado a objetos. Fue creado por James Gosling en 1995. Oracle lo compr\u00f3. Es un lenguaje indepediente de la plataforma donde va a ser ejecutado, esto significa, que una vez que se compila (.class tambi\u00e9n llamado bytecode) puede ser transportado a diferentes plataformas (Windows, MacOS, Linux) para ser ejecutado. \u00bfC\u00f3mo se hace esto? Utilizando la JVM (Java Virtual Machine). La JVM coge los bytecode compilados y los interpreta dependiendo del OS para poder ser ejecutado. Por tanto, el bytecode siempre es el mismo, pero lo que genera la JVM cambiar\u00e1 para cada SO. Tambi\u00e9n existen otros t\u00e9rminos muy famosos relacionados con Java como JRE y JDK.","title":"JAVA "},{"location":"ud1/121conceptosbasicos/#jre","text":"Java Runtime Environment . La m\u00e1quina virtual de Java est\u00e1 incluida en el JRE. Se utiliza para ejecutar aplicaciones Java en el SO, por tanto si queremos desplegar una aplicaci\u00f3n en Java, necesitamos tener instalado previamente el JRE para esa m\u00e1quina y plataforma.","title":"JRE"},{"location":"ud1/121conceptosbasicos/#jdk","text":"Java Development Kit . Es m\u00e1s pesado que el JRE, contiene todas las herramientas para programar y compilar las clases Java en bytecode, por tanto cuando desarrollamos clases Java necesitamos el JDK. Adem\u00e1s incluy el JRE.","title":"JDK"},{"location":"ud1/121conceptosbasicos/#versiones-java","text":"La \u00faltima versi\u00f3n de Java se conoce como LTS Release (Long Term Support), y es JAVA 11 LTS ( la LTS 17 estar\u00e1 disponible 14 de Septiembre 2021). Nosotros para el prop\u00f3sito de este curso usaremos Java 11.","title":"Versiones Java"},{"location":"ud1/121conceptosbasicos/#porque-java","text":"Naci\u00f3 en 1995 y todav\u00eda sigue siendo uno de los lenguajes m\u00e1s usados a nivel mundial. Su capacidad de escribirlo y ejecutarlo en cualquier plataforma: \"Write once, run anywhere\" . Desde que naci\u00f3 han salido muchas releases de gran importancia, el lenguaje sigue evolucionando con nuevas funcionalidades. Tiene un comunidad muy grande de c\u00f3digo abierto, documentaci\u00f3n y tutoriales. Es usado por muchas compa\u00f1\u00edas de software, por tanto se ofertan muchos empleos de desarrolladores Java.","title":"\u00bfPorqu\u00e9 Java?"},{"location":"ud1/122setup/","text":"\u00bfQu\u00e9 se necesita para programar en Java? Instalar el JDK versi\u00f3n 11. Lo podemos descarga desde la p\u00e1gina oficial de Oracle. Instalar un IDE (Integrated Development Environment), es un programa que te ayudar a desarrollar aplicaciones. Hay muchas opciones disponibles de IDEs. Setup Java 11 y IntelliJ en Windows Vamos a la p\u00e1gina de Oracle y descargamos JDK 11. Instalamos el JDK. En linux usamos el siguiente comando para instalar el jdk: sudo apt-get install openjdk-11-jdk Windows: A\u00f1adimos en las variables de entorno del sistema dentro de la variable Path, la ruta donde se ha instalado java en nuestra m\u00e1quina (C:\\Program Files\\Java\\jdk-11\\bin) Windows: Agregamos tambi\u00e9n una nueva variable llamada JAVA_HOME --> C:\\Program Files\\Java\\jdk-11 (Ruta de nuestra m\u00e1quina). Verificamos que se ha instalado java, ejecutando desde l\u00ednea de comandos: java --version Descargamos e instalamos IntelliJ Community En File -> Settings, modificamos las siguientes opciones:","title":"Setup"},{"location":"ud1/122setup/#que-se-necesita-para-programar-en-java","text":"Instalar el JDK versi\u00f3n 11. Lo podemos descarga desde la p\u00e1gina oficial de Oracle. Instalar un IDE (Integrated Development Environment), es un programa que te ayudar a desarrollar aplicaciones. Hay muchas opciones disponibles de IDEs.","title":"\u00bfQu\u00e9 se necesita para programar en Java?"},{"location":"ud1/122setup/#setup-java-11-y-intellij-en-windows","text":"Vamos a la p\u00e1gina de Oracle y descargamos JDK 11. Instalamos el JDK. En linux usamos el siguiente comando para instalar el jdk: sudo apt-get install openjdk-11-jdk Windows: A\u00f1adimos en las variables de entorno del sistema dentro de la variable Path, la ruta donde se ha instalado java en nuestra m\u00e1quina (C:\\Program Files\\Java\\jdk-11\\bin) Windows: Agregamos tambi\u00e9n una nueva variable llamada JAVA_HOME --> C:\\Program Files\\Java\\jdk-11 (Ruta de nuestra m\u00e1quina). Verificamos que se ha instalado java, ejecutando desde l\u00ednea de comandos: java --version Descargamos e instalamos IntelliJ Community En File -> Settings, modificamos las siguientes opciones:","title":"Setup Java 11 y IntelliJ en Windows"},{"location":"ud1/123holamundo/","text":"Proyecto \"Hola Mundo\". Estructura de un programa Cada vez que est\u00e1s aprendiendo un nuevo lenguaje de programaci\u00f3n es una tradici\u00f3n crear un nuevo programa muy simple que genera el texto Hola mundo . Veamos como podemos hacer esto en IntelliJ. Hacemos click en crear nuevo proyecto y elegimos el JDK 11 que hemos instalado. Luego en Next, Next, a\u00f1adimos nombre al proyecto y Finish. Creamos una nueva clase Java llamada Hello.java Vamos a crear un m\u00e9todo para imprimir el mensaje Hola mundo . Usaremos un m\u00e9todo especial llamado main . El main es el primer m\u00e9todo que Java busca y ejecuta en el proyecto. Es el punto de entrada. Ejecutamos el programa mediante A\u00f1adimos y ejecutamos la siguiente sentencia dentro del m\u00e9todo main: System.out.println(\"Hello World\"); Challenge Question Modifica el programa para que imprima por pantalla Hello Teacher . Question Realizar las actividades 1 y 2.","title":"Proyecto Hola Mundo"},{"location":"ud1/123holamundo/#proyecto-hola-mundo-estructura-de-un-programa","text":"Cada vez que est\u00e1s aprendiendo un nuevo lenguaje de programaci\u00f3n es una tradici\u00f3n crear un nuevo programa muy simple que genera el texto Hola mundo . Veamos como podemos hacer esto en IntelliJ. Hacemos click en crear nuevo proyecto y elegimos el JDK 11 que hemos instalado. Luego en Next, Next, a\u00f1adimos nombre al proyecto y Finish. Creamos una nueva clase Java llamada Hello.java Vamos a crear un m\u00e9todo para imprimir el mensaje Hola mundo . Usaremos un m\u00e9todo especial llamado main . El main es el primer m\u00e9todo que Java busca y ejecuta en el proyecto. Es el punto de entrada. Ejecutamos el programa mediante A\u00f1adimos y ejecutamos la siguiente sentencia dentro del m\u00e9todo main: System.out.println(\"Hello World\");","title":"Proyecto \"Hola Mundo\". Estructura de un programa"},{"location":"ud1/123holamundo/#challenge","text":"Question Modifica el programa para que imprima por pantalla Hello Teacher . Question Realizar las actividades 1 y 2.","title":"Challenge"},{"location":"ud1/131variables/","text":"Variables Las variables en Java es una forma de almacenar informaci\u00f3n en nuestro ordenador. Definimos variables asign\u00e1ndoles un nombre. De igual manera se puede acceder a la informaci\u00f3n que guardar las variable, simplemente accediendo por el nombre que le hemos dado. Es el ordenador el que se encarga de averiguar d\u00f3nde se almacena internamente en la memoria RAM del ordenador. Como su nombre indica \"variable\", se puede modificar el contenido que \u00e9sta almacena, es decir, es variable. Lo \u00fanico que tenemos que hacer es decirle al PC qu\u00e9 tipo de informaci\u00f3n queremos guardar en nuestra variable y darle un nombre. Existe diferentes tipos de informaci\u00f3n que podemos utilizar para definir nuestras variables. Se les conoce como tipos de datos o data types. Los tipos de datos son palabras reservas keywords en Java, es decir, no podemos utilizarlas fuera del contexto de tipo de datos. Para definir una variable, necesitamos especificar el tipo de datos, luego darle un nombre a nuestra variable, y opcionalmente, podemos agregar una expresi\u00f3n para inicializar la variable con un valor. Reglas para el nombrado de variables Tiene que comenzar con una letra o '_', nunca con n\u00fameros. Puede contener n\u00fameros. No debe contener espacios en blanco. No debe ser muy largo y debe expresar algo en el contexto. No se pueden usar palabras reservadas. May\u00fasculas y min\u00fasculas se tratan diferente. Definimos nuestra primera variable en el programa de la siguiente forma: La l\u00ednea que acabamos de escribir se conoce como sentencia de declaraci\u00f3n . Keywords Son palabras reservadas del lenguaje. Es decir, son palabras que tienen un significado especial en Java y no puedes usarlas fuera de ese contexto. Ejemplos: public, class, void, static, etc. Existen 61 keywords en Java. Vida de las variables Las variables son memorias reservadas para almacenar valores en RAM. Estas posiciones de memoria se liberan tan pronto como termina la vida de la variable. Seg\u00fan la vida de las variables, hay tres tipos de Variables. 1. Variables locales : La vida permanece dentro de un bloque donde se ha declarado. 2. Variables de instancia : Declaradas dentro de la clase pero fuera de los m\u00e9todos. No deber\u00eda ser est\u00e1tico. 3. Variables est\u00e1ticas : es como una variable global. Declarado como est\u00e1tico en la clase pero fuera de los m\u00e9todos. static int pi = 3.14 ; Visibilidad En las variables locales, su \u00e1mbito y uso se encuentra dentro del m\u00e9todo o bloque en el que se defini\u00f3 y se destruyen despu\u00e9s de la ejecuci\u00f3n del m\u00e9todo. Es decir, no se puede usar una variable local fuera del m\u00e9todo actual. A las variables de instancia se puede acceder solo a trav\u00e9s de objetos de la clase para la que se defini\u00f3. Un campo / variable est\u00e1tico pertenece a la clase y se cargar\u00e1 en la memoria junto con la clase. Se invocan sin crear un objeto. (Usando el nombre de la clase como referencia). Solo hay una copia de la variable est\u00e1tica disponible en toda la clase, es decir, el valor de la variable est\u00e1tica ser\u00e1 el mismo en todos los objetos. Puede definir una variable est\u00e1tica utilizando la palabra clave static .","title":"Variables"},{"location":"ud1/131variables/#variables","text":"Las variables en Java es una forma de almacenar informaci\u00f3n en nuestro ordenador. Definimos variables asign\u00e1ndoles un nombre. De igual manera se puede acceder a la informaci\u00f3n que guardar las variable, simplemente accediendo por el nombre que le hemos dado. Es el ordenador el que se encarga de averiguar d\u00f3nde se almacena internamente en la memoria RAM del ordenador. Como su nombre indica \"variable\", se puede modificar el contenido que \u00e9sta almacena, es decir, es variable. Lo \u00fanico que tenemos que hacer es decirle al PC qu\u00e9 tipo de informaci\u00f3n queremos guardar en nuestra variable y darle un nombre. Existe diferentes tipos de informaci\u00f3n que podemos utilizar para definir nuestras variables. Se les conoce como tipos de datos o data types. Los tipos de datos son palabras reservas keywords en Java, es decir, no podemos utilizarlas fuera del contexto de tipo de datos. Para definir una variable, necesitamos especificar el tipo de datos, luego darle un nombre a nuestra variable, y opcionalmente, podemos agregar una expresi\u00f3n para inicializar la variable con un valor.","title":"Variables"},{"location":"ud1/131variables/#reglas-para-el-nombrado-de-variables","text":"Tiene que comenzar con una letra o '_', nunca con n\u00fameros. Puede contener n\u00fameros. No debe contener espacios en blanco. No debe ser muy largo y debe expresar algo en el contexto. No se pueden usar palabras reservadas. May\u00fasculas y min\u00fasculas se tratan diferente. Definimos nuestra primera variable en el programa de la siguiente forma: La l\u00ednea que acabamos de escribir se conoce como sentencia de declaraci\u00f3n .","title":"Reglas para el nombrado de variables"},{"location":"ud1/131variables/#keywords","text":"Son palabras reservadas del lenguaje. Es decir, son palabras que tienen un significado especial en Java y no puedes usarlas fuera de ese contexto. Ejemplos: public, class, void, static, etc. Existen 61 keywords en Java.","title":"Keywords"},{"location":"ud1/131variables/#vida-de-las-variables","text":"Las variables son memorias reservadas para almacenar valores en RAM. Estas posiciones de memoria se liberan tan pronto como termina la vida de la variable. Seg\u00fan la vida de las variables, hay tres tipos de Variables. 1. Variables locales : La vida permanece dentro de un bloque donde se ha declarado. 2. Variables de instancia : Declaradas dentro de la clase pero fuera de los m\u00e9todos. No deber\u00eda ser est\u00e1tico. 3. Variables est\u00e1ticas : es como una variable global. Declarado como est\u00e1tico en la clase pero fuera de los m\u00e9todos. static int pi = 3.14 ;","title":"Vida de las variables"},{"location":"ud1/131variables/#visibilidad","text":"En las variables locales, su \u00e1mbito y uso se encuentra dentro del m\u00e9todo o bloque en el que se defini\u00f3 y se destruyen despu\u00e9s de la ejecuci\u00f3n del m\u00e9todo. Es decir, no se puede usar una variable local fuera del m\u00e9todo actual. A las variables de instancia se puede acceder solo a trav\u00e9s de objetos de la clase para la que se defini\u00f3. Un campo / variable est\u00e1tico pertenece a la clase y se cargar\u00e1 en la memoria junto con la clase. Se invocan sin crear un objeto. (Usando el nombre de la clase como referencia). Solo hay una copia de la variable est\u00e1tica disponible en toda la clase, es decir, el valor de la variable est\u00e1tica ser\u00e1 el mismo en todos los objetos. Puede definir una variable est\u00e1tica utilizando la palabra clave static .","title":"Visibilidad"},{"location":"ud1/132sentencias/","text":"Sentencias Hemos comentado que un programa es un conjunto de instrucciones. Estas instrucciones se llaman sentencias o statements en ingl\u00e9s. Una sentencia es un segmento de c\u00f3digo que realiza una acci\u00f3n en el programa. A medida que se ejecuta un programa, decimos que ejecuta sentencias, lo que significa que lleva a cabo las acciones especificadas por esas sentencias. En nuestro programa Hello World, tenemos un statement en la l\u00ednea 4 y 6 . La regla en Java es que las sentencias deben terminar con un punto y coma. Si se olvida, se producir\u00eda un error de sintaxis. Sentencias de declaraci\u00f3n Se usan para definir una variable de un tipo de dato en particular. En Java, una variable debe declararse antes de que pueda usarse en un programa. De no hacerlo, se producir\u00eda un error de sintaxis. En su forma m\u00e1s simple una declaraci\u00f3n incluye el tipo de datos y el nombre de la variable. Opcionalmente se puede establecer la variable a cierto valor. Es decir, se dice que se ha inicializado. Ejemplos : int numero ; int a = 3 ; //se crea la variable a y se le asigna el valor 3 int dia ; Sentencias de asignaci\u00f3n Una sentencia de asignaci\u00f3n es una sentencia que almacena (asigna) un valor en una variable. Una sentencia de asignaci\u00f3n utiliza el signo igual (=) como operador de asignaci\u00f3n. En su forma m\u00e1s simple, tiene una variable en el lado izquierdo del signo igual y alg\u00fan tipo de valor en el lado derecho. Ejemplos : numero = 6 ; //asigno el valor 6 a la variable numero a = 0 ; dia = 22 ; En el siguiente ejemplo, hay variables tanto a la izquierda como a la derecha del operador de asignaci\u00f3n (=). Pero tienen un significado muy diferente. La variable de la derecha (num2) se trata como un valor. Si esa variable almacena 20, entonces ese es su valor. De hecho, cualquier cosa que ocurra en el lado derecho de un operador de asignaci\u00f3n se trata como un valor. La variable de la izquierda (num1) se trata como una ubicaci\u00f3n de memoria. Es donde se almacenar\u00e1 el valor 20 como resultado de la ejecuci\u00f3n de esta declaraci\u00f3n. El efecto de esta declaraci\u00f3n es copia el valor almacenado en num2 en num1, como se ilustra en la siguiente imagen. Ejemplo //se crean las variables int num1 = 10 ; int num2 = 20 ; num1 = num2 ; //se copia el valor de num2 a la variable num1 Challenge Question En el programa Hello World, imprime por pantalla la variable miPrimerEntero que hemos creado. Challenge2 Question En el programa Hello World, crea las siguientes variables adicionales justo debajo de la declaraci\u00f3n \"int miPrimerEntero = 7;\" en el programa: num1 de tipo int y con un valor de 10. num2 de tipo int y con un valor de 8. y una tercera total que sea la suma de las anteriores. imprime por pantalla la variable total. Paquetes en Java - Java Packages Un paquete es una forma de organizar nuestros proyectos Java. Se pueden ver como carpetas dentro de la estructuraci\u00f3n interna del proyecto. Los paquetes son el mecanismo que usa Java para facilitar la modularidad del c\u00f3digo. Un paquete puede contener una o m\u00e1s definiciones de interfaces y clases, distribuy\u00e9ndose habitualmente como un archivo. Para utilizar los elementos de un paquete es necesario importar este en el m\u00f3dulo de c\u00f3digo en curso, usando para ello la sentencia import . IntelliJ nos ofrece la opci\u00f3n de automatizar esto cuando creamos un proyecto, simplemente seleccionando la opci\u00f3n:","title":"Sentencias y paquetes"},{"location":"ud1/132sentencias/#sentencias","text":"Hemos comentado que un programa es un conjunto de instrucciones. Estas instrucciones se llaman sentencias o statements en ingl\u00e9s. Una sentencia es un segmento de c\u00f3digo que realiza una acci\u00f3n en el programa. A medida que se ejecuta un programa, decimos que ejecuta sentencias, lo que significa que lleva a cabo las acciones especificadas por esas sentencias. En nuestro programa Hello World, tenemos un statement en la l\u00ednea 4 y 6 . La regla en Java es que las sentencias deben terminar con un punto y coma. Si se olvida, se producir\u00eda un error de sintaxis.","title":"Sentencias"},{"location":"ud1/132sentencias/#sentencias-de-declaracion","text":"Se usan para definir una variable de un tipo de dato en particular. En Java, una variable debe declararse antes de que pueda usarse en un programa. De no hacerlo, se producir\u00eda un error de sintaxis. En su forma m\u00e1s simple una declaraci\u00f3n incluye el tipo de datos y el nombre de la variable. Opcionalmente se puede establecer la variable a cierto valor. Es decir, se dice que se ha inicializado. Ejemplos : int numero ; int a = 3 ; //se crea la variable a y se le asigna el valor 3 int dia ;","title":"Sentencias de declaraci\u00f3n"},{"location":"ud1/132sentencias/#sentencias-de-asignacion","text":"Una sentencia de asignaci\u00f3n es una sentencia que almacena (asigna) un valor en una variable. Una sentencia de asignaci\u00f3n utiliza el signo igual (=) como operador de asignaci\u00f3n. En su forma m\u00e1s simple, tiene una variable en el lado izquierdo del signo igual y alg\u00fan tipo de valor en el lado derecho. Ejemplos : numero = 6 ; //asigno el valor 6 a la variable numero a = 0 ; dia = 22 ; En el siguiente ejemplo, hay variables tanto a la izquierda como a la derecha del operador de asignaci\u00f3n (=). Pero tienen un significado muy diferente. La variable de la derecha (num2) se trata como un valor. Si esa variable almacena 20, entonces ese es su valor. De hecho, cualquier cosa que ocurra en el lado derecho de un operador de asignaci\u00f3n se trata como un valor. La variable de la izquierda (num1) se trata como una ubicaci\u00f3n de memoria. Es donde se almacenar\u00e1 el valor 20 como resultado de la ejecuci\u00f3n de esta declaraci\u00f3n. El efecto de esta declaraci\u00f3n es copia el valor almacenado en num2 en num1, como se ilustra en la siguiente imagen. Ejemplo //se crean las variables int num1 = 10 ; int num2 = 20 ; num1 = num2 ; //se copia el valor de num2 a la variable num1","title":"Sentencias de asignaci\u00f3n"},{"location":"ud1/132sentencias/#challenge","text":"Question En el programa Hello World, imprime por pantalla la variable miPrimerEntero que hemos creado.","title":"Challenge"},{"location":"ud1/132sentencias/#challenge2","text":"Question En el programa Hello World, crea las siguientes variables adicionales justo debajo de la declaraci\u00f3n \"int miPrimerEntero = 7;\" en el programa: num1 de tipo int y con un valor de 10. num2 de tipo int y con un valor de 8. y una tercera total que sea la suma de las anteriores. imprime por pantalla la variable total.","title":"Challenge2"},{"location":"ud1/132sentencias/#paquetes-en-java-java-packages","text":"Un paquete es una forma de organizar nuestros proyectos Java. Se pueden ver como carpetas dentro de la estructuraci\u00f3n interna del proyecto. Los paquetes son el mecanismo que usa Java para facilitar la modularidad del c\u00f3digo. Un paquete puede contener una o m\u00e1s definiciones de interfaces y clases, distribuy\u00e9ndose habitualmente como un archivo. Para utilizar los elementos de un paquete es necesario importar este en el m\u00f3dulo de c\u00f3digo en curso, usando para ello la sentencia import . IntelliJ nos ofrece la opci\u00f3n de automatizar esto cuando creamos un proyecto, simplemente seleccionando la opci\u00f3n:","title":"Paquetes en Java - Java Packages"},{"location":"ud1/142noprimitive/","text":"No primitivos u objetos En Java, los tipos de datos no primitivos son los tipos de datos de referencia o los tipos de datos creados por el usuario. Todos los tipos de datos no primitivos se implementan utilizando conceptos de objeto. Cada variable del tipo de datos no primitivo es un objeto. Los tipos de datos no primitivos pueden utilizar m\u00e9todos adicionales para realizar determinadas operaciones. El valor predeterminado de la variable de tipo de datos no primitivos es nulo. String - Cadena de caracteres String es una clase integrada en el lenguaje Java ampliamente utilizada y definido en el paquete java.lang. Representa cadenas de caracteres y se utilizan para almacenar varios atributos como nombre de usuario, contrase\u00f1a, etc. Los String son inmutables ; es decir, no se pueden modificar una vez creados. Siempre que se modifica un objeto String, en realidad se crea uno nuevo String. Existen varias formas para crear un String: String texto = \"Severo Ochoa\" ; String texto2 = new String ( \"Severo Ochoa\" ); Asignaci\u00f3n de memoria de objetos String La memoria se divide en dos partes, el String Pool y la memoria Heap. Veamos como funcionar\u00eda para la imagen anterior. Siempre que creamos un String con comillas dobles, se almacenan en String Pool. String Pool almacena el \u00fanico valor en \u00e9l. Es por eso que, String s1 = \"blogs\" se almacenan como el primer valor en el String Pool. Siempre que creamos un objeto usando la palabra clave new , se almacena en la memoria Heap pero fuera del String Pool. Aqu\u00ed se puede almacenar valores duplicados ya que pertenece a diferentes objetos. Entonces, para la declaraci\u00f3n String s2 = new String(\u201cblogs\u201d), aunque el valor de s1 y s2 es el mismo, s2 se almacenar\u00e1 fuera del String Pool. Cuando creamos otro String usando comillas dobles, primero verifica todos los valores en el String Pool y si coincide con alguno se asigna la misma ubicaci\u00f3n asignada a otro objeto de referencia. Por lo tanto, String s3 = \u201dblogs\u201d no agregar\u00e1 una nueva entrada en el String Pool. Pero si creamos otro objeto con un valor existente usando la palabra clave new . Asignar\u00e1 nueva memoria al nuevo objeto en el Heap. Por lo tanto, a String s4 = new String (\"blogs\") se le asignar\u00e1 nueva memoria. Ahora, si manipulamos el valor en s1 usando s1 = \u201dNew\u201c + s1, no actualizar\u00e1 la entrada o referencia existente de s1. Este proceso crear\u00e1 una nueva entrada en el String Pool con el valor \"New blogs\" y la referencia de memoria cambiar\u00eda para el objeto s1. Java String Class Methods La clase java.lang.String proporciona muchos m\u00e9todos \u00fatiles para realizar operaciones en la secuencia de valores char. Date En sus inicios se crearon las clases java.util.Date y java.sql.Date para almacenar y manejar fechas. Pero ambas clases son defectuosas en dise\u00f1o e implementaci\u00f3n. Por ejemplo, las clases existentes (como java.util.Date y SimpleDateFormatter ) no son thread-safe, lo que genera posibles problemas de concurrencia para los usuarios. Por tanto, desde Java 8 y posteriores se ha desarrollado una nueva API java.time que resuelve los problemas que presentaban las librer\u00edas anteriores. More information Why do we need a new date and time library? Ejemplo de c\u00f3digo para mostara la fecha y la hora: //mostrar fecha LocalDate ld = LocalDate . now (); System . out . println ( ld ); //mostrar hora LocalTime lt = LocalTime . now (); System . out . println ( lt ); //mostrar fecha y hora LocalDateTime ldt = LocalDateTime . now (); System . out . println ( ldt ); //formatear la fecha con un formato dado DateTimeFormatter formatter = DateTimeFormatter . ofPattern ( \"dd-MM-yyyy HH:mm:ss\" ); String formatted = formatter . format ( ldt ); System . out . println ( formatted ); Enum en Java El tipo enumerado es un tipo de datos especial que permite que una variable sea un conjunto de constantes predefinidas. La variable debe ser igual a uno de los valores que se han predefinido para ella. Debido a que son constantes, los nombres de los campos del tipo enum deben estar en letras may\u00fasculas. En Java, se define un enumerado utilizando la palabra clave enum seguido del nombre siguiendo la convenci\u00f3n del nombrado de clases. Primera letra en may\u00fascula y CamelCase. Para crear un enum en Java, bot\u00f3n derecho en el paquete --> new Java class y seleccionamos enum. Ejemplo de enumerado: public enum PuntosCardinales { NORTE , SUR , ESTE , OESTE } public class Main { public static void main ( String [] args ) { PuntosCardinales myVar = PuntosCardinales . ESTE ; System . out . println ( myVar ); } }","title":"Datos no primitivos"},{"location":"ud1/142noprimitive/#no-primitivos-u-objetos","text":"En Java, los tipos de datos no primitivos son los tipos de datos de referencia o los tipos de datos creados por el usuario. Todos los tipos de datos no primitivos se implementan utilizando conceptos de objeto. Cada variable del tipo de datos no primitivo es un objeto. Los tipos de datos no primitivos pueden utilizar m\u00e9todos adicionales para realizar determinadas operaciones. El valor predeterminado de la variable de tipo de datos no primitivos es nulo.","title":"No primitivos u objetos"},{"location":"ud1/142noprimitive/#string-cadena-de-caracteres","text":"String es una clase integrada en el lenguaje Java ampliamente utilizada y definido en el paquete java.lang. Representa cadenas de caracteres y se utilizan para almacenar varios atributos como nombre de usuario, contrase\u00f1a, etc. Los String son inmutables ; es decir, no se pueden modificar una vez creados. Siempre que se modifica un objeto String, en realidad se crea uno nuevo String. Existen varias formas para crear un String: String texto = \"Severo Ochoa\" ; String texto2 = new String ( \"Severo Ochoa\" );","title":"String - Cadena de caracteres"},{"location":"ud1/142noprimitive/#asignacion-de-memoria-de-objetos-string","text":"La memoria se divide en dos partes, el String Pool y la memoria Heap. Veamos como funcionar\u00eda para la imagen anterior. Siempre que creamos un String con comillas dobles, se almacenan en String Pool. String Pool almacena el \u00fanico valor en \u00e9l. Es por eso que, String s1 = \"blogs\" se almacenan como el primer valor en el String Pool. Siempre que creamos un objeto usando la palabra clave new , se almacena en la memoria Heap pero fuera del String Pool. Aqu\u00ed se puede almacenar valores duplicados ya que pertenece a diferentes objetos. Entonces, para la declaraci\u00f3n String s2 = new String(\u201cblogs\u201d), aunque el valor de s1 y s2 es el mismo, s2 se almacenar\u00e1 fuera del String Pool. Cuando creamos otro String usando comillas dobles, primero verifica todos los valores en el String Pool y si coincide con alguno se asigna la misma ubicaci\u00f3n asignada a otro objeto de referencia. Por lo tanto, String s3 = \u201dblogs\u201d no agregar\u00e1 una nueva entrada en el String Pool. Pero si creamos otro objeto con un valor existente usando la palabra clave new . Asignar\u00e1 nueva memoria al nuevo objeto en el Heap. Por lo tanto, a String s4 = new String (\"blogs\") se le asignar\u00e1 nueva memoria. Ahora, si manipulamos el valor en s1 usando s1 = \u201dNew\u201c + s1, no actualizar\u00e1 la entrada o referencia existente de s1. Este proceso crear\u00e1 una nueva entrada en el String Pool con el valor \"New blogs\" y la referencia de memoria cambiar\u00eda para el objeto s1.","title":"Asignaci\u00f3n de memoria de objetos String"},{"location":"ud1/142noprimitive/#java-string-class-methods","text":"La clase java.lang.String proporciona muchos m\u00e9todos \u00fatiles para realizar operaciones en la secuencia de valores char.","title":"Java String Class Methods"},{"location":"ud1/142noprimitive/#date","text":"En sus inicios se crearon las clases java.util.Date y java.sql.Date para almacenar y manejar fechas. Pero ambas clases son defectuosas en dise\u00f1o e implementaci\u00f3n. Por ejemplo, las clases existentes (como java.util.Date y SimpleDateFormatter ) no son thread-safe, lo que genera posibles problemas de concurrencia para los usuarios. Por tanto, desde Java 8 y posteriores se ha desarrollado una nueva API java.time que resuelve los problemas que presentaban las librer\u00edas anteriores. More information Why do we need a new date and time library? Ejemplo de c\u00f3digo para mostara la fecha y la hora: //mostrar fecha LocalDate ld = LocalDate . now (); System . out . println ( ld ); //mostrar hora LocalTime lt = LocalTime . now (); System . out . println ( lt ); //mostrar fecha y hora LocalDateTime ldt = LocalDateTime . now (); System . out . println ( ldt ); //formatear la fecha con un formato dado DateTimeFormatter formatter = DateTimeFormatter . ofPattern ( \"dd-MM-yyyy HH:mm:ss\" ); String formatted = formatter . format ( ldt ); System . out . println ( formatted );","title":"Date"},{"location":"ud1/142noprimitive/#enum-en-java","text":"El tipo enumerado es un tipo de datos especial que permite que una variable sea un conjunto de constantes predefinidas. La variable debe ser igual a uno de los valores que se han predefinido para ella. Debido a que son constantes, los nombres de los campos del tipo enum deben estar en letras may\u00fasculas. En Java, se define un enumerado utilizando la palabra clave enum seguido del nombre siguiendo la convenci\u00f3n del nombrado de clases. Primera letra en may\u00fascula y CamelCase. Para crear un enum en Java, bot\u00f3n derecho en el paquete --> new Java class y seleccionamos enum. Ejemplo de enumerado: public enum PuntosCardinales { NORTE , SUR , ESTE , OESTE } public class Main { public static void main ( String [] args ) { PuntosCardinales myVar = PuntosCardinales . ESTE ; System . out . println ( myVar ); } }","title":"Enum en Java"},{"location":"ud1/143string/","text":"String en Java Un String es un tipo de dato no primitvo que, en Java representa una cadena de caracteres no modificable. Todos los literales de la forma \"cualquier texto\", es decir, literales entre comillas dobles, que aparecen en un programa java se implementan como objetos de la clase String. A diferencia de muchos objetos vimos que un String se puede crear sin la palabra new. String text = \"hola\"; Creaci\u00f3n de String Se puede crear un String de varias formas. String texto = \"Severo Ochoa\" ; //Utilizando new String texto2 = new String ( \"Severo Ochoa\" ); //Utilizando el operador concatenaci\u00f3n + String s2 = text + \" 2021\" ; //s2 contiene \"Severo Ochoa 2021\" El operador concatenaci\u00f3n La clase proporciona el operador + (concatenaci\u00f3n) para unir dos o m\u00e1s String. El resultado de aplicar este operador es un nuevo String concatenaci\u00f3n de los otros. Por ejemplo, si tenemos dos String b y c: String b = \"Ordenador\" ; String c = \" Port\u00e1til\" ; La operaci\u00f3n b = b + c ; Crea un nuevo String que se incluye en el String Pool: \u00cdndices Cada uno de los caracteres que forman un String son del tipo primitivo char . Los caracteres de un string est\u00e1n numerados internamente con \u00edndices empezando desde el cero: El primer car\u00e1cter tiene \u00edndice 0 y el \u00faltimo tiene la longitud del string menos 1. M\u00e9todos de la clase String La clase String proporciona m\u00e9todos para el tratamiento de las cadenas de caracteres: acceso a caracteres individuales, buscar y extraer una subcadena, copiar cadenas, convertir cadenas a may\u00fasculas o min\u00fasculas, etc. Para acceder a alguno de los m\u00e9todos siguientes utilizamos la notaci\u00f3n \".\" String texto = \"Clase\" ; int longitud = texto . length (); //devuelve 5 Tip Para m\u00e1s informaci\u00f3n consulta la documentaci\u00f3n oficial de la clase String Comparar Strings Los operadores relacionales como == o < > NO se utilizan para comparar Strings, aunque el c\u00f3digo compile no es correcto, ya que == compara objetos, y devolver\u00eda falso aunque dos strings tuvieran el mismo texto puesto que son objetos diferentes. Para comparar strings utilizamos el m\u00e9todo equals . String name = \"Patri\" ; if ( name . equals ( \"Patri\" )) { System . out . println ( \"Coincide.\" ); } La siguiente tabla muestra los m\u00e9todos que se utilizan para comparar Strings. char dentro de String Como se ha comentado, un String est\u00e1 compuesto de caracteres tipo char. Para acceder a los caracteres dentro de un String usamos el m\u00e9todo charAt . Se puede usar la concatenaci\u00f3n + para concatenar char con String. String food = \"cookie\" ; char firstLetter = food . charAt ( 0 ); // 'c' System . out . println ( firstLetter + \" is for \" + food ); Tambi\u00e9n podemos recorrer el String con un bucle for e imprimir cada uno de los caracteres que lo forman. String major = \"CSE\" ; for ( int i = 0 ; i < major . length (); i ++ ) { char c = major . charAt ( i ); System . out . println ( c ); } OUTPUT C S E char A todos los valores char se les asigna un n\u00famero internamente por el ordenador, son los llamados valores ASCII. Por ejemplo: el car\u00e1cter 'A' es 65 en c\u00f3digo ASCII el car\u00e1cter 'a' es 97 en c\u00f3digo ASCII Mezclar tipos de datos char e int autom\u00e1ticamente cause una conversi\u00f3n en entero. Por ejemplo: 'a' + 10 --> devuelve 107. Para convertir un entero en su equivalente a car\u00e1cter (char) har\u00edamos: (char) ('a' + 2) --> devuelve 'c'. Diferencias entre char y String String es un objeto, por tanto, contiene m\u00e9todos. char es un tipo de dato primitivo, no puedes llamar a m\u00e9todos con \u00e9l. String utiliza comillas dobles. char utiliza comillas simples. No se puede comparar un String usando operadores relacionales. Si se puede comparar un char usando operadores relacionales: 'a' < 'b', 'X' == 'X', ...","title":"String"},{"location":"ud1/143string/#string-en-java","text":"Un String es un tipo de dato no primitvo que, en Java representa una cadena de caracteres no modificable. Todos los literales de la forma \"cualquier texto\", es decir, literales entre comillas dobles, que aparecen en un programa java se implementan como objetos de la clase String. A diferencia de muchos objetos vimos que un String se puede crear sin la palabra new. String text = \"hola\";","title":"String en Java"},{"location":"ud1/143string/#creacion-de-string","text":"Se puede crear un String de varias formas. String texto = \"Severo Ochoa\" ; //Utilizando new String texto2 = new String ( \"Severo Ochoa\" ); //Utilizando el operador concatenaci\u00f3n + String s2 = text + \" 2021\" ; //s2 contiene \"Severo Ochoa 2021\"","title":"Creaci\u00f3n de String"},{"location":"ud1/143string/#el-operador-concatenacion","text":"La clase proporciona el operador + (concatenaci\u00f3n) para unir dos o m\u00e1s String. El resultado de aplicar este operador es un nuevo String concatenaci\u00f3n de los otros. Por ejemplo, si tenemos dos String b y c: String b = \"Ordenador\" ; String c = \" Port\u00e1til\" ; La operaci\u00f3n b = b + c ; Crea un nuevo String que se incluye en el String Pool:","title":"El operador concatenaci\u00f3n"},{"location":"ud1/143string/#indices","text":"Cada uno de los caracteres que forman un String son del tipo primitivo char . Los caracteres de un string est\u00e1n numerados internamente con \u00edndices empezando desde el cero: El primer car\u00e1cter tiene \u00edndice 0 y el \u00faltimo tiene la longitud del string menos 1.","title":"\u00cdndices"},{"location":"ud1/143string/#metodos-de-la-clase-string","text":"La clase String proporciona m\u00e9todos para el tratamiento de las cadenas de caracteres: acceso a caracteres individuales, buscar y extraer una subcadena, copiar cadenas, convertir cadenas a may\u00fasculas o min\u00fasculas, etc. Para acceder a alguno de los m\u00e9todos siguientes utilizamos la notaci\u00f3n \".\" String texto = \"Clase\" ; int longitud = texto . length (); //devuelve 5 Tip Para m\u00e1s informaci\u00f3n consulta la documentaci\u00f3n oficial de la clase String","title":"M\u00e9todos de la clase String"},{"location":"ud1/143string/#comparar-strings","text":"Los operadores relacionales como == o < > NO se utilizan para comparar Strings, aunque el c\u00f3digo compile no es correcto, ya que == compara objetos, y devolver\u00eda falso aunque dos strings tuvieran el mismo texto puesto que son objetos diferentes. Para comparar strings utilizamos el m\u00e9todo equals . String name = \"Patri\" ; if ( name . equals ( \"Patri\" )) { System . out . println ( \"Coincide.\" ); } La siguiente tabla muestra los m\u00e9todos que se utilizan para comparar Strings.","title":"Comparar Strings"},{"location":"ud1/143string/#char-dentro-de-string","text":"Como se ha comentado, un String est\u00e1 compuesto de caracteres tipo char. Para acceder a los caracteres dentro de un String usamos el m\u00e9todo charAt . Se puede usar la concatenaci\u00f3n + para concatenar char con String. String food = \"cookie\" ; char firstLetter = food . charAt ( 0 ); // 'c' System . out . println ( firstLetter + \" is for \" + food ); Tambi\u00e9n podemos recorrer el String con un bucle for e imprimir cada uno de los caracteres que lo forman. String major = \"CSE\" ; for ( int i = 0 ; i < major . length (); i ++ ) { char c = major . charAt ( i ); System . out . println ( c ); } OUTPUT C S E","title":"char dentro de String"},{"location":"ud1/143string/#char","text":"A todos los valores char se les asigna un n\u00famero internamente por el ordenador, son los llamados valores ASCII. Por ejemplo: el car\u00e1cter 'A' es 65 en c\u00f3digo ASCII el car\u00e1cter 'a' es 97 en c\u00f3digo ASCII Mezclar tipos de datos char e int autom\u00e1ticamente cause una conversi\u00f3n en entero. Por ejemplo: 'a' + 10 --> devuelve 107. Para convertir un entero en su equivalente a car\u00e1cter (char) har\u00edamos: (char) ('a' + 2) --> devuelve 'c'.","title":"char"},{"location":"ud1/143string/#diferencias-entre-char-y-string","text":"String es un objeto, por tanto, contiene m\u00e9todos. char es un tipo de dato primitivo, no puedes llamar a m\u00e9todos con \u00e9l. String utiliza comillas dobles. char utiliza comillas simples. No se puede comparar un String usando operadores relacionales. Si se puede comparar un char usando operadores relacionales: 'a' < 'b', 'X' == 'X', ...","title":"Diferencias entre char y String"},{"location":"ud1/14datatypejava/","text":"Tipos de datos Un tipo de datos es un conjunto de valores y un conjunto de operaciones definidas en ellos. Se pueden clasificar en primitivos y objetos. Primitivos Los primitivos son los m\u00e1s b\u00e1sicos y fundamentales, vienen integrados en Java. Especifican el tipo de valor almacenado en una variable y el tama\u00f1o de la memoria. Hay 8 tipos primitivos de datos integrados en el lenguaje Java. Estos incluyen: int, byte, short, long, float, double, boolean y char. Primitive data type Wrapper class byte Byte short Short int Integer long Long float Float double Double boolean Boolean char Character byte Como su propio nombre denota, emplea un solo byte (8 bits) de almacenamiento. Esto permite almacenar valores en el rango [-128, 127]. Raramente se usa. Ocupa menos memoria y puede ser m\u00e1s r\u00e1pido accedido. byte b = 2 ; short Usa el doble de almacenamiento que el anterior, es decir, ocupa 16 bits [-32.768, 32.767]. short s = 3467 ; int Emplea 4 bytes (32 bits) de almacenamiento y es el tipo de dato entero m\u00e1s empleado. Necesita cuatro veces el espacio que ocupa un byte. Es el entero predeterminado usado en Java. int maxValor = 2147483647 ; // after java 7 and higher int maxValue = 2_147_483_647 ; long Es el tipo entero de mayor tama\u00f1o, 8 bytes (64 bits). Para definir un long, tenemos que hacerlo de la siguiente forma: long myLongNumber = 500L ; float Tiene una parte flotante que sirve para expresar n\u00fameros decimales. Es de simple precisi\u00f3n (formato y cantidad de espacio que ocupa) porque ocupa 32 bits. No se recomienda mucho su uso. float f = 4 ; float f = 4f ; //tambi\u00e9n v\u00e1lida double Es un n\u00famero de precisi\u00f3n doble y ocupa 64 bits. Es el flotante predeterminado en Java. Se recomienda su uso. Muchas librer\u00edas internas de Java, relacionadas con operaciones matem\u00e1ticas, usan double. double d = 5 ; double d = 5d ; //tambi\u00e9n v\u00e1lida char Se utiliza para almacenar caracteres (letras, n\u00fameros, signos, etc.) individuales. Ocupa 2 bytes en memoria (16 bits). Permite almacenar caracteres Unicode. Unicode es un est\u00e1ndar de codificaci\u00f3n internacional que nos permite representar diferentes idiomas; y la forma en que funciona es usando una combinaci\u00f3n de los dos bytes que un char ocupa en la memoria, que puede representar hasta 65535 diferentes tipos de caracteres. Unicode table. char c = 'P' ; char u = '\\u00A2' ; //print unicode character Un car\u00e1cter precedido por una barra invertida () es una secuencia de escape y tiene un significado especial para el compilador. La siguiente tabla muestra las secuencias de escape de Java: boolean solo permite almacenar dos posibles valores que son true o false . Tiene la finalidad de facilitar el trabajo con valores \"verdadero/falso\" (booleanos), resultantes por regla general de evaluar expresiones. Este tipo de datos representa un bit de informaci\u00f3n, pero su \"tama\u00f1o\" no es algo que est\u00e9 definido con precisi\u00f3n. boolean isMyNamePatri = true ; Wrapper classes (clases contenedores) Las clases contenedoras proporcionan una forma de utilizar tipos de datos primitivos como objetos. En Java, tenemos una Wrapper class para cada uno de los 8 tipos de datos primitivos. Gracias a esto, podemos realizar operaciones en un dato primitivo como por ejemplo en un int: int minimoValorInt = Integer . MIN_VALUE ;","title":"Datos primitivos"},{"location":"ud1/14datatypejava/#tipos-de-datos","text":"Un tipo de datos es un conjunto de valores y un conjunto de operaciones definidas en ellos. Se pueden clasificar en primitivos y objetos.","title":"Tipos de datos"},{"location":"ud1/14datatypejava/#primitivos","text":"Los primitivos son los m\u00e1s b\u00e1sicos y fundamentales, vienen integrados en Java. Especifican el tipo de valor almacenado en una variable y el tama\u00f1o de la memoria. Hay 8 tipos primitivos de datos integrados en el lenguaje Java. Estos incluyen: int, byte, short, long, float, double, boolean y char. Primitive data type Wrapper class byte Byte short Short int Integer long Long float Float double Double boolean Boolean char Character","title":"Primitivos"},{"location":"ud1/14datatypejava/#byte","text":"Como su propio nombre denota, emplea un solo byte (8 bits) de almacenamiento. Esto permite almacenar valores en el rango [-128, 127]. Raramente se usa. Ocupa menos memoria y puede ser m\u00e1s r\u00e1pido accedido. byte b = 2 ;","title":"byte"},{"location":"ud1/14datatypejava/#short","text":"Usa el doble de almacenamiento que el anterior, es decir, ocupa 16 bits [-32.768, 32.767]. short s = 3467 ;","title":"short"},{"location":"ud1/14datatypejava/#int","text":"Emplea 4 bytes (32 bits) de almacenamiento y es el tipo de dato entero m\u00e1s empleado. Necesita cuatro veces el espacio que ocupa un byte. Es el entero predeterminado usado en Java. int maxValor = 2147483647 ; // after java 7 and higher int maxValue = 2_147_483_647 ;","title":"int"},{"location":"ud1/14datatypejava/#long","text":"Es el tipo entero de mayor tama\u00f1o, 8 bytes (64 bits). Para definir un long, tenemos que hacerlo de la siguiente forma: long myLongNumber = 500L ;","title":"long"},{"location":"ud1/14datatypejava/#float","text":"Tiene una parte flotante que sirve para expresar n\u00fameros decimales. Es de simple precisi\u00f3n (formato y cantidad de espacio que ocupa) porque ocupa 32 bits. No se recomienda mucho su uso. float f = 4 ; float f = 4f ; //tambi\u00e9n v\u00e1lida","title":"float"},{"location":"ud1/14datatypejava/#double","text":"Es un n\u00famero de precisi\u00f3n doble y ocupa 64 bits. Es el flotante predeterminado en Java. Se recomienda su uso. Muchas librer\u00edas internas de Java, relacionadas con operaciones matem\u00e1ticas, usan double. double d = 5 ; double d = 5d ; //tambi\u00e9n v\u00e1lida","title":"double"},{"location":"ud1/14datatypejava/#char","text":"Se utiliza para almacenar caracteres (letras, n\u00fameros, signos, etc.) individuales. Ocupa 2 bytes en memoria (16 bits). Permite almacenar caracteres Unicode. Unicode es un est\u00e1ndar de codificaci\u00f3n internacional que nos permite representar diferentes idiomas; y la forma en que funciona es usando una combinaci\u00f3n de los dos bytes que un char ocupa en la memoria, que puede representar hasta 65535 diferentes tipos de caracteres. Unicode table. char c = 'P' ; char u = '\\u00A2' ; //print unicode character Un car\u00e1cter precedido por una barra invertida () es una secuencia de escape y tiene un significado especial para el compilador. La siguiente tabla muestra las secuencias de escape de Java:","title":"char"},{"location":"ud1/14datatypejava/#boolean","text":"solo permite almacenar dos posibles valores que son true o false . Tiene la finalidad de facilitar el trabajo con valores \"verdadero/falso\" (booleanos), resultantes por regla general de evaluar expresiones. Este tipo de datos representa un bit de informaci\u00f3n, pero su \"tama\u00f1o\" no es algo que est\u00e9 definido con precisi\u00f3n. boolean isMyNamePatri = true ;","title":"boolean"},{"location":"ud1/14datatypejava/#wrapper-classes-clases-contenedores","text":"Las clases contenedoras proporcionan una forma de utilizar tipos de datos primitivos como objetos. En Java, tenemos una Wrapper class para cada uno de los 8 tipos de datos primitivos. Gracias a esto, podemos realizar operaciones en un dato primitivo como por ejemplo en un int: int minimoValorInt = Integer . MIN_VALUE ;","title":"Wrapper classes (clases contenedores)"},{"location":"ud1/15operators/","text":"Operadores Los operadores son s\u00edmbolos especiales en Java que realizan operaciones entre uno o varios operandos y devuelve un resultado. Uno de los m\u00e1s usados es el operador suma (+) como hemos visto en clases anteriores. Operando Es cualquier t\u00e9rmino, que puede ser una variable o valor y que es manipulado por un operador. int valor = 8 ; int numero = valor + 12 ; En el ejemplo anterior, + es el operador y valor y 12 son los operandos. valor + 12 es una expresi\u00f3n que devuelve el resultado de 20. Expresiones Una expresi\u00f3n es una combinaci\u00f3n de literales, operadores, nombres de variables y par\u00e9ntesis que se utilizan para calcular un valor. int miPrimerEntero = 7 + 5 ; int resultado = 0 ; resultado = ( miPrimerEntero * 10 ) / ( 32 + 12 ); Java examina la expresi\u00f3n de la derecha del signo igual y realiza el c\u00e1lculo de una expresi\u00f3n matem\u00e1tica. Despu\u00e9s asigna ese valor a la variable resultado. Podr\u00edamos complicar m\u00e1s la expresi\u00f3n utilizando operadores como par\u00e9ntesis, multiplicaciones, divisiones, etc. Las partes de una expresi\u00f3n deben estar ordenadas correctamente. Las reglas para las expresiones Java correctas son casi las mismas que las del \u00e1lgebra: Cada operador debe tener el n\u00famero correcto de operandos. Multiplicaci\u00f3n *, Divisi\u00f3n /, Suma +, Resta: debe tener dos operandos, uno en cada lado. La negaci\u00f3n - y unario m\u00e1s + deben ir seguidos de un operando. Los par\u00e9ntesis () pueden rodear una expresi\u00f3n legal para convertirla en operando. Expresiones mixtas con int y double Si ambos operandos de un operador aritm\u00e9tico son de tipo int, entonces la operaci\u00f3n es una operaci\u00f3n entera. Si alg\u00fan operando es de punto flotante, entonces la operaci\u00f3n es de punto flotante. Tipos de operadores en Java Java proporciona muchos tipos de operadores que se pueden usar seg\u00fan la necesidad. Se clasifican seg\u00fan la funcionalidad que brindan. Algunos de los tipos son los siguientes: Operadores aritm\u00e9ticos, unarios, de asignaci\u00f3n, relacionales, l\u00f3gicos, etc. Operador de asignaci\u00f3n (=) Es uno de los operadores m\u00e1s usados. Se usa para asignar un valor a cualquier variable. Tiene una asociaci\u00f3n de derecha a izquierda, es decir, el valor dado en el lado derecho del operador se asigna a la variable de la izquierda y, por lo tanto, el valor del lado derecho debe declararse antes de usarlo o debe ser una constante. Operadores aritm\u00e9ticos Se utilizan para realizar operaciones aritm\u00e9ticas simples. S\u00edmbolo Operaci\u00f3n Descripci\u00f3n + Suma Realiza la suma de los operandos. - Resta Realiza la resta de los operandos. * Producto Multiplica los operandos. / Divisi\u00f3n Realiza la divisi\u00f3n. % M\u00f3dulo Calcula el resto. Operadores unarios Los operadores unarios solo necesitan un operando. Se usan para incrementar, disminuir o negar un valor. S\u00edmbolo Operaci\u00f3n Descripci\u00f3n ++ Incremento Incrementa el valor en 1 unidad. -- Decremento El valor disminuye en 1 unidad. ! NOT l\u00f3gico Invierte un valor booleano. Existen dos versiones de estos operadores: Pre-incremento y pre-decremento. El valor se aumenta/disminuye primero y luego se calcula el resultado. int a = 8 , b = 1 ; b = ++ a ; //b=9, a=9 Post-Incremento y post-decremento: el valor se usa por primera vez para calcular el resultado y luego se incrementa/decrementa. int a = 8 , b = 1 ; b = a ++ ; //b = 8, a = 9 Operadores relacionales Estos operadores se utilizan para verificar relaciones como igualdad, mayor que, menor que. Devuelven el resultado booleano despu\u00e9s de la comparaci\u00f3n. S\u00edmbolo Operaci\u00f3n Descripci\u00f3n == Igual a Devuelve verdadero si el valor de la izquierda del s\u00edmbolo es igual al de la derecha. != Distinto a Devuelve verdadero si el valor de la izquierda es distinto al de la derecha. < Menor que Devuelve verdadero si el valor de la izquierda es menor que el de la derecha. <= Menor o igual que Devuelve verdadero si el valor de la izquierda es menor o igual que el de la derecha. > Mayor que Devuelve verdadero si el valor de la izquierda es mayor que el de la derecha. >= Mayor o igual que Devuelve verdadero si el valor de la izquierda es mayor o igual al de la derecha. int a = 20 , b = 10 ; System . out . println ( \"a == b :\" + ( a == b )); //Devuelve falso, porque a no es igual a b Operadores l\u00f3gicos Estos operadores se utilizan para realizar operaciones l\u00f3gicas AND y OR . Se usa ampliamente en sentencias if-then o bucles para verificar condiciones, establecer un punto de salida de un bucle o la toma de decisiones. Los operadores condicionales son: S\u00edmbolo Operaci\u00f3n Descripci\u00f3n && AND l\u00f3gico Devuelve verdadero cuando ambas condiciones son ciertas. || OR l\u00f3gico Devuelve verdadero si al menos una condici\u00f3n es cierta. int a = 20 , b = 10 , c = 10 ; System . out . println (( b == c && a == c )); //False System . out . println (( a == c && b == c )); //False System . out . println (( a == b || b == c )); //True Operadores de bits S\u00edmbolo Operaci\u00f3n Descripci\u00f3n & AND Si ambos bits de entrada son 1, establece como resultado 1. De lo contrario 0. | OR Si por lo menos uno de los bits de entrada es 1, establece como resultado 1. De lo contrario 0. ^ XOR Si uno de los bits de entrada es 1 y el otro 0, establece como resultado 1. Si los bits son iguales establece 0. ~ NOT Invierte todos los bits y devuelve el resultado en complemento a 2. Operador ternario (?:) Ternario es una versi\u00f3n abreviada de la sentencia if-else. Tiene tres operandos y de ah\u00ed el nombre ternario. El formato general es: La declaraci\u00f3n anterior significa que si la condici\u00f3n se eval\u00faa como verdadera, entonces ejecuta las instrucciones despu\u00e9s del \u2018?\u2018 de lo contrario, ejecuta las instrucciones despu\u00e9s de \u2018:\u2018. int nota = 7 ; String notaFinal = ( nota >= 5 ) ? \"Aprobado\" : \"Suspendido\" ; System . out . println ( notaFinal ); //muestra Aprobado Abreviaciones En muchos casos, el operador de asignaci\u00f3n se puede combinar con otros operadores para construir una versi\u00f3n m\u00e1s corta de la declaraci\u00f3n llamada Declaraci\u00f3n Compuesta (Compound Statement). += , para sumar el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda. int a = 5 ; a += 5 ; // a = a + 5; \u2013 = , para restar el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda. int a = 5 ; a -= 5 ; // a = a - 5; *= , para multiplicar el operando izquierdo con el operando derecho y luego asign\u00e1ndolo a la variable de la izquierda. int a = 5 ; a *= 5 ; // a = a * 5; / = , para dividir el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda. int a = 5 ; a /= 5 ; // a = a / 5; % = , para asignar el m\u00f3dulo del operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda. int a = 5 ; a %= 5 ; // a = a % 5; Precedencia de operadores El orden de precedencia, es decir, como Java decide la prioridad al evaluar los operadores en una expresi\u00f3n, se puede ver en Java Operator Precedence Table Conversiones de tipo Conversiones por defecto Las reglas de Java para saber el tipo de datos resultante de una expresi\u00f3n se siguen las siguientes reglas: Si alg\u00fan operando es El otro operando se transforma a double double float float long long byte or short int Si se aplican dos regla, se elige la que aparece primero en la tabla. Conversiones forzosas (casting entre tipos nativos) Es una forma de convertir un n\u00famero de un tipo a otro tipo de dato. Para hacerlo ponemos en par\u00e9ntesis el tipo de dato al que queremos convertirlo. byte miByte = ( byte ) ( 14 / 2 ); //conviero la operaci\u00f3n divisi\u00f3n que devuelve un int a byte //Otra forma float a = 8.0f ; int b = 10 ; b = ( int ) a ; //convierto el tipo float a int Otros operadores Existen m\u00e1s operadores que no se han mencionado en el curso. Si se desea consultar todos los operadores de Java se pueden ver en su documentaci\u00f3n oficial. More information","title":"1.5.- Operadores y expresiones"},{"location":"ud1/15operators/#operadores","text":"Los operadores son s\u00edmbolos especiales en Java que realizan operaciones entre uno o varios operandos y devuelve un resultado. Uno de los m\u00e1s usados es el operador suma (+) como hemos visto en clases anteriores.","title":"Operadores"},{"location":"ud1/15operators/#operando","text":"Es cualquier t\u00e9rmino, que puede ser una variable o valor y que es manipulado por un operador. int valor = 8 ; int numero = valor + 12 ; En el ejemplo anterior, + es el operador y valor y 12 son los operandos. valor + 12 es una expresi\u00f3n que devuelve el resultado de 20.","title":"Operando"},{"location":"ud1/15operators/#expresiones","text":"Una expresi\u00f3n es una combinaci\u00f3n de literales, operadores, nombres de variables y par\u00e9ntesis que se utilizan para calcular un valor. int miPrimerEntero = 7 + 5 ; int resultado = 0 ; resultado = ( miPrimerEntero * 10 ) / ( 32 + 12 ); Java examina la expresi\u00f3n de la derecha del signo igual y realiza el c\u00e1lculo de una expresi\u00f3n matem\u00e1tica. Despu\u00e9s asigna ese valor a la variable resultado. Podr\u00edamos complicar m\u00e1s la expresi\u00f3n utilizando operadores como par\u00e9ntesis, multiplicaciones, divisiones, etc. Las partes de una expresi\u00f3n deben estar ordenadas correctamente. Las reglas para las expresiones Java correctas son casi las mismas que las del \u00e1lgebra: Cada operador debe tener el n\u00famero correcto de operandos. Multiplicaci\u00f3n *, Divisi\u00f3n /, Suma +, Resta: debe tener dos operandos, uno en cada lado. La negaci\u00f3n - y unario m\u00e1s + deben ir seguidos de un operando. Los par\u00e9ntesis () pueden rodear una expresi\u00f3n legal para convertirla en operando.","title":"Expresiones"},{"location":"ud1/15operators/#expresiones-mixtas-con-int-y-double","text":"Si ambos operandos de un operador aritm\u00e9tico son de tipo int, entonces la operaci\u00f3n es una operaci\u00f3n entera. Si alg\u00fan operando es de punto flotante, entonces la operaci\u00f3n es de punto flotante.","title":"Expresiones mixtas con int y double"},{"location":"ud1/15operators/#tipos-de-operadores-en-java","text":"Java proporciona muchos tipos de operadores que se pueden usar seg\u00fan la necesidad. Se clasifican seg\u00fan la funcionalidad que brindan. Algunos de los tipos son los siguientes: Operadores aritm\u00e9ticos, unarios, de asignaci\u00f3n, relacionales, l\u00f3gicos, etc.","title":"Tipos de operadores en Java"},{"location":"ud1/15operators/#operador-de-asignacion","text":"Es uno de los operadores m\u00e1s usados. Se usa para asignar un valor a cualquier variable. Tiene una asociaci\u00f3n de derecha a izquierda, es decir, el valor dado en el lado derecho del operador se asigna a la variable de la izquierda y, por lo tanto, el valor del lado derecho debe declararse antes de usarlo o debe ser una constante.","title":"Operador de asignaci\u00f3n (=)"},{"location":"ud1/15operators/#operadores-aritmeticos","text":"Se utilizan para realizar operaciones aritm\u00e9ticas simples. S\u00edmbolo Operaci\u00f3n Descripci\u00f3n + Suma Realiza la suma de los operandos. - Resta Realiza la resta de los operandos. * Producto Multiplica los operandos. / Divisi\u00f3n Realiza la divisi\u00f3n. % M\u00f3dulo Calcula el resto.","title":"Operadores aritm\u00e9ticos"},{"location":"ud1/15operators/#operadores-unarios","text":"Los operadores unarios solo necesitan un operando. Se usan para incrementar, disminuir o negar un valor. S\u00edmbolo Operaci\u00f3n Descripci\u00f3n ++ Incremento Incrementa el valor en 1 unidad. -- Decremento El valor disminuye en 1 unidad. ! NOT l\u00f3gico Invierte un valor booleano. Existen dos versiones de estos operadores: Pre-incremento y pre-decremento. El valor se aumenta/disminuye primero y luego se calcula el resultado. int a = 8 , b = 1 ; b = ++ a ; //b=9, a=9 Post-Incremento y post-decremento: el valor se usa por primera vez para calcular el resultado y luego se incrementa/decrementa. int a = 8 , b = 1 ; b = a ++ ; //b = 8, a = 9","title":"Operadores unarios"},{"location":"ud1/15operators/#operadores-relacionales","text":"Estos operadores se utilizan para verificar relaciones como igualdad, mayor que, menor que. Devuelven el resultado booleano despu\u00e9s de la comparaci\u00f3n. S\u00edmbolo Operaci\u00f3n Descripci\u00f3n == Igual a Devuelve verdadero si el valor de la izquierda del s\u00edmbolo es igual al de la derecha. != Distinto a Devuelve verdadero si el valor de la izquierda es distinto al de la derecha. < Menor que Devuelve verdadero si el valor de la izquierda es menor que el de la derecha. <= Menor o igual que Devuelve verdadero si el valor de la izquierda es menor o igual que el de la derecha. > Mayor que Devuelve verdadero si el valor de la izquierda es mayor que el de la derecha. >= Mayor o igual que Devuelve verdadero si el valor de la izquierda es mayor o igual al de la derecha. int a = 20 , b = 10 ; System . out . println ( \"a == b :\" + ( a == b )); //Devuelve falso, porque a no es igual a b","title":"Operadores relacionales"},{"location":"ud1/15operators/#operadores-logicos","text":"Estos operadores se utilizan para realizar operaciones l\u00f3gicas AND y OR . Se usa ampliamente en sentencias if-then o bucles para verificar condiciones, establecer un punto de salida de un bucle o la toma de decisiones. Los operadores condicionales son: S\u00edmbolo Operaci\u00f3n Descripci\u00f3n && AND l\u00f3gico Devuelve verdadero cuando ambas condiciones son ciertas. || OR l\u00f3gico Devuelve verdadero si al menos una condici\u00f3n es cierta. int a = 20 , b = 10 , c = 10 ; System . out . println (( b == c && a == c )); //False System . out . println (( a == c && b == c )); //False System . out . println (( a == b || b == c )); //True","title":"Operadores l\u00f3gicos"},{"location":"ud1/15operators/#operadores-de-bits","text":"S\u00edmbolo Operaci\u00f3n Descripci\u00f3n & AND Si ambos bits de entrada son 1, establece como resultado 1. De lo contrario 0. | OR Si por lo menos uno de los bits de entrada es 1, establece como resultado 1. De lo contrario 0. ^ XOR Si uno de los bits de entrada es 1 y el otro 0, establece como resultado 1. Si los bits son iguales establece 0. ~ NOT Invierte todos los bits y devuelve el resultado en complemento a 2.","title":"Operadores de bits"},{"location":"ud1/15operators/#operador-ternario","text":"Ternario es una versi\u00f3n abreviada de la sentencia if-else. Tiene tres operandos y de ah\u00ed el nombre ternario. El formato general es: La declaraci\u00f3n anterior significa que si la condici\u00f3n se eval\u00faa como verdadera, entonces ejecuta las instrucciones despu\u00e9s del \u2018?\u2018 de lo contrario, ejecuta las instrucciones despu\u00e9s de \u2018:\u2018. int nota = 7 ; String notaFinal = ( nota >= 5 ) ? \"Aprobado\" : \"Suspendido\" ; System . out . println ( notaFinal ); //muestra Aprobado","title":"Operador ternario (?:)"},{"location":"ud1/15operators/#abreviaciones","text":"En muchos casos, el operador de asignaci\u00f3n se puede combinar con otros operadores para construir una versi\u00f3n m\u00e1s corta de la declaraci\u00f3n llamada Declaraci\u00f3n Compuesta (Compound Statement). += , para sumar el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda. int a = 5 ; a += 5 ; // a = a + 5; \u2013 = , para restar el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda. int a = 5 ; a -= 5 ; // a = a - 5; *= , para multiplicar el operando izquierdo con el operando derecho y luego asign\u00e1ndolo a la variable de la izquierda. int a = 5 ; a *= 5 ; // a = a * 5; / = , para dividir el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda. int a = 5 ; a /= 5 ; // a = a / 5; % = , para asignar el m\u00f3dulo del operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda. int a = 5 ; a %= 5 ; // a = a % 5;","title":"Abreviaciones"},{"location":"ud1/15operators/#precedencia-de-operadores","text":"El orden de precedencia, es decir, como Java decide la prioridad al evaluar los operadores en una expresi\u00f3n, se puede ver en Java Operator Precedence Table","title":"Precedencia de operadores"},{"location":"ud1/15operators/#conversiones-de-tipo","text":"","title":"Conversiones de tipo"},{"location":"ud1/15operators/#conversiones-por-defecto","text":"Las reglas de Java para saber el tipo de datos resultante de una expresi\u00f3n se siguen las siguientes reglas: Si alg\u00fan operando es El otro operando se transforma a double double float float long long byte or short int Si se aplican dos regla, se elige la que aparece primero en la tabla.","title":"Conversiones por defecto"},{"location":"ud1/15operators/#conversiones-forzosas-casting-entre-tipos-nativos","text":"Es una forma de convertir un n\u00famero de un tipo a otro tipo de dato. Para hacerlo ponemos en par\u00e9ntesis el tipo de dato al que queremos convertirlo. byte miByte = ( byte ) ( 14 / 2 ); //conviero la operaci\u00f3n divisi\u00f3n que devuelve un int a byte //Otra forma float a = 8.0f ; int b = 10 ; b = ( int ) a ; //convierto el tipo float a int Otros operadores Existen m\u00e1s operadores que no se han mencionado en el curso. Si se desea consultar todos los operadores de Java se pueden ver en su documentaci\u00f3n oficial. More information","title":"Conversiones forzosas (casting entre tipos nativos)"},{"location":"ud1/16comments/","text":"Comentarios en Java Los comentarios son ignorados por el ordenador y se usan en el programa para ayudar a describir alguna funcionalidad o explicaci\u00f3n del c\u00f3digo fuente. Existen dos tipos de comentarios. Comentarios de una l\u00ednea Usamos la doble barra // para realizar un comentario de una sola l\u00ednea. Lo podemos usar en una l\u00ednea en blanco o detr\u00e1s del c\u00f3digo. int gravity ; //variable para calcular la gravedad Comentarios multil\u00ednea Usamos la barra con asterisco doble para realizar comentarios que afecten a m\u00e1s de una l\u00ednea. De forma que cuando abramos un comentario usaremos /* , para cerrarlo */ . /* Clase que almacena en la base de datos los datos de una persona. */ public class Persona { ... }","title":"1.6.- Comentarios en Java"},{"location":"ud1/16comments/#comentarios-en-java","text":"Los comentarios son ignorados por el ordenador y se usan en el programa para ayudar a describir alguna funcionalidad o explicaci\u00f3n del c\u00f3digo fuente. Existen dos tipos de comentarios.","title":"Comentarios en Java"},{"location":"ud1/16comments/#comentarios-de-una-linea","text":"Usamos la doble barra // para realizar un comentario de una sola l\u00ednea. Lo podemos usar en una l\u00ednea en blanco o detr\u00e1s del c\u00f3digo. int gravity ; //variable para calcular la gravedad","title":"Comentarios de una l\u00ednea"},{"location":"ud1/16comments/#comentarios-multilinea","text":"Usamos la barra con asterisco doble para realizar comentarios que afecten a m\u00e1s de una l\u00ednea. De forma que cuando abramos un comentario usaremos /* , para cerrarlo */ . /* Clase que almacena en la base de datos los datos de una persona. */ public class Persona { ... }","title":"Comentarios multil\u00ednea"},{"location":"ud1/17constantesliterales/","text":"Constantes y literales Las constantes Un programa puede contener ciertos valores que no deben cambiar durante su ejecuci\u00f3n. Estos valores se llaman constantes. Definici\u00f3n: Una constante es una zona de memoria que se referencia con un identificador, conocido como nombre de la constante, donde se almacena un valor que no puede cambiar durante la ejecuci\u00f3n del programa. La nomenclatura para definiar las constantes es la siguiente: Todas las letras de cada palabra deben estar en may\u00fasculas Se separa cada palabra con un _ Se declaran similar a las variables, con la diferencia de que el tipo de dato va despu\u00e9s de la palabra reservada final final double PI = 3.141591 ; final int MIN_WIDTH = 4 ; final double TASAS = 0.045 ; Las constantes hacen que el programa sea m\u00e1s f\u00e1cil de leer y verificar que sea correcto. Si es necesario cambiar una constante (por ejemplo, si cambian las tasas), todo lo que tendremos que hacer es cambiar la declaraci\u00f3n de la constante. No ser\u00e1 necesario buscar en todo el programa cada aparici\u00f3n de ese n\u00famero espec\u00edfico. Los literales Un literal Java es un valor de tipo entero, real, l\u00f3gico, car\u00e1cter, cadena de caracteres o un valor nulo (null) que puede aparecer dentro de un programa. Por ejemplo: 150, 12.4, \u201cANA\u201d, null, \u2018t\u2019. Los literales suelen aparecer en la asignaci\u00f3n de valores a las variables o formando parte de expresiones aritm\u00e9ticas o l\u00f3gicas.","title":"1.7.- Constantes y literales"},{"location":"ud1/17constantesliterales/#constantes-y-literales","text":"","title":"Constantes y literales"},{"location":"ud1/17constantesliterales/#las-constantes","text":"Un programa puede contener ciertos valores que no deben cambiar durante su ejecuci\u00f3n. Estos valores se llaman constantes. Definici\u00f3n: Una constante es una zona de memoria que se referencia con un identificador, conocido como nombre de la constante, donde se almacena un valor que no puede cambiar durante la ejecuci\u00f3n del programa. La nomenclatura para definiar las constantes es la siguiente: Todas las letras de cada palabra deben estar en may\u00fasculas Se separa cada palabra con un _ Se declaran similar a las variables, con la diferencia de que el tipo de dato va despu\u00e9s de la palabra reservada final final double PI = 3.141591 ; final int MIN_WIDTH = 4 ; final double TASAS = 0.045 ; Las constantes hacen que el programa sea m\u00e1s f\u00e1cil de leer y verificar que sea correcto. Si es necesario cambiar una constante (por ejemplo, si cambian las tasas), todo lo que tendremos que hacer es cambiar la declaraci\u00f3n de la constante. No ser\u00e1 necesario buscar en todo el programa cada aparici\u00f3n de ese n\u00famero espec\u00edfico.","title":"Las constantes"},{"location":"ud1/17constantesliterales/#los-literales","text":"Un literal Java es un valor de tipo entero, real, l\u00f3gico, car\u00e1cter, cadena de caracteres o un valor nulo (null) que puede aparecer dentro de un programa. Por ejemplo: 150, 12.4, \u201cANA\u201d, null, \u2018t\u2019. Los literales suelen aparecer en la asignaci\u00f3n de valores a las variables o formando parte de expresiones aritm\u00e9ticas o l\u00f3gicas.","title":"Los literales"},{"location":"ud1/18inputoutputconsole/","text":"Programaci\u00f3n de la consola: entrada y salida de informaci\u00f3n (I/O input/output) Java viene con una biblioteca de clases que se puede usar para realizar tareas comunes. La biblioteca de clases de Java est\u00e1 organizada en un conjunto de paquetes, donde cada paquete contiene una colecci\u00f3n de clases relacionadas. En esta secci\u00f3n presentamos las clases System y Scanner que se utilizan para imprimir la salida y leer la entrada de un programa. El tipo m\u00e1s simple de interfaz de usuario es la interfaz de l\u00ednea de comandos, en la que la entrada se toma de la l\u00ednea de comandos a trav\u00e9s del teclado y la salida se muestra en la consola. Algunas aplicaciones Java utilizan este tipo de interfaz otros usan interfaz gr\u00e1fica como veremos m\u00e1s adelante. Salida de la informaci\u00f3n En Java, cualquier origen o destino de I/O se considera un flujo de bytes o caracteres. Para realizar la salida, insertamos bytes o caracteres en la secuencia. Para realizar la entrada, extraemos bytes o caracteres del flujo (stream). Incluso los caracteres introducidos en un teclado, si se consideran como una secuencia de pulsaciones de teclas, se pueden representar como un stream. En Java, la I/O se maneja a trav\u00e9s de m\u00e9todos que pertenecen a clases contenidas en el paquete java.io. Ya hemos visto c\u00f3mo se usa el m\u00e9todo de salida println() para enviar una cadena a la consola. Por ejemplo: System . out . println ( \"Hola mundo\" ); imprime el texto Hola mundo por la consola. Los objetos System.out y System.err se pueden usar para escribir la salida en la consola. Como sugiere su nombre, el flujo de errores se usa principalmente para mensajes de error, mientras que el flujo de salida se usa para otras salidas impresas. System . err . println ( \"Fallo al abrir el fichero\" ); De manera similar, como sugiere su nombre, el objeto System.in se puede usar para manejar la entrada, que se trata en el siguiente punto. La \u00fanica diferencia entre los m\u00e9todos print() y println() es que println() tambi\u00e9n imprimir\u00e1 un retorno de carro y un avance de l\u00ednea despu\u00e9s de imprimir sus datos, lo que permitir\u00e1 que la salida posterior se imprima en una nueva l\u00ednea. Por ejemplo: System . out . print ( \"Hola\" ); System . out . print ( \"mundo\" ): System . out . println ( \"Texto con salto de l\u00ednea\" ); System . out . println ( \"adi\u00f3s\" ); HolamundoTexto con salto de l\u00ednea adi\u00f3s Entrada de la informaci\u00f3n java.util.Scanner Se ha agregado la clase Scanner al paquete java.util que permite la entrada de teclado sin forzar el programador para manejar las excepciones. La clase Scanner est\u00e1 dise\u00f1ada para ser una forma muy flexible de reconocer fragmentos de datos que se ajustan a patrones espec\u00edficos de cualquier flujo de entrada. Para usar la clase Scanner para la entrada de teclado, debemos crear una instancia de Scanner y asociarla con System.in. La clase tiene un constructor para este prop\u00f3sito, por lo que la declaraci\u00f3n Scanner sc = new Scanner ( System . in ); declara y crea una instancia de un objeto que se puede utilizar para la entrada del teclado. Despu\u00e9s de crear un objeto Scanner, podemos hacer una llamada a nextInt(), nextDouble(), o next() para leer, respectivamente, un entero, un n\u00famero real, o String del teclado. public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); System . out . print ( \"Introduce un n\u00famero: \" ); int num = sc . nextInt (); //Read the integer System . out . println ( \"El n\u00famero introducido es: \" + num ); } Cuando se ejecuta el m\u00e9todo nextInt() , no se ejecutan m\u00e1s declaraciones hasta que el m\u00e9todo devuelve un valor int. Normalmente, esto no sucede hasta que el usuario ha escrito los d\u00edgitos de un n\u00famero entero y presiona la tecla Intro o Intro. Para leer un String utilizamos el m\u00e9todo next() . public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); System . out . print ( \"Introduce una palabra: \" ); String str = sc . next (); System . out . println ( str ); } Un objeto Scanner tiene un conjunto de cadenas de caracteres que separan o delimitan los fragmentos de datos que est\u00e1 buscando. De forma predeterminada, este conjunto de delimitadores consta de cualquier secuencia no vac\u00eda de caracteres en blanco, es decir, los caracteres de espacio, tabulaci\u00f3n, retorno y nueva l\u00ednea. Esto permitir\u00e1 al usuario ingresar varios n\u00fameros enteros separados por espacios antes de presionar la tecla Enter. En c\u00f3digo ser\u00eda: System . out . print ( \"Introduce dos n\u00fameros: \" ); int num = sc . nextInt (); int num2 = sc . nextInt (); Los espacios en blanco como delimitadores tambi\u00e9n significan que el m\u00e9todo next() no puede devolver una cadena vac\u00eda ni puede devolver una cadena que contenga espacios. Por ejemplo, considere el c\u00f3digo: System . out . print ( \"Introduce un texto separado por espacio en blanco: \" ); String str = sc . next (); Si se escribe \"Hola mundo\" y se presiona la tecla enter, la cadena str almacenar\u00e1 s\u00f3lo \"Hola\". Para que un objeto Scanner lea cadenas que contienen espacios, debemos usar el m\u00e9todo nextLine() : String str = sc . nextLine ();","title":"1.8.- Entrada y salida de informaci\u00f3n por consola"},{"location":"ud1/18inputoutputconsole/#programacion-de-la-consola-entrada-y-salida-de-informacion-io-inputoutput","text":"Java viene con una biblioteca de clases que se puede usar para realizar tareas comunes. La biblioteca de clases de Java est\u00e1 organizada en un conjunto de paquetes, donde cada paquete contiene una colecci\u00f3n de clases relacionadas. En esta secci\u00f3n presentamos las clases System y Scanner que se utilizan para imprimir la salida y leer la entrada de un programa. El tipo m\u00e1s simple de interfaz de usuario es la interfaz de l\u00ednea de comandos, en la que la entrada se toma de la l\u00ednea de comandos a trav\u00e9s del teclado y la salida se muestra en la consola. Algunas aplicaciones Java utilizan este tipo de interfaz otros usan interfaz gr\u00e1fica como veremos m\u00e1s adelante.","title":"Programaci\u00f3n de la consola: entrada y salida de informaci\u00f3n (I/O input/output)"},{"location":"ud1/18inputoutputconsole/#salida-de-la-informacion","text":"En Java, cualquier origen o destino de I/O se considera un flujo de bytes o caracteres. Para realizar la salida, insertamos bytes o caracteres en la secuencia. Para realizar la entrada, extraemos bytes o caracteres del flujo (stream). Incluso los caracteres introducidos en un teclado, si se consideran como una secuencia de pulsaciones de teclas, se pueden representar como un stream. En Java, la I/O se maneja a trav\u00e9s de m\u00e9todos que pertenecen a clases contenidas en el paquete java.io. Ya hemos visto c\u00f3mo se usa el m\u00e9todo de salida println() para enviar una cadena a la consola. Por ejemplo: System . out . println ( \"Hola mundo\" ); imprime el texto Hola mundo por la consola. Los objetos System.out y System.err se pueden usar para escribir la salida en la consola. Como sugiere su nombre, el flujo de errores se usa principalmente para mensajes de error, mientras que el flujo de salida se usa para otras salidas impresas. System . err . println ( \"Fallo al abrir el fichero\" ); De manera similar, como sugiere su nombre, el objeto System.in se puede usar para manejar la entrada, que se trata en el siguiente punto. La \u00fanica diferencia entre los m\u00e9todos print() y println() es que println() tambi\u00e9n imprimir\u00e1 un retorno de carro y un avance de l\u00ednea despu\u00e9s de imprimir sus datos, lo que permitir\u00e1 que la salida posterior se imprima en una nueva l\u00ednea. Por ejemplo: System . out . print ( \"Hola\" ); System . out . print ( \"mundo\" ): System . out . println ( \"Texto con salto de l\u00ednea\" ); System . out . println ( \"adi\u00f3s\" ); HolamundoTexto con salto de l\u00ednea adi\u00f3s","title":"Salida de la informaci\u00f3n"},{"location":"ud1/18inputoutputconsole/#entrada-de-la-informacion-javautilscanner","text":"Se ha agregado la clase Scanner al paquete java.util que permite la entrada de teclado sin forzar el programador para manejar las excepciones. La clase Scanner est\u00e1 dise\u00f1ada para ser una forma muy flexible de reconocer fragmentos de datos que se ajustan a patrones espec\u00edficos de cualquier flujo de entrada. Para usar la clase Scanner para la entrada de teclado, debemos crear una instancia de Scanner y asociarla con System.in. La clase tiene un constructor para este prop\u00f3sito, por lo que la declaraci\u00f3n Scanner sc = new Scanner ( System . in ); declara y crea una instancia de un objeto que se puede utilizar para la entrada del teclado. Despu\u00e9s de crear un objeto Scanner, podemos hacer una llamada a nextInt(), nextDouble(), o next() para leer, respectivamente, un entero, un n\u00famero real, o String del teclado. public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); System . out . print ( \"Introduce un n\u00famero: \" ); int num = sc . nextInt (); //Read the integer System . out . println ( \"El n\u00famero introducido es: \" + num ); } Cuando se ejecuta el m\u00e9todo nextInt() , no se ejecutan m\u00e1s declaraciones hasta que el m\u00e9todo devuelve un valor int. Normalmente, esto no sucede hasta que el usuario ha escrito los d\u00edgitos de un n\u00famero entero y presiona la tecla Intro o Intro. Para leer un String utilizamos el m\u00e9todo next() . public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); System . out . print ( \"Introduce una palabra: \" ); String str = sc . next (); System . out . println ( str ); } Un objeto Scanner tiene un conjunto de cadenas de caracteres que separan o delimitan los fragmentos de datos que est\u00e1 buscando. De forma predeterminada, este conjunto de delimitadores consta de cualquier secuencia no vac\u00eda de caracteres en blanco, es decir, los caracteres de espacio, tabulaci\u00f3n, retorno y nueva l\u00ednea. Esto permitir\u00e1 al usuario ingresar varios n\u00fameros enteros separados por espacios antes de presionar la tecla Enter. En c\u00f3digo ser\u00eda: System . out . print ( \"Introduce dos n\u00fameros: \" ); int num = sc . nextInt (); int num2 = sc . nextInt (); Los espacios en blanco como delimitadores tambi\u00e9n significan que el m\u00e9todo next() no puede devolver una cadena vac\u00eda ni puede devolver una cadena que contenga espacios. Por ejemplo, considere el c\u00f3digo: System . out . print ( \"Introduce un texto separado por espacio en blanco: \" ); String str = sc . next (); Si se escribe \"Hola mundo\" y se presiona la tecla enter, la cadena str almacenar\u00e1 s\u00f3lo \"Hola\". Para que un objeto Scanner lea cadenas que contienen espacios, debemos usar el m\u00e9todo nextLine() : String str = sc . nextLine ();","title":"Entrada de la informaci\u00f3n java.util.Scanner"},{"location":"ud1/19poo/","text":"Introducci\u00f3n a la programaci\u00f3n orientada a objetos La programaci\u00f3n modular es un paradigma que consiste en dividir un programa en m\u00f3dulos con el fin de hacerlo m\u00e1s legible y manejable. Enfatiza este concepto mediante la construcci\u00f3n de aplicaciones a partir de su divisi\u00f3n en componentes independientes que llevan a cabo tareas concretas. Al aplicar programaci\u00f3n modular, un problema complejo debe ser dividido en otros subproblemas m\u00e1s simples a\u00fan. Un m\u00f3dulo es cada una de las partes de un programa que resuelve uno de los subproblemas. La programaci\u00f3n orientada a objetos (POO) se basa en la programaci\u00f3n modular, aunque supone una ruptura respecto a \u00e9sta al introducir el concepto de objeto, lo que supone un gran avance en t\u00e9rminos de modularizaci\u00f3n y reutilizaci\u00f3n de c\u00f3digo. Fundamentos de la POO Abstracci\u00f3n : es el pilar de la POO, un principio por el cual se a\u00edsla toda aquella informaci\u00f3n que no resulta relevante a un determinado nivel de conocimiento. Consiste en captar las caracter\u00edsticas esenciales de un objeto, asi como su comportamiento. Encapsulaci\u00f3n : se centra en ocultad la complejidad de la clase. Significa proteger a los miembros de una clase de un acceso ilegal o no autorizado. Herencia : es el pilar m\u00e1s fuerte que asegura la reutilizaci\u00f3n de c\u00f3digo. Permite la definici\u00f3n de nuevas clases a partir de otras ya existentes. Polimorfismo : posibilita que una misma operaci\u00f3n pueda realizar tareas diferentes, dependiendo del tipo de objeto sobre el cual se ha invocado. Concepto de objeto Entonces, \u00bfqu\u00e9 es un objeto? Al igual que en el mundo real, un objeto es cualquier cosa. Un objeto puede ser una cosa f\u00edsica, como un coche, o una cosa mental, como una idea. Puede ser algo natural, como un animal, o algo artificial hecho por el hombre, como un cajero autom\u00e1tico. Un programa que administra un cajero autom\u00e1tico involucrar\u00eda cuentas bancarias y objetos de cliente. Un programa de ajedrez involucrar\u00eda un objeto tablero y objetos piezas de ajedrez. Atributos y acciones Atributos Al igual que con los objetos reales, los objetos de nuestros programas tienen ciertos atributos o propiedades caracter\u00edsticos. Por ejemplo, un objeto de cajero autom\u00e1tico tendr\u00eda una cantidad actual de efectivo que podr\u00eda dispensar. Un objeto pieza ajedrez puede tener un par de atributos de fila y columna que especifiquen su posici\u00f3n en el tablero de ajedrez. Observe que los atributos de un objeto son en s\u00ed mismos objetos. El atributo de efectivo del cajero autom\u00e1tico y los atributos de fila y columna de la pieza de ajedrez son n\u00fameros. A veces nos referimos a la colecci\u00f3n de atributos y valores de un objeto como su estado . Acciones o M\u00e9todos Adem\u00e1s de sus atributos o propiedades, los objetos tambi\u00e9n tienen acciones o comportamientos caracter\u00edsticos. Como ya dijimos, los objetos en los programas son din\u00e1micos. Hacen cosas o les hacen cosas. Por ejemplo, en un programa de ajedrez, ChessPieces tiene la capacidad de moveTo () a una nueva posici\u00f3n en el tablero de ajedrez. De manera similar, cuando un cliente presiona el bot\u00f3n \"Saldo actual\" en un cajero autom\u00e1tico, esto le est\u00e1 diciendo al cajero autom\u00e1tico que informe () el saldo bancario actual del cliente. (Observe c\u00f3mo usamos par\u00e9ntesis para distinguir acciones de objetos y atributos). Las acciones asociadas con un objeto se pueden utilizar para enviar mensajes a los objetos y recuperar informaci\u00f3n de los objetos. Un mensaje es el paso de informaci\u00f3n o datos de un objeto a otro. En este ejemplo, le decimos a pe\u00f3n1: Pieza de ajedrez que se mueva a (3,4). chessPiece . move ( 3 , 4 ); Los n\u00fameros 3 y 4 en este caso son argumentos que le dicen al pe\u00f3n a qu\u00e9 casilla moverse. (Un tablero de ajedrez tiene 8 filas y 8 columnas y cada cuadrado se identifica por sus coordenadas de fila y columna). En general, un argumento es un valor de datos que especializa el contenido de un mensaje de alguna manera. Responder a un mensaje o realizar una acci\u00f3n a veces provoca un cambio en el estado de un objeto. Por ejemplo, despu\u00e9s de realizar moveTo (3,4), el pe\u00f3n estar\u00e1 en una casilla diferente. Su posici\u00f3n habr\u00e1 cambiado. Por otro lado, algunos mensajes (o acciones) no modifican el estado del objeto. Informar el saldo de la cuenta bancaria del cliente no cambia el saldo. Caracter\u00edsticas b\u00e1sicas Estado : est\u00e1 representado por atributos de un objeto. Comportamiento : se representa mediante m\u00e9todos de un objeto. Tambi\u00e9n refleja la respuesta de un objeto con otros objetos. Identidad : le da un nombre \u00fanico a un objeto y permite que un objeto interact\u00fae con otros objetos. Creaci\u00f3n y destrucci\u00f3n de objetos Creaci\u00f3n Para crear un objeto utilizamos la palabra reservada new , que asigna memoria del Heap. Se usa el nombre de la clase (constructor) seguido por par\u00e9ntesis. Se le llama instanciar un objeto. ATM atm = new ATM (); Destrucci\u00f3n En Java no es posible destruir objetos de forma expl\u00edcita, los objetos se destruyen de forma autom\u00e1tica por el recolector de basura. Java busca objetos inalcanzables y los destruye, normalmente cuando falta memoria. Los convierte de nuevo en memoria binaria no utilizada. Uso de objetos: acceso a atributos y m\u00e9todos Para acceder a los atributos y m\u00e9todos de un objeto utilizamos la notaci\u00f3n \".\" detr\u00e1s del nombre del objeto. El objeto debe ser creado previamente sino dar\u00e1 error de compilaci\u00f3n. double cantidad = atm . efectivo ; atm . mostrarEfectivo (); M\u00e1s adelante veremos la visibilidad de los m\u00e9todos y atributos de los objetos.","title":"1.9.- Introducci\u00f3n a la programaci\u00f3n orientada a objetos"},{"location":"ud1/19poo/#introduccion-a-la-programacion-orientada-a-objetos","text":"La programaci\u00f3n modular es un paradigma que consiste en dividir un programa en m\u00f3dulos con el fin de hacerlo m\u00e1s legible y manejable. Enfatiza este concepto mediante la construcci\u00f3n de aplicaciones a partir de su divisi\u00f3n en componentes independientes que llevan a cabo tareas concretas. Al aplicar programaci\u00f3n modular, un problema complejo debe ser dividido en otros subproblemas m\u00e1s simples a\u00fan. Un m\u00f3dulo es cada una de las partes de un programa que resuelve uno de los subproblemas. La programaci\u00f3n orientada a objetos (POO) se basa en la programaci\u00f3n modular, aunque supone una ruptura respecto a \u00e9sta al introducir el concepto de objeto, lo que supone un gran avance en t\u00e9rminos de modularizaci\u00f3n y reutilizaci\u00f3n de c\u00f3digo.","title":"Introducci\u00f3n a la programaci\u00f3n orientada a objetos"},{"location":"ud1/19poo/#fundamentos-de-la-poo","text":"Abstracci\u00f3n : es el pilar de la POO, un principio por el cual se a\u00edsla toda aquella informaci\u00f3n que no resulta relevante a un determinado nivel de conocimiento. Consiste en captar las caracter\u00edsticas esenciales de un objeto, asi como su comportamiento. Encapsulaci\u00f3n : se centra en ocultad la complejidad de la clase. Significa proteger a los miembros de una clase de un acceso ilegal o no autorizado. Herencia : es el pilar m\u00e1s fuerte que asegura la reutilizaci\u00f3n de c\u00f3digo. Permite la definici\u00f3n de nuevas clases a partir de otras ya existentes. Polimorfismo : posibilita que una misma operaci\u00f3n pueda realizar tareas diferentes, dependiendo del tipo de objeto sobre el cual se ha invocado.","title":"Fundamentos de la POO"},{"location":"ud1/19poo/#concepto-de-objeto","text":"Entonces, \u00bfqu\u00e9 es un objeto? Al igual que en el mundo real, un objeto es cualquier cosa. Un objeto puede ser una cosa f\u00edsica, como un coche, o una cosa mental, como una idea. Puede ser algo natural, como un animal, o algo artificial hecho por el hombre, como un cajero autom\u00e1tico. Un programa que administra un cajero autom\u00e1tico involucrar\u00eda cuentas bancarias y objetos de cliente. Un programa de ajedrez involucrar\u00eda un objeto tablero y objetos piezas de ajedrez.","title":"Concepto de objeto"},{"location":"ud1/19poo/#atributos-y-acciones","text":"","title":"Atributos y acciones"},{"location":"ud1/19poo/#atributos","text":"Al igual que con los objetos reales, los objetos de nuestros programas tienen ciertos atributos o propiedades caracter\u00edsticos. Por ejemplo, un objeto de cajero autom\u00e1tico tendr\u00eda una cantidad actual de efectivo que podr\u00eda dispensar. Un objeto pieza ajedrez puede tener un par de atributos de fila y columna que especifiquen su posici\u00f3n en el tablero de ajedrez. Observe que los atributos de un objeto son en s\u00ed mismos objetos. El atributo de efectivo del cajero autom\u00e1tico y los atributos de fila y columna de la pieza de ajedrez son n\u00fameros. A veces nos referimos a la colecci\u00f3n de atributos y valores de un objeto como su estado .","title":"Atributos"},{"location":"ud1/19poo/#acciones-o-metodos","text":"Adem\u00e1s de sus atributos o propiedades, los objetos tambi\u00e9n tienen acciones o comportamientos caracter\u00edsticos. Como ya dijimos, los objetos en los programas son din\u00e1micos. Hacen cosas o les hacen cosas. Por ejemplo, en un programa de ajedrez, ChessPieces tiene la capacidad de moveTo () a una nueva posici\u00f3n en el tablero de ajedrez. De manera similar, cuando un cliente presiona el bot\u00f3n \"Saldo actual\" en un cajero autom\u00e1tico, esto le est\u00e1 diciendo al cajero autom\u00e1tico que informe () el saldo bancario actual del cliente. (Observe c\u00f3mo usamos par\u00e9ntesis para distinguir acciones de objetos y atributos). Las acciones asociadas con un objeto se pueden utilizar para enviar mensajes a los objetos y recuperar informaci\u00f3n de los objetos. Un mensaje es el paso de informaci\u00f3n o datos de un objeto a otro. En este ejemplo, le decimos a pe\u00f3n1: Pieza de ajedrez que se mueva a (3,4). chessPiece . move ( 3 , 4 ); Los n\u00fameros 3 y 4 en este caso son argumentos que le dicen al pe\u00f3n a qu\u00e9 casilla moverse. (Un tablero de ajedrez tiene 8 filas y 8 columnas y cada cuadrado se identifica por sus coordenadas de fila y columna). En general, un argumento es un valor de datos que especializa el contenido de un mensaje de alguna manera. Responder a un mensaje o realizar una acci\u00f3n a veces provoca un cambio en el estado de un objeto. Por ejemplo, despu\u00e9s de realizar moveTo (3,4), el pe\u00f3n estar\u00e1 en una casilla diferente. Su posici\u00f3n habr\u00e1 cambiado. Por otro lado, algunos mensajes (o acciones) no modifican el estado del objeto. Informar el saldo de la cuenta bancaria del cliente no cambia el saldo.","title":"Acciones o M\u00e9todos"},{"location":"ud1/19poo/#caracteristicas-basicas","text":"Estado : est\u00e1 representado por atributos de un objeto. Comportamiento : se representa mediante m\u00e9todos de un objeto. Tambi\u00e9n refleja la respuesta de un objeto con otros objetos. Identidad : le da un nombre \u00fanico a un objeto y permite que un objeto interact\u00fae con otros objetos.","title":"Caracter\u00edsticas b\u00e1sicas"},{"location":"ud1/19poo/#creacion-y-destruccion-de-objetos","text":"","title":"Creaci\u00f3n y destrucci\u00f3n de objetos"},{"location":"ud1/19poo/#creacion","text":"Para crear un objeto utilizamos la palabra reservada new , que asigna memoria del Heap. Se usa el nombre de la clase (constructor) seguido por par\u00e9ntesis. Se le llama instanciar un objeto. ATM atm = new ATM ();","title":"Creaci\u00f3n"},{"location":"ud1/19poo/#destruccion","text":"En Java no es posible destruir objetos de forma expl\u00edcita, los objetos se destruyen de forma autom\u00e1tica por el recolector de basura. Java busca objetos inalcanzables y los destruye, normalmente cuando falta memoria. Los convierte de nuevo en memoria binaria no utilizada.","title":"Destrucci\u00f3n"},{"location":"ud1/19poo/#uso-de-objetos-acceso-a-atributos-y-metodos","text":"Para acceder a los atributos y m\u00e9todos de un objeto utilizamos la notaci\u00f3n \".\" detr\u00e1s del nombre del objeto. El objeto debe ser creado previamente sino dar\u00e1 error de compilaci\u00f3n. double cantidad = atm . efectivo ; atm . mostrarEfectivo (); M\u00e1s adelante veremos la visibilidad de los m\u00e9todos y atributos de los objetos.","title":"Uso de objetos: acceso a atributos y m\u00e9todos"},{"location":"ud1/1elementos/","text":"Elementos de un programa inform\u00e1tico Un programa es una secuencia de instrucciones que un ordenador ejecuta para realizar alguna tarea. Parece una idea bastante simple, pero para que el ordenador pueda hacer uso de las instrucciones, deben estar escritas de forma que las pueda usar. Esto significa que los programas deben estar escritos en lenguajes de programaci\u00f3n. Los lenguajes de programaci\u00f3n se diferencian de los lenguajes humanos ordinarios en que son completamente inequ\u00edvocos y muy estrictos sobre lo que est\u00e1 y no est\u00e1 permitido en un programa. Las reglas que determinan lo que est\u00e1 permitido se denominan sintaxis del lenguaje. Las reglas de sintaxis especifican el vocabulario b\u00e1sico del lenguaje y c\u00f3mo se pueden construir los programas. Lenguajes de programaci\u00f3n Se trata de un conjunto de instrucciones que permite la comunicaci\u00f3n de los humanos con los ordenadores. C --> bases de datos, videojuegos, kernel linux, IOT, dispositivos inteligentes, etc. Python --> inteligencia artificial, big data, etc. Java --> puntos de ventas, aplicaciones de escritorio, cajeros autom\u00e1ticos, dispositivos m\u00f3viles, ... \u00bfCon qu\u00e9 lenguaje de programaci\u00f3n debo empezar? En realidad, no existe el mejor lenguaje de programaci\u00f3n para empezar, y el lenguaje que elijas pr\u00e1cticamente no tendr\u00e1 un efecto duradero en tu carrera. Los lenguajes de programaci\u00f3n pueden verse muy diferentes en la superficie, pero la mayor\u00eda de los conceptos fundamentales se transferir\u00e1n de un lenguaje a otro. Aprender un nuevo idioma tambi\u00e9n ser\u00e1 m\u00e1s f\u00e1cil con el tiempo; un principiante puede tardar meses antes de que se sienta c\u00f3modo con su primer lenguaje; un programador experimentado puede familiarizarse con un nuevo idioma en cuesti\u00f3n de d\u00edas. 7 Tips para aprender a programar con \u00e9xito 1 . Learn by doing. Always play with the code while learning 2 . Grasp the fundamentals for long-term benefits 3 . Code by hand. It sharpens proficiency and you\u2019ll need it to get a job 4 . Ask for help. You\u2019ll need it 5 . Seek out more online resources. There\u2019s a wealth of content 6 . Don\u2019t just read the sample code. Tinker with it! 7 . Take breaks when debugging Fuente: Coding dojo Tip S\u00e9 persistente, no te rindas!","title":"1.1.- Programa y lenguajes de programaci\u00f3n"},{"location":"ud1/1elementos/#elementos-de-un-programa-informatico","text":"Un programa es una secuencia de instrucciones que un ordenador ejecuta para realizar alguna tarea. Parece una idea bastante simple, pero para que el ordenador pueda hacer uso de las instrucciones, deben estar escritas de forma que las pueda usar. Esto significa que los programas deben estar escritos en lenguajes de programaci\u00f3n. Los lenguajes de programaci\u00f3n se diferencian de los lenguajes humanos ordinarios en que son completamente inequ\u00edvocos y muy estrictos sobre lo que est\u00e1 y no est\u00e1 permitido en un programa. Las reglas que determinan lo que est\u00e1 permitido se denominan sintaxis del lenguaje. Las reglas de sintaxis especifican el vocabulario b\u00e1sico del lenguaje y c\u00f3mo se pueden construir los programas.","title":"Elementos de un programa inform\u00e1tico"},{"location":"ud1/1elementos/#lenguajes-de-programacion","text":"Se trata de un conjunto de instrucciones que permite la comunicaci\u00f3n de los humanos con los ordenadores. C --> bases de datos, videojuegos, kernel linux, IOT, dispositivos inteligentes, etc. Python --> inteligencia artificial, big data, etc. Java --> puntos de ventas, aplicaciones de escritorio, cajeros autom\u00e1ticos, dispositivos m\u00f3viles, ...","title":"Lenguajes de programaci\u00f3n"},{"location":"ud1/1elementos/#con-que-lenguaje-de-programacion-debo-empezar","text":"En realidad, no existe el mejor lenguaje de programaci\u00f3n para empezar, y el lenguaje que elijas pr\u00e1cticamente no tendr\u00e1 un efecto duradero en tu carrera. Los lenguajes de programaci\u00f3n pueden verse muy diferentes en la superficie, pero la mayor\u00eda de los conceptos fundamentales se transferir\u00e1n de un lenguaje a otro. Aprender un nuevo idioma tambi\u00e9n ser\u00e1 m\u00e1s f\u00e1cil con el tiempo; un principiante puede tardar meses antes de que se sienta c\u00f3modo con su primer lenguaje; un programador experimentado puede familiarizarse con un nuevo idioma en cuesti\u00f3n de d\u00edas.","title":"\u00bfCon qu\u00e9 lenguaje de programaci\u00f3n debo empezar?"},{"location":"ud1/1elementos/#7-tips-para-aprender-a-programar-con-exito","text":"1 . Learn by doing. Always play with the code while learning 2 . Grasp the fundamentals for long-term benefits 3 . Code by hand. It sharpens proficiency and you\u2019ll need it to get a job 4 . Ask for help. You\u2019ll need it 5 . Seek out more online resources. There\u2019s a wealth of content 6 . Don\u2019t just read the sample code. Tinker with it! 7 . Take breaks when debugging Fuente: Coding dojo Tip S\u00e9 persistente, no te rindas!","title":"7 Tips para aprender a programar con \u00e9xito"},{"location":"ud2/11booleanexpressions/","text":"Expresiones booleanas Las sentencias if del cap\u00edtulo anterior inclu\u00edan preguntas simples de verdadero / falso (expresiones booleanas) como num<10 o jugadores==1. A menudo, las expresiones booleanas simples no son suficientes. Este cap\u00edtulo trata sobre expresiones booleanas m\u00e1s complicadas. && El operador AND && es un operador l\u00f3gico. Un operador l\u00f3gico examina dos valores verdadero / falso y genera un \u00fanico valor verdadero / falso. Por ejemplo cuando necesitas verificar m\u00e1s de una expresi\u00f3n. if ( harina == 100 && azucar >= 65 ) { } Cada parte es una expresi\u00f3n relacional. Una expresi\u00f3n relacional es un tipo de expresi\u00f3n booleana que usa un operador relacional para calcular un valor verdadero o falso. Las expresiones se eval\u00faan de izquierda a derecha, as\u00ed, tan pronto se detecta el primer false, la expresi\u00f3n entera se convierte en false y no se eval\u00faa el resto de expresiones. || El operador OR || se usa en una expresi\u00f3n booleana para verificar que haya al menos una verdadera. Si solo un lado es verdadero, toda la expresi\u00f3n es verdadera. Si ambos lados son falsos, toda la expresi\u00f3n es falsa. if ( ahorrosMensuales > 1000 || pr\u00e9stamo == 3000 ) { } ! El operador NOT ! cambia de verdadero a falso y de falso a verdadero. Esto puede parecer una tonter\u00eda, pero a menudo es \u00fatil. A veces es m\u00e1s natural expresar una condici\u00f3n de una manera particular, pero la l\u00f3gica del programa requiere lo contrario de lo que ha escrito. if ( ! ( precio < 35 )) { }","title":"Expresiones booleanas"},{"location":"ud2/11booleanexpressions/#expresiones-booleanas","text":"Las sentencias if del cap\u00edtulo anterior inclu\u00edan preguntas simples de verdadero / falso (expresiones booleanas) como num<10 o jugadores==1. A menudo, las expresiones booleanas simples no son suficientes. Este cap\u00edtulo trata sobre expresiones booleanas m\u00e1s complicadas.","title":"Expresiones booleanas"},{"location":"ud2/11booleanexpressions/#_1","text":"El operador AND && es un operador l\u00f3gico. Un operador l\u00f3gico examina dos valores verdadero / falso y genera un \u00fanico valor verdadero / falso. Por ejemplo cuando necesitas verificar m\u00e1s de una expresi\u00f3n. if ( harina == 100 && azucar >= 65 ) { } Cada parte es una expresi\u00f3n relacional. Una expresi\u00f3n relacional es un tipo de expresi\u00f3n booleana que usa un operador relacional para calcular un valor verdadero o falso. Las expresiones se eval\u00faan de izquierda a derecha, as\u00ed, tan pronto se detecta el primer false, la expresi\u00f3n entera se convierte en false y no se eval\u00faa el resto de expresiones.","title":"&amp;&amp;"},{"location":"ud2/11booleanexpressions/#_2","text":"El operador OR || se usa en una expresi\u00f3n booleana para verificar que haya al menos una verdadera. Si solo un lado es verdadero, toda la expresi\u00f3n es verdadera. Si ambos lados son falsos, toda la expresi\u00f3n es falsa. if ( ahorrosMensuales > 1000 || pr\u00e9stamo == 3000 ) { }","title":"||"},{"location":"ud2/11booleanexpressions/#_3","text":"El operador NOT ! cambia de verdadero a falso y de falso a verdadero. Esto puede parecer una tonter\u00eda, pero a menudo es \u00fatil. A veces es m\u00e1s natural expresar una condici\u00f3n de una manera particular, pero la l\u00f3gica del programa requiere lo contrario de lo que ha escrito. if ( ! ( precio < 35 )) { }","title":"!"},{"location":"ud2/1seleccion/","text":"Sentencia IF Este apartado analiza c\u00f3mo los programas del ordenador toman decisiones utilizando la sentencia if . Esta sentencia es uno de los bloques de construcci\u00f3n fundamentales de la programaci\u00f3n. Veamos c\u00f3mo funciona. Los limpiaparabrisas se controlan con un interruptor de encendido y apagado. El diagrama de flujo de la derecha muestra c\u00f3mo se toma esta decisi\u00f3n. Comience en la parte superior del gr\u00e1fico y luego siga la l\u00ednea hasta la pregunta: \u00bfesta lloviendo? La respuesta es verdadera o falsa. Si la respuesta es verdadera, siga la l\u00ednea etiquetada como Verdadero, siga las instrucciones en el cuadro \"Activo limpiaparabrisas , siga la l\u00ednea para \"Continuar\". Si la respuesta es falsa, siga la l\u00ednea etiquetada como Falso, siga las instrucciones en el cuadro \"limpiaparabrisas desactivados\", siga la l\u00ednea para \"Continuar\". Ejemplo del programa en c\u00f3digo public static void main(String[] args) { Scanner scan = new Scanner( System.in ); String respuesta; System.out.print(\"\u00bfEst\u00e1 lloviendo? (Y or N): \"); respuesta = scan.nextLine(); if (respuesta.equals(\"Y\")) { System.out.println(\"Activa limpiaparabrisas\"); } else { System.out.println(\"Desactiva limpiaparabrisas\"); } } Sentencia simple condicional if La declaraci\u00f3n if es la m\u00e1s b\u00e1sica de todas las declaraciones de flujo de control. Le dice a su programa que ejecute una determinada secci\u00f3n de c\u00f3digo solo si una prueba en particular se eval\u00faa como verdadera. La sentencia simple condicional if tiene la siguiente estructura: if ( * condici\u00f3n * ) { //sentencias } Condicion es una expresi\u00f3n booleana. Recuerde que una expresi\u00f3n es una combinaci\u00f3n de literales, operadores, nombres de variables y par\u00e9ntesis que se utilizan para calcular un valor, o incluso una llamada a un m\u00e9todo. Una expresi\u00f3n booleana es una expresi\u00f3n que se eval\u00faa como verdadera o falsa. Dada esta descripci\u00f3n de la sintaxis de la sentencia if, los siguientes son ejemplos de sentencias if v\u00e1lidas: if ( true ) { System . out . println ( \"expresi\u00f3n if\" ); } int num = 6 ; if ( num > 0 ) { System . out . println ( \"El n\u00famero es positivo.\" ); } Sentencia condicional compuesta if-else Una segunda versi\u00f3n de la sentencia if incorpora una cl\u00e1usula else en la estructura. Esto nos permite ejecutar cualquiera de dos declaraciones separadas (simple o compuesta) como resultado de un booleano expresi\u00f3n. if ( * condici\u00f3n * ) { //sentencias 1 } else { //sentencias 2 } Ejemplo: int numJugadores = 2 ; if ( numJugadores == 1 ) { System . out . println ( \"Single player\" ); } else { System . out . println ( \"Multiplayer\" ); } Sentencia condicional if-else m\u00faltiple Lo que se ejecuta dentro de los if or else, es decir las sentencias pueden ser a su vez sentencias if-else. En otras palabras, es posible incrustar una o m\u00e1s sentencias if-else dentro de otra sentencia if-else, creando as\u00ed una estructura de control anidada. Como ocurre con la mayor\u00eda de las cosas, hacer una estructura de control demasiado compleja no es una buena idea, pero existe una estructura de control est\u00e1ndar anidada ifelse que es muy \u00fatil. Se conoce como selecci\u00f3n de m\u00faltiples v\u00edas. if ( * condici\u00f3n * ) { //sentencias 1 } else if ( * condici\u00f3n * ) { //sentencias 2 } else if ( * condici\u00f3n * ) { ... } else { //sentencias } Ejemplo: if ( numJugadores == 1 ) { System . out . println ( \"Single player\" ); } else if ( numJugadores == 2 ) { System . out . println ( \"Two player\" ); } else if ( numJugadores == 3 ) { System . out . println ( \"Multiplayer\" ); } else { System . out . println ( \"Not possible, too many players\" ); }","title":"If Statement"},{"location":"ud2/1seleccion/#sentencia-if","text":"Este apartado analiza c\u00f3mo los programas del ordenador toman decisiones utilizando la sentencia if . Esta sentencia es uno de los bloques de construcci\u00f3n fundamentales de la programaci\u00f3n. Veamos c\u00f3mo funciona. Los limpiaparabrisas se controlan con un interruptor de encendido y apagado. El diagrama de flujo de la derecha muestra c\u00f3mo se toma esta decisi\u00f3n. Comience en la parte superior del gr\u00e1fico y luego siga la l\u00ednea hasta la pregunta: \u00bfesta lloviendo? La respuesta es verdadera o falsa. Si la respuesta es verdadera, siga la l\u00ednea etiquetada como Verdadero, siga las instrucciones en el cuadro \"Activo limpiaparabrisas , siga la l\u00ednea para \"Continuar\". Si la respuesta es falsa, siga la l\u00ednea etiquetada como Falso, siga las instrucciones en el cuadro \"limpiaparabrisas desactivados\", siga la l\u00ednea para \"Continuar\". Ejemplo del programa en c\u00f3digo public static void main(String[] args) { Scanner scan = new Scanner( System.in ); String respuesta; System.out.print(\"\u00bfEst\u00e1 lloviendo? (Y or N): \"); respuesta = scan.nextLine(); if (respuesta.equals(\"Y\")) { System.out.println(\"Activa limpiaparabrisas\"); } else { System.out.println(\"Desactiva limpiaparabrisas\"); } }","title":"Sentencia IF"},{"location":"ud2/1seleccion/#sentencia-simple-condicional-if","text":"La declaraci\u00f3n if es la m\u00e1s b\u00e1sica de todas las declaraciones de flujo de control. Le dice a su programa que ejecute una determinada secci\u00f3n de c\u00f3digo solo si una prueba en particular se eval\u00faa como verdadera. La sentencia simple condicional if tiene la siguiente estructura: if ( * condici\u00f3n * ) { //sentencias } Condicion es una expresi\u00f3n booleana. Recuerde que una expresi\u00f3n es una combinaci\u00f3n de literales, operadores, nombres de variables y par\u00e9ntesis que se utilizan para calcular un valor, o incluso una llamada a un m\u00e9todo. Una expresi\u00f3n booleana es una expresi\u00f3n que se eval\u00faa como verdadera o falsa. Dada esta descripci\u00f3n de la sintaxis de la sentencia if, los siguientes son ejemplos de sentencias if v\u00e1lidas: if ( true ) { System . out . println ( \"expresi\u00f3n if\" ); } int num = 6 ; if ( num > 0 ) { System . out . println ( \"El n\u00famero es positivo.\" ); }","title":"Sentencia simple condicional if"},{"location":"ud2/1seleccion/#sentencia-condicional-compuesta-if-else","text":"Una segunda versi\u00f3n de la sentencia if incorpora una cl\u00e1usula else en la estructura. Esto nos permite ejecutar cualquiera de dos declaraciones separadas (simple o compuesta) como resultado de un booleano expresi\u00f3n. if ( * condici\u00f3n * ) { //sentencias 1 } else { //sentencias 2 } Ejemplo: int numJugadores = 2 ; if ( numJugadores == 1 ) { System . out . println ( \"Single player\" ); } else { System . out . println ( \"Multiplayer\" ); }","title":"Sentencia condicional compuesta if-else"},{"location":"ud2/1seleccion/#sentencia-condicional-if-else-multiple","text":"Lo que se ejecuta dentro de los if or else, es decir las sentencias pueden ser a su vez sentencias if-else. En otras palabras, es posible incrustar una o m\u00e1s sentencias if-else dentro de otra sentencia if-else, creando as\u00ed una estructura de control anidada. Como ocurre con la mayor\u00eda de las cosas, hacer una estructura de control demasiado compleja no es una buena idea, pero existe una estructura de control est\u00e1ndar anidada ifelse que es muy \u00fatil. Se conoce como selecci\u00f3n de m\u00faltiples v\u00edas. if ( * condici\u00f3n * ) { //sentencias 1 } else if ( * condici\u00f3n * ) { //sentencias 2 } else if ( * condici\u00f3n * ) { ... } else { //sentencias } Ejemplo: if ( numJugadores == 1 ) { System . out . println ( \"Single player\" ); } else if ( numJugadores == 2 ) { System . out . println ( \"Two player\" ); } else if ( numJugadores == 3 ) { System . out . println ( \"Multiplayer\" ); } else { System . out . println ( \"Not possible, too many players\" ); }","title":"Sentencia condicional if-else m\u00faltiple"},{"location":"ud2/22dowhile/","text":"Sentencia DO-WHILE El bucle do-while es una variante del bucle while que proporciona el lenguaje de programaci\u00f3n Java. Se puede expresar de la siguiente forma: //inicializadores do { //bloque de c\u00f3digo: sentencia(s) //actualizador } while ( condici\u00f3n ); La diferencia entre do-while y while es que do-while eval\u00faa la condici\u00f3n despu\u00e9s de ejecutar el cuerpo del bucle. Por lo tanto, las sentencias dentro del bloque do-while se ejecutan al menos una vez . Una estructura while correctamente dise\u00f1ada debe incluir 3 partes: un inicializador, una condici\u00f3n de bucle y un actualizador. El actualizador debe garantizar que la condici\u00f3n de entrada del bucle finalmente falle, permitiendo as\u00ed que el bucle termine . Ejemplo: Muestra los n\u00fameros del 0 al 4 int i = 0 ; do { System . out . println ( i ); i ++ ; } while ( i < 5 ); Salida 0 1 2 3 4 Traza Iteraci\u00f3n Variable i < 5 Acci\u00f3n i = 0 no se verifica imprime 0, incrementa i=1 1a i = 1 true imprime 1, i = 2 2a i = 2 true imprime 2, i = 3 3a i = 3 true imprime 3, i = 4 4a i = 4 true imprime 4, i = 5 5a i = 5 false termina Ejemplo: Sumar los n\u00fameros del 0 al 10 int i = 0 ; //inicializador int suma = 0 ; do { suma = suma + i ; i ++ ; //actualizador } while ( i <= 10 ); System . out . println ( suma ); Salida 55","title":"Bucle do while"},{"location":"ud2/22dowhile/#sentencia-do-while","text":"El bucle do-while es una variante del bucle while que proporciona el lenguaje de programaci\u00f3n Java. Se puede expresar de la siguiente forma: //inicializadores do { //bloque de c\u00f3digo: sentencia(s) //actualizador } while ( condici\u00f3n ); La diferencia entre do-while y while es que do-while eval\u00faa la condici\u00f3n despu\u00e9s de ejecutar el cuerpo del bucle. Por lo tanto, las sentencias dentro del bloque do-while se ejecutan al menos una vez . Una estructura while correctamente dise\u00f1ada debe incluir 3 partes: un inicializador, una condici\u00f3n de bucle y un actualizador. El actualizador debe garantizar que la condici\u00f3n de entrada del bucle finalmente falle, permitiendo as\u00ed que el bucle termine .","title":"Sentencia DO-WHILE"},{"location":"ud2/22dowhile/#ejemplo-muestra-los-numeros-del-0-al-4","text":"int i = 0 ; do { System . out . println ( i ); i ++ ; } while ( i < 5 ); Salida 0 1 2 3 4 Traza Iteraci\u00f3n Variable i < 5 Acci\u00f3n i = 0 no se verifica imprime 0, incrementa i=1 1a i = 1 true imprime 1, i = 2 2a i = 2 true imprime 2, i = 3 3a i = 3 true imprime 3, i = 4 4a i = 4 true imprime 4, i = 5 5a i = 5 false termina","title":"Ejemplo: Muestra los n\u00fameros del 0 al 4"},{"location":"ud2/22dowhile/#ejemplo-sumar-los-numeros-del-0-al-10","text":"int i = 0 ; //inicializador int suma = 0 ; do { suma = suma + i ; i ++ ; //actualizador } while ( i <= 10 ); System . out . println ( suma ); Salida 55","title":"Ejemplo: Sumar los n\u00fameros del 0 al 10"},{"location":"ud2/22for/","text":"Sentencia FOR Un bucle de conteo, o bucle controlado por un contador, es un bucle en el que sabes de antemano cu\u00e1ntas veces se repetir\u00e1. Como por ejemplo el siguiente c\u00f3digo que cuenta hasta 100: int i = 0 ; while ( i < 100 ) { System . out . println ( i ): i ++ ; } Aunque podemos usar una estructura while como la anterior para codificar un bucle de conteo, Java posee una estructura para \u00e9ste prop\u00f3sito, el bucle for . El bucle for se utiliza cuando el n\u00famero de iteraciones es conocido. Mientras que while y do-while se utiliza generalmente cuando el n\u00famero de iteraciones no se conoce. for ( inicializador ; condici\u00f3n ; modificador ) { //cuerpo del bucle } //VARIANTES: Si solo tiene una sentencia en el cuerpo tambi\u00e9n //se puede escribir sin llaves for ( inicializador ; condici\u00f3n ; modificador ) //sentencia; for ( inicializador ; condici\u00f3n ; modificador ) //sentencia; for ( int i = 0 ; i < 100 ; i ++ ) { System . out . println ( i ); } Proceso: Inicializador: inicializa y/o declara variables y se ejecuta solo una vez. Condici\u00f3n: se eval\u00faa la condici\u00f3n. Si la condici\u00f3n es verdadera, se ejecuta el cuerpo del bucle for. Modificador: actualiza el valor de inicializador . La condici\u00f3n se eval\u00faa nuevamente. El proceso contin\u00faa hasta que la condici\u00f3n es falsa. Ejemplo: Imprime cualquier texto por pantalla 4 veces for ( int i = 1 ; i <= 4 ; ++ i ) { System . out . println ( \"This is a for loop.\" ); } Salida This is a for loop. This is a for loop. This is a for loop. This is a for loop. Traza Iteraci\u00f3n Variable i <= 4 Acci\u00f3n 1a i=1 true imprime texto, i=2 2a i=2 true imprime texto, i=3 3a i=3 true imprime texto, i=4 4a i=4 true imprime texto, i=5 5a i=5 false termina La variable de inicializaci\u00f3n en el bucle for, puede ser declarada en otro lugar del c\u00f3digo. Ejemplo: int i ; //c\u00f3digo for ( i = 1 ; i <= 4 ; ++ i ) { System . out . println ( \"This is a for loop.\" ); } Pero esto, viola la idea de que todas las partes del bucle se combinan en una sola declaraci\u00f3n. Por tanto, estar\u00eda bien si la declaraci\u00f3n de la variable i forma parte de la declaraci\u00f3n for. Una variable declarada en una instrucci\u00f3n for solo se puede usar en esa instrucci\u00f3n y en el cuerpo del bucle. Bucle infinito Un l\u00edmite de bucle es un valor que controla cu\u00e1ntas veces se repite un bucle. Un bucle se repetir\u00e1 hasta que se alcance su l\u00edmite de bucle. La condici\u00f3n del bucle debe ser una expresi\u00f3n booleana que pruebe si se ha alcanzado el l\u00edmite del bucle. De manera similar, el actualizador debe modificar el contador del bucle para que avance hacia su l\u00edmite. Si nunca se alcanza el l\u00edmite del bucle, la condici\u00f3n del bucle nunca se volver\u00e1 falsa y el bucle se repetir\u00e1 para siempre. Esto se conoce como bucle infinito . Para salir de un programa con bucle infinito presiona CONTROL+C. Bucle for-each Lo veremos m\u00e1s adelante, cuando veamos los arrays y colecciones.","title":"Bucle for"},{"location":"ud2/22for/#sentencia-for","text":"Un bucle de conteo, o bucle controlado por un contador, es un bucle en el que sabes de antemano cu\u00e1ntas veces se repetir\u00e1. Como por ejemplo el siguiente c\u00f3digo que cuenta hasta 100: int i = 0 ; while ( i < 100 ) { System . out . println ( i ): i ++ ; } Aunque podemos usar una estructura while como la anterior para codificar un bucle de conteo, Java posee una estructura para \u00e9ste prop\u00f3sito, el bucle for . El bucle for se utiliza cuando el n\u00famero de iteraciones es conocido. Mientras que while y do-while se utiliza generalmente cuando el n\u00famero de iteraciones no se conoce. for ( inicializador ; condici\u00f3n ; modificador ) { //cuerpo del bucle } //VARIANTES: Si solo tiene una sentencia en el cuerpo tambi\u00e9n //se puede escribir sin llaves for ( inicializador ; condici\u00f3n ; modificador ) //sentencia; for ( inicializador ; condici\u00f3n ; modificador ) //sentencia; for ( int i = 0 ; i < 100 ; i ++ ) { System . out . println ( i ); } Proceso: Inicializador: inicializa y/o declara variables y se ejecuta solo una vez. Condici\u00f3n: se eval\u00faa la condici\u00f3n. Si la condici\u00f3n es verdadera, se ejecuta el cuerpo del bucle for. Modificador: actualiza el valor de inicializador . La condici\u00f3n se eval\u00faa nuevamente. El proceso contin\u00faa hasta que la condici\u00f3n es falsa.","title":"Sentencia FOR"},{"location":"ud2/22for/#ejemplo-imprime-cualquier-texto-por-pantalla-4-veces","text":"for ( int i = 1 ; i <= 4 ; ++ i ) { System . out . println ( \"This is a for loop.\" ); } Salida This is a for loop. This is a for loop. This is a for loop. This is a for loop. Traza Iteraci\u00f3n Variable i <= 4 Acci\u00f3n 1a i=1 true imprime texto, i=2 2a i=2 true imprime texto, i=3 3a i=3 true imprime texto, i=4 4a i=4 true imprime texto, i=5 5a i=5 false termina La variable de inicializaci\u00f3n en el bucle for, puede ser declarada en otro lugar del c\u00f3digo. Ejemplo: int i ; //c\u00f3digo for ( i = 1 ; i <= 4 ; ++ i ) { System . out . println ( \"This is a for loop.\" ); } Pero esto, viola la idea de que todas las partes del bucle se combinan en una sola declaraci\u00f3n. Por tanto, estar\u00eda bien si la declaraci\u00f3n de la variable i forma parte de la declaraci\u00f3n for. Una variable declarada en una instrucci\u00f3n for solo se puede usar en esa instrucci\u00f3n y en el cuerpo del bucle.","title":"Ejemplo: Imprime cualquier texto por pantalla 4 veces"},{"location":"ud2/22for/#bucle-infinito","text":"Un l\u00edmite de bucle es un valor que controla cu\u00e1ntas veces se repite un bucle. Un bucle se repetir\u00e1 hasta que se alcance su l\u00edmite de bucle. La condici\u00f3n del bucle debe ser una expresi\u00f3n booleana que pruebe si se ha alcanzado el l\u00edmite del bucle. De manera similar, el actualizador debe modificar el contador del bucle para que avance hacia su l\u00edmite. Si nunca se alcanza el l\u00edmite del bucle, la condici\u00f3n del bucle nunca se volver\u00e1 falsa y el bucle se repetir\u00e1 para siempre. Esto se conoce como bucle infinito . Para salir de un programa con bucle infinito presiona CONTROL+C.","title":"Bucle infinito"},{"location":"ud2/22for/#bucle-for-each","text":"Lo veremos m\u00e1s adelante, cuando veamos los arrays y colecciones.","title":"Bucle for-each"},{"location":"ud2/22nestedloop/","text":"Bucles anidados Un bucle anidado es una estructura en la que un bucle est\u00e1 contenido dentro del cuerpo de otro bucle. Por ejemplo, imagina que quieres imprimir algo como la siguiente tabla de n\u00fameros, donde en la fila y columnas superiores aparecen las posiciones y dentro de las filas tenemos fila x columna. Para producir esta tabla de multiplicar, podr\u00edamos usar los siguientes bucles for anidados: 1 for ( int fila = 1 ; fila <= 4 ; fila ++ ) { //para cada una de las 4 filas 2 for ( int col = 1 ; col <= 9 ; col ++ ) //para cada una de las 9 columnas 3 System . out . print ( col * fila + \"\\t\" ); //muestra la multiplicaci\u00f3n 4 System . out . println (); //Empieza una nueva fila 5 } Indentamos el c\u00f3digo para hacer que sea m\u00e1s legible. En este ejemplo, el bucle externo controla el n\u00famero de filas en la tabla, es decir, nuestra elecci\u00f3n de fila como su contador de bucle. La instrucci\u00f3n println() (l\u00ednea 4) se ejecuta despu\u00e9s de que el bucle interno haya terminado de iterar, lo que nos permite imprimir una nueva fila en cada iteraci\u00f3n del bucle externo. El bucle interno imprime los nueve valores en cada fila imprimiendo la expresi\u00f3n col * fila . Obviamente, el valor de esta expresi\u00f3n depende de ambas variables de bucle. Analicemos un poco el ejemplo anterior: \u00bfCu\u00e1ntas veces se ejecuta la instrucci\u00f3n for en la l\u00ednea 2? El bucle interno se ejecuta una vez por cada iteraci\u00f3n del bucle externo. Por lo tanto, se ejecuta cuatro veces, que es el mismo n\u00famero de veces que se ejecuta la l\u00ednea 4. \u00bfCu\u00e1ntas veces se ejecuta la declaraci\u00f3n de la l\u00ednea 3? El cuerpo del bucle interno se ejecuta 36 veces, 9 veces por cada ejecuci\u00f3n de la l\u00ednea 2. Patrones de FOR anidado A veces es \u00fatil usar la variable del bucle externo como l\u00edmite para el bucle interno. Por ejemplo, veamos el siguiente patr\u00f3n: El n\u00famero de s\u00edmbolos # en cada fila var\u00eda inversamente con el n\u00famero de fila. En la fila 1, tenemos cinco s\u00edmbolos; en la fila 2 tenemos cuatro; y as\u00ed sucesivamente hasta la fila 5, donde tenemos un #. Para producir este tipo de patr\u00f3n bidimensional, necesitamos dos contadores : uno para contar el n\u00famero de fila y otro para contar el n\u00famero de s\u00edmbolos # en cada fila. Debido a que tenemos que imprimir los s\u00edmbolos de cada fila antes de pasar a la siguiente fila, el ciclo externo contar\u00e1 los n\u00fameros de fila y el ciclo interno contar\u00e1 los s\u00edmbolos en cada fila. La siguiente tabla muestra la relaci\u00f3n que queremos: Fila L\u00edmite (6-i) N\u00fam. s\u00edmbolos 1 6-1 5 2 6-2 4 3 6-3 3 4 6-4 2 5 6-5 1 Si dejamos que j sea el contador del bucle interno, entonces j estar\u00e1 limitado por la expresi\u00f3n 6 - i . Esto conduce a la siguiente estructura de bucle anidado: for ( int i = 1 ; i <= 5 ; i ++ ) { for ( int j = 1 ; j <= ( 6 - i ); j ++ ) { System . out . print ( '#' ); } System . out . println (); } Otra soluci\u00f3n si no queremos usar un literal en la condici\u00f3n del bucle interno ser\u00eda: for ( int i = 1 ; i <= 5 ; i ++ ) { for ( int j = 5 ; j >= i ; j -- ) { System . out . print ( '#' ); } System . out . println (); } A menudo los literales que aparecen como l\u00edmites en los bucles for se denominan n\u00fameros m\u00e1gicos y pueden crear problemas de redundancia en el c\u00f3digo o c\u00f3digo no legible. Para solucionar esto utilizamos constantes: final int MAX_WIDTH = 5 ; for ( int i = 1 ; i <= MAX_WIDTH ; i ++ ) { for ( int j = MAX_WIDTH ; j >= i ; j -- ) { System . out . print ( '#' ); } System . out . println (); }","title":"Bucles anidados"},{"location":"ud2/22nestedloop/#bucles-anidados","text":"Un bucle anidado es una estructura en la que un bucle est\u00e1 contenido dentro del cuerpo de otro bucle. Por ejemplo, imagina que quieres imprimir algo como la siguiente tabla de n\u00fameros, donde en la fila y columnas superiores aparecen las posiciones y dentro de las filas tenemos fila x columna. Para producir esta tabla de multiplicar, podr\u00edamos usar los siguientes bucles for anidados: 1 for ( int fila = 1 ; fila <= 4 ; fila ++ ) { //para cada una de las 4 filas 2 for ( int col = 1 ; col <= 9 ; col ++ ) //para cada una de las 9 columnas 3 System . out . print ( col * fila + \"\\t\" ); //muestra la multiplicaci\u00f3n 4 System . out . println (); //Empieza una nueva fila 5 } Indentamos el c\u00f3digo para hacer que sea m\u00e1s legible. En este ejemplo, el bucle externo controla el n\u00famero de filas en la tabla, es decir, nuestra elecci\u00f3n de fila como su contador de bucle. La instrucci\u00f3n println() (l\u00ednea 4) se ejecuta despu\u00e9s de que el bucle interno haya terminado de iterar, lo que nos permite imprimir una nueva fila en cada iteraci\u00f3n del bucle externo. El bucle interno imprime los nueve valores en cada fila imprimiendo la expresi\u00f3n col * fila . Obviamente, el valor de esta expresi\u00f3n depende de ambas variables de bucle. Analicemos un poco el ejemplo anterior: \u00bfCu\u00e1ntas veces se ejecuta la instrucci\u00f3n for en la l\u00ednea 2? El bucle interno se ejecuta una vez por cada iteraci\u00f3n del bucle externo. Por lo tanto, se ejecuta cuatro veces, que es el mismo n\u00famero de veces que se ejecuta la l\u00ednea 4. \u00bfCu\u00e1ntas veces se ejecuta la declaraci\u00f3n de la l\u00ednea 3? El cuerpo del bucle interno se ejecuta 36 veces, 9 veces por cada ejecuci\u00f3n de la l\u00ednea 2.","title":"Bucles anidados"},{"location":"ud2/22nestedloop/#patrones-de-for-anidado","text":"A veces es \u00fatil usar la variable del bucle externo como l\u00edmite para el bucle interno. Por ejemplo, veamos el siguiente patr\u00f3n: El n\u00famero de s\u00edmbolos # en cada fila var\u00eda inversamente con el n\u00famero de fila. En la fila 1, tenemos cinco s\u00edmbolos; en la fila 2 tenemos cuatro; y as\u00ed sucesivamente hasta la fila 5, donde tenemos un #. Para producir este tipo de patr\u00f3n bidimensional, necesitamos dos contadores : uno para contar el n\u00famero de fila y otro para contar el n\u00famero de s\u00edmbolos # en cada fila. Debido a que tenemos que imprimir los s\u00edmbolos de cada fila antes de pasar a la siguiente fila, el ciclo externo contar\u00e1 los n\u00fameros de fila y el ciclo interno contar\u00e1 los s\u00edmbolos en cada fila. La siguiente tabla muestra la relaci\u00f3n que queremos: Fila L\u00edmite (6-i) N\u00fam. s\u00edmbolos 1 6-1 5 2 6-2 4 3 6-3 3 4 6-4 2 5 6-5 1 Si dejamos que j sea el contador del bucle interno, entonces j estar\u00e1 limitado por la expresi\u00f3n 6 - i . Esto conduce a la siguiente estructura de bucle anidado: for ( int i = 1 ; i <= 5 ; i ++ ) { for ( int j = 1 ; j <= ( 6 - i ); j ++ ) { System . out . print ( '#' ); } System . out . println (); } Otra soluci\u00f3n si no queremos usar un literal en la condici\u00f3n del bucle interno ser\u00eda: for ( int i = 1 ; i <= 5 ; i ++ ) { for ( int j = 5 ; j >= i ; j -- ) { System . out . print ( '#' ); } System . out . println (); } A menudo los literales que aparecen como l\u00edmites en los bucles for se denominan n\u00fameros m\u00e1gicos y pueden crear problemas de redundancia en el c\u00f3digo o c\u00f3digo no legible. Para solucionar esto utilizamos constantes: final int MAX_WIDTH = 5 ; for ( int i = 1 ; i <= MAX_WIDTH ; i ++ ) { for ( int j = MAX_WIDTH ; j >= i ; j -- ) { System . out . print ( '#' ); } System . out . println (); }","title":"Patrones de FOR anidado"},{"location":"ud2/22principlesloop/","text":"Principios del dise\u00f1o de bucles Un bucle de conteo se utiliza siempre que se sepa de antemano exactamente cu\u00e1ntas iteraciones se necesitan. La instrucci\u00f3n for de Java es una estructura apropiada para codificar un bucle de conteo. Se debe usar una estructura while cuando el problema sugiera que el cuerpo del bucle puede omitirse por completo. Una estructura do-while debe usarse solo cuando un bucle requiere al menos una o m\u00e1s iteraciones. La variable de bucle se utiliza para especificar la condici\u00f3n de entrada de bucle. Debe inicializarse a un valor inicial apropiado y debe actualizarse en cada iteraci\u00f3n del bucle. El l\u00edmite de un bucle puede ser un recuento, un centinela o, de manera m\u00e1s general, un l\u00edmite condicional. Debe estar correctamente especificado en la expresi\u00f3n de entrada de bucle y el progreso hacia el l\u00edmite debe realizarse en el actualizador. Puede producirse un bucle infinito si el inicializador, la expresi\u00f3n de entrada de bucle o la expresi\u00f3n del actualizador no se especifican correctamente.","title":"Principios del dise\u00f1o de bucles"},{"location":"ud2/22principlesloop/#principios-del-diseno-de-bucles","text":"Un bucle de conteo se utiliza siempre que se sepa de antemano exactamente cu\u00e1ntas iteraciones se necesitan. La instrucci\u00f3n for de Java es una estructura apropiada para codificar un bucle de conteo. Se debe usar una estructura while cuando el problema sugiera que el cuerpo del bucle puede omitirse por completo. Una estructura do-while debe usarse solo cuando un bucle requiere al menos una o m\u00e1s iteraciones. La variable de bucle se utiliza para especificar la condici\u00f3n de entrada de bucle. Debe inicializarse a un valor inicial apropiado y debe actualizarse en cada iteraci\u00f3n del bucle. El l\u00edmite de un bucle puede ser un recuento, un centinela o, de manera m\u00e1s general, un l\u00edmite condicional. Debe estar correctamente especificado en la expresi\u00f3n de entrada de bucle y el progreso hacia el l\u00edmite debe realizarse en el actualizador. Puede producirse un bucle infinito si el inicializador, la expresi\u00f3n de entrada de bucle o la expresi\u00f3n del actualizador no se especifican correctamente.","title":"Principios del dise\u00f1o de bucles"},{"location":"ud2/22while/","text":"Sentencia WHILE Una estructura de repetici\u00f3n es una estructura de control que repite una declaraci\u00f3n o secuencia de declaraciones de forma controlada. Las estructuras de repetici\u00f3n tambi\u00e9n se denominan estructuras de bucle . Muchos tipos de tareas de programaci\u00f3n requieren una estructura de repetici\u00f3n. Por ejemplo: Sumar los cuadrados de los n\u00fameros del 1 al 100. Un empleado de seguridad inform\u00e1tica quiere probar todas las contrase\u00f1as posibles para entrar en la cuenta de un presunto esp\u00eda. Quieres que los jugadores inserten movimientos durante un turno en un juego hasta que el juego ha terminado. La instrucci\u00f3n while es una instrucci\u00f3n de bucle en la que la condici\u00f3n de bucle ocurre antes que el cuerpo del bucle. Tiene la siguiente estructura: while ( condici\u00f3n ) { //cuerpo del bucle //bloque de c\u00f3digo: sentencia(s) } //VARIANTES: Si solo tiene una sentencia en el cuerpo //tambi\u00e9n se puede escribir as\u00ed while ( condici\u00f3n ) //sentencia; Contiene la palabra reservada while seguida de un bloque de c\u00f3digo. Un bloque es un conjunto de sentencias encerradas entre corchetes { y }. Cuando se ejecuta la instrucci\u00f3n while, se eval\u00faa la condici\u00f3n del bucle, que es una expresi\u00f3n booleana y sucede alguno de los siguientes escenarios: Si esto se eval\u00faa como falso, la ejecuci\u00f3n contin\u00faa en la instrucci\u00f3n inmediatamente despu\u00e9s del cuerpo del bucle(fuera del bloque). Si la condici\u00f3n de bucle se eval\u00faa como verdadero, el cuerpo del bucle se ejecuta y luego la condici\u00f3n se eval\u00faa nuevamente y se repite el proceso. El cuerpo del bucle contin\u00faa ejecut\u00e1ndose hasta que la condici\u00f3n se eval\u00faa como falsa. Para que una declaraci\u00f3n while realice una tarea, la variable o variables en la condici\u00f3n de entrada de bucle deben inicializarse correctamente antes; y adem\u00e1s estas variables deben actualizarse correctamente al final del cuerpo de bucle. Podemos reformular las pautas anteriores como un principio de dise\u00f1o: Una estructura while correctamente dise\u00f1ada debe incluir 3 partes: un inicializador, una condici\u00f3n de bucle y un actualizador. El actualizador debe garantizar que la condici\u00f3n de entrada del bucle finalmente falle, permitiendo as\u00ed que el bucle termine . //inicializadores while ( condici\u00f3n ) { //sentencias //actualizador } Ejemplo: Mostrar los 3 primeros n\u00fameros int i = 1 ; //inicializador while ( i <= 3 ) { System . out . println ( i ); //Sentencia i = i + 1 ; //actualizador } Salida 1 2 3 Traza Iteraci\u00f3n Variable i <= 3 Acci\u00f3n 1a i = 1 true imprime 1, incrementa i=2 2a i = 2 true imprime 2, incrementa i = 3 3a i = 3 true imprime 3, incrementa i = 4 4a i = 4 false termina el bucle Ejemplo: Sumar los n\u00fameros del 0 al 10 int i = 0 ; //inicializador int suma = 0 ; while ( i <= 10 ) { suma = suma + i ; i ++ ; //actualizador } System . out . println ( suma ); Salida 55 Traza Iteraci\u00f3n Variable i <= 10 Acci\u00f3n 1a suma=0, i=0 true suma=0, incrementa i(1) 2a suma=0, i=1 true suma=1, incrementa i(2) 3a suma=1, i=2 true suma=3, incrementa i(3) 4a suma=3, i=3 true suma=6, incrementa i(4) 5a suma=6, i=4 true suma=10, incrementa i(5) .. .. .. .. 12a suma=55, i=11 false termina","title":"Bucle while"},{"location":"ud2/22while/#sentencia-while","text":"Una estructura de repetici\u00f3n es una estructura de control que repite una declaraci\u00f3n o secuencia de declaraciones de forma controlada. Las estructuras de repetici\u00f3n tambi\u00e9n se denominan estructuras de bucle . Muchos tipos de tareas de programaci\u00f3n requieren una estructura de repetici\u00f3n. Por ejemplo: Sumar los cuadrados de los n\u00fameros del 1 al 100. Un empleado de seguridad inform\u00e1tica quiere probar todas las contrase\u00f1as posibles para entrar en la cuenta de un presunto esp\u00eda. Quieres que los jugadores inserten movimientos durante un turno en un juego hasta que el juego ha terminado. La instrucci\u00f3n while es una instrucci\u00f3n de bucle en la que la condici\u00f3n de bucle ocurre antes que el cuerpo del bucle. Tiene la siguiente estructura: while ( condici\u00f3n ) { //cuerpo del bucle //bloque de c\u00f3digo: sentencia(s) } //VARIANTES: Si solo tiene una sentencia en el cuerpo //tambi\u00e9n se puede escribir as\u00ed while ( condici\u00f3n ) //sentencia; Contiene la palabra reservada while seguida de un bloque de c\u00f3digo. Un bloque es un conjunto de sentencias encerradas entre corchetes { y }. Cuando se ejecuta la instrucci\u00f3n while, se eval\u00faa la condici\u00f3n del bucle, que es una expresi\u00f3n booleana y sucede alguno de los siguientes escenarios: Si esto se eval\u00faa como falso, la ejecuci\u00f3n contin\u00faa en la instrucci\u00f3n inmediatamente despu\u00e9s del cuerpo del bucle(fuera del bloque). Si la condici\u00f3n de bucle se eval\u00faa como verdadero, el cuerpo del bucle se ejecuta y luego la condici\u00f3n se eval\u00faa nuevamente y se repite el proceso. El cuerpo del bucle contin\u00faa ejecut\u00e1ndose hasta que la condici\u00f3n se eval\u00faa como falsa. Para que una declaraci\u00f3n while realice una tarea, la variable o variables en la condici\u00f3n de entrada de bucle deben inicializarse correctamente antes; y adem\u00e1s estas variables deben actualizarse correctamente al final del cuerpo de bucle. Podemos reformular las pautas anteriores como un principio de dise\u00f1o: Una estructura while correctamente dise\u00f1ada debe incluir 3 partes: un inicializador, una condici\u00f3n de bucle y un actualizador. El actualizador debe garantizar que la condici\u00f3n de entrada del bucle finalmente falle, permitiendo as\u00ed que el bucle termine . //inicializadores while ( condici\u00f3n ) { //sentencias //actualizador }","title":"Sentencia WHILE"},{"location":"ud2/22while/#ejemplo-mostrar-los-3-primeros-numeros","text":"int i = 1 ; //inicializador while ( i <= 3 ) { System . out . println ( i ); //Sentencia i = i + 1 ; //actualizador } Salida 1 2 3 Traza Iteraci\u00f3n Variable i <= 3 Acci\u00f3n 1a i = 1 true imprime 1, incrementa i=2 2a i = 2 true imprime 2, incrementa i = 3 3a i = 3 true imprime 3, incrementa i = 4 4a i = 4 false termina el bucle","title":"Ejemplo: Mostrar los 3 primeros n\u00fameros"},{"location":"ud2/22while/#ejemplo-sumar-los-numeros-del-0-al-10","text":"int i = 0 ; //inicializador int suma = 0 ; while ( i <= 10 ) { suma = suma + i ; i ++ ; //actualizador } System . out . println ( suma ); Salida 55 Traza Iteraci\u00f3n Variable i <= 10 Acci\u00f3n 1a suma=0, i=0 true suma=0, incrementa i(1) 2a suma=0, i=1 true suma=1, incrementa i(2) 3a suma=1, i=2 true suma=3, incrementa i(3) 4a suma=3, i=3 true suma=6, incrementa i(4) 5a suma=6, i=4 true suma=10, incrementa i(5) .. .. .. .. 12a suma=55, i=11 false termina","title":"Ejemplo: Sumar los n\u00fameros del 0 al 10"},{"location":"ud2/22whileif/","text":"Bucles WHILE con sentencias IF Este cap\u00edtulo muestra c\u00f3mo los bucles while y las instrucciones if se usan juntas para implementar la l\u00f3gica de un programa. El siguiente c\u00f3digo muestra un esqueleto de un programa que suma todos los n\u00fameros enteros hasta un l\u00edmite y suma tambi\u00e9n los que son n\u00fameros pares. STEP 1 Primero, inicializamos la variable count. El bucle debe contar desde uno hasta el l\u00edmite(incluido). En este programa, la mayor parte de la l\u00f3gica est\u00e1 contenida dentro del cuerpo del bucle. Comprobamos que el programa se puede compilar y ejecutar. Si no fuera as\u00ed, corrige los errores de sintaxis (si los hay) y busca qu\u00e9 errores tienes. Inserta algunas sentencias println temporales para ayudarte en la b\u00fasqueda de errores. (O usa un depurador). Tip Es mejor escribir un programa por etapas. Escriba y depura cada etapa antes de construir sobre el. En un programa con un bucle principal, la primera etapa es construir el bucle. STEP 2 El bucle de momento solo cuenta n\u00fameros hasta un l\u00edmite, pero todav\u00eda no hace nada con ellos. Esto es lo que queremos que suceda: Sumar cada entero y asignarlo a sumaTotal. Sumar cada entero par y asginarlo a sumaPar. \u00bfC\u00f3mo decidimos cuando agregar un n\u00famero entero a sumaPar? Para ello necesitaremos la sentencia if . El cuerpo del bucle en este programa contiene una instrucci\u00f3n if. Una instrucci\u00f3n if dentro de un cuerpo de bucle se denomina if anidado. No tiene nada de especial funciona igual que fuera del cuerpo del bucle. \u00bfC\u00f3mo calculamos los n\u00fameros que son pares? Los n\u00fameros pares son aquellos que son divisibles por 2. Podemos hacerlo usando el operador %. Si el resto al dividir entre 2 da 0, entonces obtenemos un n\u00famero par.","title":"Bucles while con if"},{"location":"ud2/22whileif/#bucles-while-con-sentencias-if","text":"Este cap\u00edtulo muestra c\u00f3mo los bucles while y las instrucciones if se usan juntas para implementar la l\u00f3gica de un programa. El siguiente c\u00f3digo muestra un esqueleto de un programa que suma todos los n\u00fameros enteros hasta un l\u00edmite y suma tambi\u00e9n los que son n\u00fameros pares.","title":"Bucles WHILE con sentencias IF"},{"location":"ud2/22whileif/#step-1","text":"Primero, inicializamos la variable count. El bucle debe contar desde uno hasta el l\u00edmite(incluido). En este programa, la mayor parte de la l\u00f3gica est\u00e1 contenida dentro del cuerpo del bucle. Comprobamos que el programa se puede compilar y ejecutar. Si no fuera as\u00ed, corrige los errores de sintaxis (si los hay) y busca qu\u00e9 errores tienes. Inserta algunas sentencias println temporales para ayudarte en la b\u00fasqueda de errores. (O usa un depurador). Tip Es mejor escribir un programa por etapas. Escriba y depura cada etapa antes de construir sobre el. En un programa con un bucle principal, la primera etapa es construir el bucle.","title":"STEP 1"},{"location":"ud2/22whileif/#step-2","text":"El bucle de momento solo cuenta n\u00fameros hasta un l\u00edmite, pero todav\u00eda no hace nada con ellos. Esto es lo que queremos que suceda: Sumar cada entero y asignarlo a sumaTotal. Sumar cada entero par y asginarlo a sumaPar. \u00bfC\u00f3mo decidimos cuando agregar un n\u00famero entero a sumaPar? Para ello necesitaremos la sentencia if . El cuerpo del bucle en este programa contiene una instrucci\u00f3n if. Una instrucci\u00f3n if dentro de un cuerpo de bucle se denomina if anidado. No tiene nada de especial funciona igual que fuera del cuerpo del bucle. \u00bfC\u00f3mo calculamos los n\u00fameros que son pares? Los n\u00fameros pares son aquellos que son divisibles por 2. Podemos hacerlo usando el operador %. Si el resto al dividir entre 2 da 0, entonces obtenemos un n\u00famero par.","title":"STEP 2"},{"location":"ud2/23breakcontinue/","text":"Break y continue Las sentencias break y continue son las sentencias de salto que se utilizan para omitir algunas sentencias dentro del bucle o terminar el bucle inmediatamente sin comprobar la condici\u00f3n. Estas instrucciones se pueden usar dentro de cualquier bucle, como for, while, do-while. BREAK Ya se ha visto la instrucci\u00f3n break utilizada en un cap\u00edtulo anterior de este tutorial. En concreto en la estructura switch. La sentencia break en java se usa para terminar el bucle inmediatamente. Cuando se encuentra una sentencia break dentro de un bucle, la iteraci\u00f3n del bucle se detiene ah\u00ed y el control vuelve a la primera sentencia despu\u00e9s del bucle. B\u00e1sicamente, las instrucciones break se utilizan en situaciones en las que no estamos seguros del n\u00famero real de iteraciones del bucle o queremos terminar el bucle en funci\u00f3n de alguna condici\u00f3n. for ( int i = 0 ; i < 10 ; i ++ ) { if ( i == 3 ) break ; System . out . print ( i + \" \" ); } System . out . println ( \"Fuera del bucle for\" ); Output : 0 1 2 Fuera del bucle for Note En el caso de bucles anidados, la instrucci\u00f3n break termina el bucle m\u00e1s interno. Break etiquetado Hasta ahora, hemos utilizado la sentencia break sin etiquetar. Sin embargo, hay otra forma de utilizar break en Java conocido como break etiquetado (labeled break). En la imagen se ha utilizado un break etiquetado con el identificador label para especificar el bucle exterior. Observa c\u00f3mo se usa la declaraci\u00f3n break con etiqueta. La sentencia break est\u00e1 terminando la sentencia etiquetada (es decir, el bucle externo). Luego, el control del programa salta a la sentencia justo despu\u00e9s de la etiquetada. De esta forma, podr\u00edamos utilizar la sentencia break etiquetada para terminar el bucle m\u00e1s externo como se ve en el siguiente ejemplo: public static void main ( String [] args ) { //el primer bucle es etiquetado como primero primero : for ( int i = 1 ; i < 5 ; i ++ ) { // el segundo bucle como segundo segundo : for ( int j = 1 ; j <= 2 ; j ++ ) { System . out . println ( \"i = \" + i + \"; j = \" + j ); // se realiza un break del primer bucle if ( i == 2 ) break primero ; } } } Output i = 1; j = 1 i = 1; j = 2 i = 2; j = 1 CONTINUE La instrucci\u00f3n continue en Java se usa para omitir la iteraci\u00f3n actual de un bucle y continuar con la siguiente iteraci\u00f3n del bucle. Podemos usar la instrucci\u00f3n continue dentro de cualquier tipo de bucle, como el bucle for, while y do-while. B\u00e1sicamente, las sentencias continue se utilizan en situaciones en las que queremos continuar el ciclo pero no queremos la sentencia restante despu\u00e9s de la sentencia continue. for ( int i = 0 ; i < 5 ; i ++ ) { if ( i == 2 ) continue ; System . out . print ( i + \" \" ); } Output : 0 1 3 4","title":"Sentencias break y continue"},{"location":"ud2/23breakcontinue/#break-y-continue","text":"Las sentencias break y continue son las sentencias de salto que se utilizan para omitir algunas sentencias dentro del bucle o terminar el bucle inmediatamente sin comprobar la condici\u00f3n. Estas instrucciones se pueden usar dentro de cualquier bucle, como for, while, do-while.","title":"Break y continue"},{"location":"ud2/23breakcontinue/#break","text":"Ya se ha visto la instrucci\u00f3n break utilizada en un cap\u00edtulo anterior de este tutorial. En concreto en la estructura switch. La sentencia break en java se usa para terminar el bucle inmediatamente. Cuando se encuentra una sentencia break dentro de un bucle, la iteraci\u00f3n del bucle se detiene ah\u00ed y el control vuelve a la primera sentencia despu\u00e9s del bucle. B\u00e1sicamente, las instrucciones break se utilizan en situaciones en las que no estamos seguros del n\u00famero real de iteraciones del bucle o queremos terminar el bucle en funci\u00f3n de alguna condici\u00f3n. for ( int i = 0 ; i < 10 ; i ++ ) { if ( i == 3 ) break ; System . out . print ( i + \" \" ); } System . out . println ( \"Fuera del bucle for\" ); Output : 0 1 2 Fuera del bucle for Note En el caso de bucles anidados, la instrucci\u00f3n break termina el bucle m\u00e1s interno.","title":"BREAK"},{"location":"ud2/23breakcontinue/#break-etiquetado","text":"Hasta ahora, hemos utilizado la sentencia break sin etiquetar. Sin embargo, hay otra forma de utilizar break en Java conocido como break etiquetado (labeled break). En la imagen se ha utilizado un break etiquetado con el identificador label para especificar el bucle exterior. Observa c\u00f3mo se usa la declaraci\u00f3n break con etiqueta. La sentencia break est\u00e1 terminando la sentencia etiquetada (es decir, el bucle externo). Luego, el control del programa salta a la sentencia justo despu\u00e9s de la etiquetada. De esta forma, podr\u00edamos utilizar la sentencia break etiquetada para terminar el bucle m\u00e1s externo como se ve en el siguiente ejemplo: public static void main ( String [] args ) { //el primer bucle es etiquetado como primero primero : for ( int i = 1 ; i < 5 ; i ++ ) { // el segundo bucle como segundo segundo : for ( int j = 1 ; j <= 2 ; j ++ ) { System . out . println ( \"i = \" + i + \"; j = \" + j ); // se realiza un break del primer bucle if ( i == 2 ) break primero ; } } } Output i = 1; j = 1 i = 1; j = 2 i = 2; j = 1","title":"Break etiquetado"},{"location":"ud2/23breakcontinue/#continue","text":"La instrucci\u00f3n continue en Java se usa para omitir la iteraci\u00f3n actual de un bucle y continuar con la siguiente iteraci\u00f3n del bucle. Podemos usar la instrucci\u00f3n continue dentro de cualquier tipo de bucle, como el bucle for, while y do-while. B\u00e1sicamente, las sentencias continue se utilizan en situaciones en las que queremos continuar el ciclo pero no queremos la sentencia restante despu\u00e9s de la sentencia continue. for ( int i = 0 ; i < 5 ; i ++ ) { if ( i == 2 ) continue ; System . out . print ( i + \" \" ); } Output : 0 1 3 4","title":"CONTINUE"},{"location":"ud2/24exceptions/","text":"Excepciones Jerarqu\u00eda de excepciones en Java La clase Throwable es la clase base incorporada que se usa para manejar todas las excepciones en Java. El tipo m\u00e1s gen\u00e9rico de excepci\u00f3n, java.lang.Exception, se encuentra en el paquete java.lang, pero la mayor\u00eda de sus subclases est\u00e1n contenidas en otros paquetes. Un programa a menudo encuentra problemas mientras se ejecuta. Puede tener problemas para leer datos, puede haber caracteres ilegales en los datos o un \u00edndice puede salirse de los l\u00edmites. La clase Java que gestiona estos problemas se llama Exception . La entrada y la salida son especialmente propensas a errores. El manejo de excepciones es esencial para la programaci\u00f3n de I/O. Por ejemplo, \u00bfqu\u00e9 ha ido mal en el siguiente programa?: Si hacemos un seguimiento a la pila de errores, vemos que el usuario insert\u00f3 \"hola\" y la clase Scanner, en concreto el m\u00e9todo nextInt no pudo convertir ese texto en un n\u00famero, por tanto, se lanz\u00f3 una excepci\u00f3n. Eso no significa que el programa est\u00e9 mal, simplemente el fallo est\u00e1 en los datos. Cuando nextInt encuentra el problema lanza la excepci\u00f3n InputMismatchException . La ejecuci\u00f3n del programa Java detecta la excepci\u00f3n y detiene el programa imprimiendo los mensajes de error. Es muy importante leer bien la pila de errores en la consola cuando se lanza una excepci\u00f3n para encontrar el fallo. \u00bfQu\u00e9 es un error? Un error indica que se ha producido un fallo no recuperable, del que no se puede recuperar la ejecuci\u00f3n normal del programa. Un error est\u00e1 representado por un objeto de clase Error . La clase Throwable tiene dos subclases: Exception y Error . Un m\u00e9todo Java puede \"lanzar\" un objeto de clase Throwable. Por ejemplo, Scanner lanz\u00f3 una excepci\u00f3n cuando intent\u00f3 convertir \"hola\" en un n\u00famero entero. Las excepciones son diferentes de los errores porque los programas se pueden escribir para recuperarse de las excepciones, pero los programas no se pueden escribir para recuperarse de los errores. \u00bfQu\u00e9 es una excepci\u00f3n? Una excepci\u00f3n es un problema que ocurre cuando se ejecuta un programa. Cuando ocurre una excepci\u00f3n, la m\u00e1quina virtual Java crea un objeto de clase Exception que contiene informaci\u00f3n sobre el problema. Cuando se lanza una excepci\u00f3n, se puede capturar la excepci\u00f3n para recuperarse del programa. Bloques try - catch Para capturar una excepci\u00f3n realizamos los siguientes pasos: Colocar el c\u00f3digo que pueda lanzar una excepci\u00f3n dentro de un bloque try. Colocar el c\u00f3digo que maneja la excepci\u00f3n dentro de un bloque catch (captura). El bloque catch debe seguir inmediatamente al bloque try. Cada bloque catch es un manejador de excepciones que maneja el tipo de excepci\u00f3n indicado por su argumento. El tipo de argumento, ExceptionType, declara el tipo de excepci\u00f3n que el controlador puede manejar y debe ser el nombre de una clase que hereda de la clase Throwable. El siguiente ejemplo arroja dentro del bloque try una InputMismatchException, el bloque catch comienza a ejecutarse inmediatamente. Se omiten las sentencias restantes en el bloque try. Scanner sc = new Scanner ( System . in ); int numero ; System . out . println ( \"Introduzca un entero:\" ); try { numero = sc . nextInt (); } catch ( InputMismatchException e ) { System . out . println ( \"No has introducido un n\u00famero.\" ); e . printStackTrace (); } System . out . println ( \"Sigue ejecut\u00e1ndose el programa\" ); El par\u00e1metro dentro de catch e se refiere al objeto de excepci\u00f3n que se lanza. Si queremos mostrar la pila de errores que genera el error usamos el m\u00e9todo e.printStackTrace(); Despu\u00e9s de ejecutar el bloque catch, la ejecuci\u00f3n contin\u00faa con la instrucci\u00f3n que sigue al bloque catch. La ejecuci\u00f3n no vuelve al bloque try . C\u00f3mo se ejecuta un try-catch paso por paso Cuando se lanza una excepci\u00f3n dentro de un bloque try, el controlador de excepciones examina la excepci\u00f3n dentro de los bloques catch. Los bloques catch se examinan uno a uno empezando por el primero. El primer bloque catch que encaja con la excepci\u00f3n obtiene el control. Aunque haya muchas excepciones que encajen solo se ejecuta un bloque catch. Si ning\u00fan bloque catch encaja con la excepci\u00f3n lanzada se muestra la pila de errores y se termina la ejecuci\u00f3n del programa ya que no se ha manejado la excepci\u00f3n. Las clases m\u00e1s especificas deben ir primero seguidas de las m\u00e1s generales. Despu\u00e9s de ejecutar la \u00faltima instrucci\u00f3n dentro del catch el control del programa vuelve a la siguiente l\u00ednea fuera del try-catch (o finally si hubiera). Capturar m\u00e1s de una excepci\u00f3n en un solo catch En Java SE 7 y posteriores, un solo bloque catch puede manejar m\u00e1s de un tipo de excepci\u00f3n. Esta funci\u00f3n puede reducir la duplicaci\u00f3n de c\u00f3digo. En la cl\u00e1usula catch, se especifican los tipos de excepciones que puede manejar el bloque y se separa cada tipo de excepci\u00f3n con una barra vertical (|): catch ( IOException | SQLException ex ) { //realizar acciones } Note Si un bloque catch maneja m\u00e1s de un tipo de excepci\u00f3n, el par\u00e1metro catch es impl\u00edcitamente final. En este ejemplo, la variable catch ex es final y, por lo tanto, no puede asignarle ning\u00fan valor dentro del bloque catch. Sentencia throw Utilizando la palabra reservada throw podemos lanzar nosotros expl\u00edcitamente una excepci\u00f3n. Podemos construir una instancia de la excepci\u00f3n que queremos lanzar y a\u00f1adirle un mensaje en el constructor. Ejemplo: try { System . out . print ( \"Inserta el numerador: \" ); num = scan . nextInt (); System . out . print ( \"Inserta el denominador: \" ); div = scan . nextInt (); if ( div == 0 ) throw new ArithmeticException ( \"Error al intentar dividir entre cero\" ); .... } catch ( ArithmeticException ex ) { System . out . println ( \"No se puede dividir \" + num + \" entre \" + div ); System . out . println ( ex . getMessage ()); } Bloque finally El bloque finally siempre se ejecuta cuando sale del bloque try-catch incluso si ocurre una excepci\u00f3n inesperada. Estructura: try { //c\u00f3digo } catch () { //c\u00f3digo } finally { //siempre se ejecuta } Solo puede haber un bloque finally, y debe estar despu\u00e9s de los bloques catch. Si el bloque try sale normalmente (no ocurrieron excepciones), entonces el control va directamente al bloque finally. Si el bloque try sale debido a una excepci\u00f3n que es manejada por un bloque catch, primero ese bloque se ejecuta y luego el control va al bloque finally. Si el bloque try sale debido a una excepci\u00f3n que NO es manejada por un bloque catch, el control va directamente al bloque finally. Despu\u00e9s de que se ejecuta el bloque finally, se lanza la excepci\u00f3n a la persona que llama y el control vuelve a la persona que llama. En resumen: si el control entra en un bloque try, siempre entrar\u00e1 en el bloque finally. Importante El bloque finally es una herramienta clave para prevenir fugas de recursos. Al cerrar un archivo o recuperar recursos, coloque el c\u00f3digo en un bloque final para asegurarse de que el recurso siempre se recupere. Sentencia try-with-resources Pr\u00f3ximamente. Tip M\u00e1s informaci\u00f3n en oracle-exceptions java","title":"2.4.- Control de excepciones"},{"location":"ud2/24exceptions/#excepciones","text":"","title":"Excepciones"},{"location":"ud2/24exceptions/#jerarquia-de-excepciones-en-java","text":"La clase Throwable es la clase base incorporada que se usa para manejar todas las excepciones en Java. El tipo m\u00e1s gen\u00e9rico de excepci\u00f3n, java.lang.Exception, se encuentra en el paquete java.lang, pero la mayor\u00eda de sus subclases est\u00e1n contenidas en otros paquetes. Un programa a menudo encuentra problemas mientras se ejecuta. Puede tener problemas para leer datos, puede haber caracteres ilegales en los datos o un \u00edndice puede salirse de los l\u00edmites. La clase Java que gestiona estos problemas se llama Exception . La entrada y la salida son especialmente propensas a errores. El manejo de excepciones es esencial para la programaci\u00f3n de I/O. Por ejemplo, \u00bfqu\u00e9 ha ido mal en el siguiente programa?: Si hacemos un seguimiento a la pila de errores, vemos que el usuario insert\u00f3 \"hola\" y la clase Scanner, en concreto el m\u00e9todo nextInt no pudo convertir ese texto en un n\u00famero, por tanto, se lanz\u00f3 una excepci\u00f3n. Eso no significa que el programa est\u00e9 mal, simplemente el fallo est\u00e1 en los datos. Cuando nextInt encuentra el problema lanza la excepci\u00f3n InputMismatchException . La ejecuci\u00f3n del programa Java detecta la excepci\u00f3n y detiene el programa imprimiendo los mensajes de error. Es muy importante leer bien la pila de errores en la consola cuando se lanza una excepci\u00f3n para encontrar el fallo.","title":"Jerarqu\u00eda de excepciones en Java"},{"location":"ud2/24exceptions/#que-es-un-error","text":"Un error indica que se ha producido un fallo no recuperable, del que no se puede recuperar la ejecuci\u00f3n normal del programa. Un error est\u00e1 representado por un objeto de clase Error . La clase Throwable tiene dos subclases: Exception y Error . Un m\u00e9todo Java puede \"lanzar\" un objeto de clase Throwable. Por ejemplo, Scanner lanz\u00f3 una excepci\u00f3n cuando intent\u00f3 convertir \"hola\" en un n\u00famero entero. Las excepciones son diferentes de los errores porque los programas se pueden escribir para recuperarse de las excepciones, pero los programas no se pueden escribir para recuperarse de los errores.","title":"\u00bfQu\u00e9 es un error?"},{"location":"ud2/24exceptions/#que-es-una-excepcion","text":"Una excepci\u00f3n es un problema que ocurre cuando se ejecuta un programa. Cuando ocurre una excepci\u00f3n, la m\u00e1quina virtual Java crea un objeto de clase Exception que contiene informaci\u00f3n sobre el problema. Cuando se lanza una excepci\u00f3n, se puede capturar la excepci\u00f3n para recuperarse del programa.","title":"\u00bfQu\u00e9 es una excepci\u00f3n?"},{"location":"ud2/24exceptions/#bloques-try-catch","text":"Para capturar una excepci\u00f3n realizamos los siguientes pasos: Colocar el c\u00f3digo que pueda lanzar una excepci\u00f3n dentro de un bloque try. Colocar el c\u00f3digo que maneja la excepci\u00f3n dentro de un bloque catch (captura). El bloque catch debe seguir inmediatamente al bloque try. Cada bloque catch es un manejador de excepciones que maneja el tipo de excepci\u00f3n indicado por su argumento. El tipo de argumento, ExceptionType, declara el tipo de excepci\u00f3n que el controlador puede manejar y debe ser el nombre de una clase que hereda de la clase Throwable. El siguiente ejemplo arroja dentro del bloque try una InputMismatchException, el bloque catch comienza a ejecutarse inmediatamente. Se omiten las sentencias restantes en el bloque try. Scanner sc = new Scanner ( System . in ); int numero ; System . out . println ( \"Introduzca un entero:\" ); try { numero = sc . nextInt (); } catch ( InputMismatchException e ) { System . out . println ( \"No has introducido un n\u00famero.\" ); e . printStackTrace (); } System . out . println ( \"Sigue ejecut\u00e1ndose el programa\" ); El par\u00e1metro dentro de catch e se refiere al objeto de excepci\u00f3n que se lanza. Si queremos mostrar la pila de errores que genera el error usamos el m\u00e9todo e.printStackTrace(); Despu\u00e9s de ejecutar el bloque catch, la ejecuci\u00f3n contin\u00faa con la instrucci\u00f3n que sigue al bloque catch. La ejecuci\u00f3n no vuelve al bloque try .","title":"Bloques try -  catch"},{"location":"ud2/24exceptions/#como-se-ejecuta-un-try-catch-paso-por-paso","text":"Cuando se lanza una excepci\u00f3n dentro de un bloque try, el controlador de excepciones examina la excepci\u00f3n dentro de los bloques catch. Los bloques catch se examinan uno a uno empezando por el primero. El primer bloque catch que encaja con la excepci\u00f3n obtiene el control. Aunque haya muchas excepciones que encajen solo se ejecuta un bloque catch. Si ning\u00fan bloque catch encaja con la excepci\u00f3n lanzada se muestra la pila de errores y se termina la ejecuci\u00f3n del programa ya que no se ha manejado la excepci\u00f3n. Las clases m\u00e1s especificas deben ir primero seguidas de las m\u00e1s generales. Despu\u00e9s de ejecutar la \u00faltima instrucci\u00f3n dentro del catch el control del programa vuelve a la siguiente l\u00ednea fuera del try-catch (o finally si hubiera).","title":"C\u00f3mo se ejecuta un try-catch paso por paso"},{"location":"ud2/24exceptions/#capturar-mas-de-una-excepcion-en-un-solo-catch","text":"En Java SE 7 y posteriores, un solo bloque catch puede manejar m\u00e1s de un tipo de excepci\u00f3n. Esta funci\u00f3n puede reducir la duplicaci\u00f3n de c\u00f3digo. En la cl\u00e1usula catch, se especifican los tipos de excepciones que puede manejar el bloque y se separa cada tipo de excepci\u00f3n con una barra vertical (|): catch ( IOException | SQLException ex ) { //realizar acciones } Note Si un bloque catch maneja m\u00e1s de un tipo de excepci\u00f3n, el par\u00e1metro catch es impl\u00edcitamente final. En este ejemplo, la variable catch ex es final y, por lo tanto, no puede asignarle ning\u00fan valor dentro del bloque catch.","title":"Capturar m\u00e1s de una excepci\u00f3n en un solo catch"},{"location":"ud2/24exceptions/#sentencia-throw","text":"Utilizando la palabra reservada throw podemos lanzar nosotros expl\u00edcitamente una excepci\u00f3n. Podemos construir una instancia de la excepci\u00f3n que queremos lanzar y a\u00f1adirle un mensaje en el constructor. Ejemplo: try { System . out . print ( \"Inserta el numerador: \" ); num = scan . nextInt (); System . out . print ( \"Inserta el denominador: \" ); div = scan . nextInt (); if ( div == 0 ) throw new ArithmeticException ( \"Error al intentar dividir entre cero\" ); .... } catch ( ArithmeticException ex ) { System . out . println ( \"No se puede dividir \" + num + \" entre \" + div ); System . out . println ( ex . getMessage ()); }","title":"Sentencia throw"},{"location":"ud2/24exceptions/#bloque-finally","text":"El bloque finally siempre se ejecuta cuando sale del bloque try-catch incluso si ocurre una excepci\u00f3n inesperada. Estructura: try { //c\u00f3digo } catch () { //c\u00f3digo } finally { //siempre se ejecuta } Solo puede haber un bloque finally, y debe estar despu\u00e9s de los bloques catch. Si el bloque try sale normalmente (no ocurrieron excepciones), entonces el control va directamente al bloque finally. Si el bloque try sale debido a una excepci\u00f3n que es manejada por un bloque catch, primero ese bloque se ejecuta y luego el control va al bloque finally. Si el bloque try sale debido a una excepci\u00f3n que NO es manejada por un bloque catch, el control va directamente al bloque finally. Despu\u00e9s de que se ejecuta el bloque finally, se lanza la excepci\u00f3n a la persona que llama y el control vuelve a la persona que llama. En resumen: si el control entra en un bloque try, siempre entrar\u00e1 en el bloque finally. Importante El bloque finally es una herramienta clave para prevenir fugas de recursos. Al cerrar un archivo o recuperar recursos, coloque el c\u00f3digo en un bloque final para asegurarse de que el recurso siempre se recupere.","title":"Bloque finally"},{"location":"ud2/24exceptions/#sentencia-try-with-resources","text":"Pr\u00f3ximamente. Tip M\u00e1s informaci\u00f3n en oracle-exceptions java","title":"Sentencia try-with-resources"},{"location":"ud2/25fallos/","text":"Prueba y depuraci\u00f3n de aplicaciones Todo IDE ofrece un conjunto de herramientas para hacer debug. El debug permite supervisar la ejecuci\u00f3n de los programas, para localizar y eliminar los errores de programaci\u00f3n. Es necesario que un programa compile para poder depurarlo. Permite suspender la ejecuci\u00f3n de un programa, examinar y establecer los valores de las variables, comprobar los valores devueltos por un determinado m\u00e9todo, el resultado de una comparaci\u00f3n l\u00f3gica o relacional, etc... Debug en IntelliJ Run --> Debug Breakpoint / Punto de ruptura Permite detener un programa en una l\u00ednea/parte determinada. 1) Click sobre el n\u00famero de l\u00ednea o CTRL + F8 Una vez se detiene el programa podemos: 1) Analizar el valor de cualquier variable/propiedad 2) Analizar el valor de una expresi\u00f3n. 3) Ejecutar l\u00ednea a l\u00ednea y comprobar el flujo de la aplicaci\u00f3n. Tras realizar la comprobaci\u00f3n, se puede: 1) Detener el programa. 2) O continuar su ejecuci\u00f3n hasta el final. Tipos de ejecuci\u00f3n Primero hemos de lanzar el Debug (ALT + SHIFT + F9) Step Over (F8) / Paso a paso: Step Into (F7) / Paso a paso entrando en el m\u00e9todo/procedimiento Resume (F9) / Continuar Step Out (SHIFT + F8) / Ejecuci\u00f3n de un programa hasta el final Examinador de variables En cualquier momento podemos inspeccionar el valor y tipo de una variable Si queremos evaluar esas variables m\u00e1s de una vez, es mejor crear un \u201cWatchpoint\u201d sobre ellas Bot\u00f3n derecho + Add to Watches o pesta\u00f1a variables Proceso de depuraci\u00f3n 1) Localizar el problema 2) Poner un breakpoint en la l\u00ednea del error o en la entrada a la llamada \u25cf Poner watchpoint sobre los datos m\u00e1s sensibles 3) Lanzar el Debug y utilizar Step Over o Step Into. En cada paso, evaluar el contenido de las variables o expresiones fijadas. 4) Una vez localizado el error, detener el debug. Cambiar c\u00f3digo en caliente Al detener un programa mediante un breakpoint, podemos modificar el valor de cualquier variable y ver c\u00f3mo act\u00faa nuestro c\u00f3digo. Pesta\u00f1a Variables \u2192 campo bot\u00f3n derecho \u2192 set value...","title":"2.5.- Prueba y depuraci\u00f3n de aplicaciones"},{"location":"ud2/25fallos/#prueba-y-depuracion-de-aplicaciones","text":"Todo IDE ofrece un conjunto de herramientas para hacer debug. El debug permite supervisar la ejecuci\u00f3n de los programas, para localizar y eliminar los errores de programaci\u00f3n. Es necesario que un programa compile para poder depurarlo. Permite suspender la ejecuci\u00f3n de un programa, examinar y establecer los valores de las variables, comprobar los valores devueltos por un determinado m\u00e9todo, el resultado de una comparaci\u00f3n l\u00f3gica o relacional, etc...","title":"Prueba y depuraci\u00f3n de aplicaciones"},{"location":"ud2/25fallos/#debug-en-intellij","text":"Run --> Debug","title":"Debug en IntelliJ"},{"location":"ud2/25fallos/#breakpoint-punto-de-ruptura","text":"Permite detener un programa en una l\u00ednea/parte determinada. 1) Click sobre el n\u00famero de l\u00ednea o CTRL + F8 Una vez se detiene el programa podemos: 1) Analizar el valor de cualquier variable/propiedad 2) Analizar el valor de una expresi\u00f3n. 3) Ejecutar l\u00ednea a l\u00ednea y comprobar el flujo de la aplicaci\u00f3n. Tras realizar la comprobaci\u00f3n, se puede: 1) Detener el programa. 2) O continuar su ejecuci\u00f3n hasta el final.","title":"Breakpoint / Punto de ruptura"},{"location":"ud2/25fallos/#tipos-de-ejecucion","text":"Primero hemos de lanzar el Debug (ALT + SHIFT + F9) Step Over (F8) / Paso a paso: Step Into (F7) / Paso a paso entrando en el m\u00e9todo/procedimiento Resume (F9) / Continuar Step Out (SHIFT + F8) / Ejecuci\u00f3n de un programa hasta el final","title":"Tipos de ejecuci\u00f3n"},{"location":"ud2/25fallos/#examinador-de-variables","text":"En cualquier momento podemos inspeccionar el valor y tipo de una variable Si queremos evaluar esas variables m\u00e1s de una vez, es mejor crear un \u201cWatchpoint\u201d sobre ellas Bot\u00f3n derecho + Add to Watches o pesta\u00f1a variables","title":"Examinador de variables"},{"location":"ud2/25fallos/#proceso-de-depuracion","text":"1) Localizar el problema 2) Poner un breakpoint en la l\u00ednea del error o en la entrada a la llamada \u25cf Poner watchpoint sobre los datos m\u00e1s sensibles 3) Lanzar el Debug y utilizar Step Over o Step Into. En cada paso, evaluar el contenido de las variables o expresiones fijadas. 4) Una vez localizado el error, detener el debug.","title":"Proceso de depuraci\u00f3n"},{"location":"ud2/25fallos/#cambiar-codigo-en-caliente","text":"Al detener un programa mediante un breakpoint, podemos modificar el valor de cualquier variable y ver c\u00f3mo act\u00faa nuestro c\u00f3digo. Pesta\u00f1a Variables \u2192 campo bot\u00f3n derecho \u2192 set value...","title":"Cambiar c\u00f3digo en caliente"},{"location":"ud2/26methods/","text":"Introducci\u00f3n a los m\u00e9todos en Java Los m\u00e9todos sirven para hacer nuestro c\u00f3digo m\u00e1s legible, m\u00e1s f\u00e1cil de mantener y sin c\u00f3digo duplicado. Todo el tiempo hemos estado usando un m\u00e9todo llamado main, dentro de \u00e9l se encuentran todas las sentencias que hemos ido ejecutando, ahora vamos a crear nuestros propios m\u00e9todos teniendo en cuenta: Los m\u00e9todos se alinean unos debajo de otros, no se puede insertar un m\u00e9todo dentro de otro m\u00e9todo, y adem\u00e1s deben estar dentro de la clase. Ejemplo public class Main { public static void main ( String [] args ) { boolean gameOver = true ; int puntuacion = 5000 ; int nivelCompletado = 5 ; int bonus = 10 ; int score = calcularPuntuacion ( gameOver , puntuacion , nivelCompletado , bonus ); System . out . println ( score ); //otra forma de hacerlo es pasarle directamente el valor de las variables score = calcularPuntuacion ( true , 1000 , 10 , 30 ); System . out . println ( score ); } public static int calcularPuntuacion ( boolean gameOver , int puntuacion , int nivelCompletado , int bonus ) { if ( gameOver ) { int puntuacionFinal = puntuacion + ( nivelCompletado * bonus ); puntuacionFinal += 100 ; return puntuacionFinal ; } else { return - 1 ; } } //OTRAS FORMAS M\u00c1S EFICIENTES DE CREAR EL M\u00c9TODO calcularPuntuaciones //1. M\u00e9todo m\u00e1s eficiente sin sentencia else public static int calcularPuntuacion ( boolean gameOver , int puntuacion , int nivelCompletado , int bonus ) { if ( gameOver ) { int puntuacionFinal = puntuacion + ( nivelCompletado * bonus ); puntuacionFinal += 100 ; return puntuacionFinal ; } return - 1 ; } //2. Otra forma de realizar el m\u00e9todo calcularPuntuacion sin utilizar dos sentencias de return ser\u00eda public static int calcularPuntuacion ( boolean gameOver , int puntuacion , int nivelCompletado , int bonus ) { int puntuacionFinal = - 1 ; if ( gameOver ) { int puntuacionFinal = puntuacion + ( nivelCompletado * bonus ); puntuacionFinal += 100 ; } return puntuacionFinal ; } }","title":"2.6.- Introducci\u00f3n a los m\u00e9todos en Java"},{"location":"ud2/26methods/#introduccion-a-los-metodos-en-java","text":"Los m\u00e9todos sirven para hacer nuestro c\u00f3digo m\u00e1s legible, m\u00e1s f\u00e1cil de mantener y sin c\u00f3digo duplicado. Todo el tiempo hemos estado usando un m\u00e9todo llamado main, dentro de \u00e9l se encuentran todas las sentencias que hemos ido ejecutando, ahora vamos a crear nuestros propios m\u00e9todos teniendo en cuenta: Los m\u00e9todos se alinean unos debajo de otros, no se puede insertar un m\u00e9todo dentro de otro m\u00e9todo, y adem\u00e1s deben estar dentro de la clase. Ejemplo public class Main { public static void main ( String [] args ) { boolean gameOver = true ; int puntuacion = 5000 ; int nivelCompletado = 5 ; int bonus = 10 ; int score = calcularPuntuacion ( gameOver , puntuacion , nivelCompletado , bonus ); System . out . println ( score ); //otra forma de hacerlo es pasarle directamente el valor de las variables score = calcularPuntuacion ( true , 1000 , 10 , 30 ); System . out . println ( score ); } public static int calcularPuntuacion ( boolean gameOver , int puntuacion , int nivelCompletado , int bonus ) { if ( gameOver ) { int puntuacionFinal = puntuacion + ( nivelCompletado * bonus ); puntuacionFinal += 100 ; return puntuacionFinal ; } else { return - 1 ; } } //OTRAS FORMAS M\u00c1S EFICIENTES DE CREAR EL M\u00c9TODO calcularPuntuaciones //1. M\u00e9todo m\u00e1s eficiente sin sentencia else public static int calcularPuntuacion ( boolean gameOver , int puntuacion , int nivelCompletado , int bonus ) { if ( gameOver ) { int puntuacionFinal = puntuacion + ( nivelCompletado * bonus ); puntuacionFinal += 100 ; return puntuacionFinal ; } return - 1 ; } //2. Otra forma de realizar el m\u00e9todo calcularPuntuacion sin utilizar dos sentencias de return ser\u00eda public static int calcularPuntuacion ( boolean gameOver , int puntuacion , int nivelCompletado , int bonus ) { int puntuacionFinal = - 1 ; if ( gameOver ) { int puntuacionFinal = puntuacion + ( nivelCompletado * bonus ); puntuacionFinal += 100 ; } return puntuacionFinal ; } }","title":"Introducci\u00f3n a los m\u00e9todos en Java"},{"location":"ud2/2switch/","text":"Sentencia SWITCH Otra estructura de selecci\u00f3n o alternativa para agregar a nuestro repertorio es la estructura switch . La expresi\u00f3n switch se eval\u00faa una vez. El valor de la expresi\u00f3n se compara con los valores de cada caso. Si hay una coincidencia, se ejecuta el bloque de c\u00f3digo asociado. Las palabras clave break y default son opcionales . Los casos (case) suelen ser literales que no var\u00edan, y a menudo se usan constantes o el tipo de dato enum. Es una forma abreviada de codificar la estructura de selecci\u00f3n m\u00faltiple que vimos en el cap\u00edtulo anterior. De forma que el siguiente c\u00f3digo expresado con if-else m\u00faltiple: if ( numJugadores == 1 ) { System . out . println ( \"Single player\" ); } else if ( numJugadores == 2 ) { System . out . println ( \"Two player\" ); } else if ( numJugadores == 3 ) { System . out . println ( \"Multiplayer\" ); } else { System . out . println ( \"Not possible, too many players\" ); } Es equivalente a: switch ( numJugadores ) { case 1 : System . out . println ( \"Single player\" ); break ; case 2 : System . out . println ( \"Two player\" ); break ; case 3 : System . out . println ( \"Multiplayer\" ); break ; default : System . out . println ( \"Not possible, too many players\" ); } BREAK Cuando el programa Java alcanza la palabra break, se sale del bloque switch. Es decir, ya no se sigue ejecutando m\u00e1s c\u00f3digo dentro del switch ni ning\u00fan case. Un break puede ahorrar mucho tiempo de ejecuci\u00f3n porque \"ignora\" la ejecuci\u00f3n de todo el resto del c\u00f3digo switch. DEFAULT La palabra default se usa para ejecutar c\u00f3digo cuando no hay ninguna coincidencia con ning\u00fan caso ( case ). Siempre se pone al final, por tanto no necesita de la instrucci\u00f3n break .","title":"Switch Statement"},{"location":"ud2/2switch/#sentencia-switch","text":"Otra estructura de selecci\u00f3n o alternativa para agregar a nuestro repertorio es la estructura switch . La expresi\u00f3n switch se eval\u00faa una vez. El valor de la expresi\u00f3n se compara con los valores de cada caso. Si hay una coincidencia, se ejecuta el bloque de c\u00f3digo asociado. Las palabras clave break y default son opcionales . Los casos (case) suelen ser literales que no var\u00edan, y a menudo se usan constantes o el tipo de dato enum. Es una forma abreviada de codificar la estructura de selecci\u00f3n m\u00faltiple que vimos en el cap\u00edtulo anterior. De forma que el siguiente c\u00f3digo expresado con if-else m\u00faltiple: if ( numJugadores == 1 ) { System . out . println ( \"Single player\" ); } else if ( numJugadores == 2 ) { System . out . println ( \"Two player\" ); } else if ( numJugadores == 3 ) { System . out . println ( \"Multiplayer\" ); } else { System . out . println ( \"Not possible, too many players\" ); } Es equivalente a: switch ( numJugadores ) { case 1 : System . out . println ( \"Single player\" ); break ; case 2 : System . out . println ( \"Two player\" ); break ; case 3 : System . out . println ( \"Multiplayer\" ); break ; default : System . out . println ( \"Not possible, too many players\" ); }","title":"Sentencia SWITCH"},{"location":"ud2/2switch/#break","text":"Cuando el programa Java alcanza la palabra break, se sale del bloque switch. Es decir, ya no se sigue ejecutando m\u00e1s c\u00f3digo dentro del switch ni ning\u00fan case. Un break puede ahorrar mucho tiempo de ejecuci\u00f3n porque \"ignora\" la ejecuci\u00f3n de todo el resto del c\u00f3digo switch.","title":"BREAK"},{"location":"ud2/2switch/#default","text":"La palabra default se usa para ejecutar c\u00f3digo cuando no hay ninguna coincidencia con ning\u00fan caso ( case ). Siempre se pone al final, por tanto no necesita de la instrucci\u00f3n break .","title":"DEFAULT"},{"location":"ud3/1metodoclase/","text":"Clases en Java Las clases es el componente fundamental en la POO. Para entender el concepto de clase, primero necesitamos entender que son los objetos ya que son la clave en la tecnolog\u00eda orientada a objetos. Objetos Los objetos de software son una parte fundamental de la programaci\u00f3n orientada a objetos. Son muy similares a los objetos que representan cosas del mundo real. Como puede ser un micr\u00f3fono, altavoz, ordenador, etc. Como ya estudiamos en la unidad 1, los objetos del mundo real tienen dos caracter\u00edsticas, estado y comportamiento . Estado - Campos Por ejemplo, para un ordenador, el estado podr\u00eda ser la cantidad de memoria RAM que tiene, el sistema operativo que incluye, tama\u00f1o del disco duro, etc. En el caso de una persona, el estado puede ser la edad, el nombre, si est\u00e1 casada, etc. Comportamiento - M\u00e9todos Atendiendo al comportamiento de un ordenador podr\u00eda ser arrancando, apag\u00e1ndose, reiniciando, escribir en la pantalla, etc. Para una persona ser\u00e1 comer, beber, dormir, etc. Los objetos de software almacenan su estado en campos . Los campos es lo que conocemos como variables. Y exponen su comportamiento en lo que llamamos m\u00e9todos . Clases Teniendo en cuenta todo esto, podemos pasar a hablar de clase . Una clase es una plantilla para crear objetos. Para crear un clase en Java utilizamos la palabra reservada class . La nomenclatura del nombre de la clase es primera letra en may\u00fasculas y usar la regla CamelCase para palabras compuestas. public class Coche { } public: es un modificador de acceso, determina qu\u00e9 acceso queremos permitir a otros en la clase. Existen tres tipos de modificadores de acceso: public: en este caso, public especifica que no hay ninguna restricci\u00f3n de acceso. private: nadie puede acceder a la clase. protected: permite a las clases de este paquete acceder. class: identificador de clase. \u00bfDe qu\u00e9 forma nos ayudan las clases en nuestro c\u00f3digo? Bien, hasta ahora solo hemos trabajado con tipos de datos primitivos como int, short, char, etc. Este tipo de datos es bastante limitado. Por tanto, las clases se podr\u00edan considerar como un tipo de dato extra poderoso definido por el usuario que nos permite realizar acciones en las que los datos primitivos se quedan cortos. Miembros de la clase : atributos y m\u00e9todos Atributos, campos de la clase o variables de instancia Hasta ahora hemos creado variables dentro de un m\u00e9todo. A \u00e9stas se les llama variables locales porque son propias del m\u00e9todo en si. Y no puedes acceder a ellas desde fuera de ese m\u00e9todo. Tambi\u00e9n vimos esto dentro de bloques de c\u00f3digo {}, donde las variables creadas en un bloque m\u00e1s interno no eran accesibles en bloques m\u00e1s externos. Ejemplo: public static void sumar () { int contador = 0 ; while ( contador < 10 ) { int suma = 0 ; suma += contador ; contador ++ ; } System . out . println ( suma ); // esto da error, la variable // suma aqu\u00ed no existe. } A diferencia de esto, las clases nos permiten crear variables que pueden ser accesibles desde cualquier lugar dentro de la clase que estamos creando. A estas variables se les conoce con el nombre de variables miembro/instancia , o de manera m\u00e1s com\u00fan como campos o atributos de la clase. Creaci\u00f3n de atributos de la clase Para crear un campo de la clase se debe especificar un modificador de acceso(opcional) + tipo de dato + nombre de la variable + inicializaci\u00f3n(opcional). Si no se pone modificador utiliza el de por defecto en el que la variable es accesible por las clases dentro del mismo paquete. El modificador de acceso funciona de la misma forma a como lo hemos explicado anteriormente para la creaci\u00f3n de una clase. public class Coche { private int puertas ; private int ruedas ; private String modelo ; private String color ; } Estamos definiendo el estado del coche, es decir, sus caracter\u00edsticas. Modificadores de acceso de atributos Un buen dise\u00f1o de software refuerza la encapsulaci\u00f3n. Aqu\u00ed es donde las variables de instancia de un objeto son visibles solo para los propios m\u00e9todos del objeto. El c\u00f3digo fuera del objeto no puede acceder directamente a estas variables. Se utiliza para hacer esto el modificador de visibilidad privada. Como regla general, cuando definimos campos para la clase el modificador de acceso ser\u00e1 privado . Es decir, usamos el concepto de encapsulaci\u00f3n que es una clave fundamental de la programaci\u00f3n orientada a objetos. Lo que hacemos es ocultar los campos de la clase del acceso p\u00fablico para que nadie pueda acceder y modificar los campos de la clase. Significa que la representaci\u00f3n del objeto se ocultar\u00e1 a la vista, es decir, el funcionamiento interno del objeto. Existen los siguientes tipos de modificadores, ordenados de menor a mayor restricci\u00f3n: public : son accesibles desde cualquier lugar. protected : son accesibles desde dentro del mismo paquete y en clases heredadas. private : solo son accesibles desde la propia clase, no son accesibles desde fuera. M\u00e9todos de instancia Para actualizar los campos de la clase, como su acceso es privado se utilizan los m\u00e9todos de instancia . Estos m\u00e9todos ya no van a ser public static como hemos visto hasta ahora. Para crear los m\u00e9todos que actualizan los campos debemos usar la siguiente nomenclatura: Setters: establecen el valor en el campo de la clase public void setNombreCampo( TipoDatoCampo nombreCampo ), donde el par\u00e1metro del m\u00e9todo debe ser del mismo tipo ya que vamos a actualizar su valor mediante el m\u00e9todo. Getters: devuelven el campo de la clase public tipoDatoCampo getNombreCampo() public class Coche { private int puertas ; private int ruedas ; private String modelo ; private String color ; public void setPuertas ( int puertas ) { this . puertas = puertas ; } public int getPuertas () { return this . puertas ; } public void setRuedas () { this . ruedas = ruedas ; } public int getRuedas () { return this . ruedas ; } public void setModelo ( String modelo ) { this . modelo = modelo ; } public String getModelo () { return this . modelo ; } public void setColor ( String color ) { this . color = color ; } public String getColor () { return this . color ; } } Palabra reservada this En un m\u00e9todo set como el nombre del par\u00e1metro del m\u00e9todo es igual al del campo de la clase, necesitamos algo que nos permita distinguir entre uno u otro. Para esto se utiliza la palabra reservada this que hace alusi\u00f3n al campo de la clase.","title":"3.1- Clases en Java"},{"location":"ud3/1metodoclase/#clases-en-java","text":"Las clases es el componente fundamental en la POO. Para entender el concepto de clase, primero necesitamos entender que son los objetos ya que son la clave en la tecnolog\u00eda orientada a objetos.","title":"Clases en Java"},{"location":"ud3/1metodoclase/#objetos","text":"Los objetos de software son una parte fundamental de la programaci\u00f3n orientada a objetos. Son muy similares a los objetos que representan cosas del mundo real. Como puede ser un micr\u00f3fono, altavoz, ordenador, etc. Como ya estudiamos en la unidad 1, los objetos del mundo real tienen dos caracter\u00edsticas, estado y comportamiento .","title":"Objetos"},{"location":"ud3/1metodoclase/#estado-campos","text":"Por ejemplo, para un ordenador, el estado podr\u00eda ser la cantidad de memoria RAM que tiene, el sistema operativo que incluye, tama\u00f1o del disco duro, etc. En el caso de una persona, el estado puede ser la edad, el nombre, si est\u00e1 casada, etc.","title":"Estado - Campos"},{"location":"ud3/1metodoclase/#comportamiento-metodos","text":"Atendiendo al comportamiento de un ordenador podr\u00eda ser arrancando, apag\u00e1ndose, reiniciando, escribir en la pantalla, etc. Para una persona ser\u00e1 comer, beber, dormir, etc. Los objetos de software almacenan su estado en campos . Los campos es lo que conocemos como variables. Y exponen su comportamiento en lo que llamamos m\u00e9todos .","title":"Comportamiento - M\u00e9todos"},{"location":"ud3/1metodoclase/#clases","text":"Teniendo en cuenta todo esto, podemos pasar a hablar de clase . Una clase es una plantilla para crear objetos. Para crear un clase en Java utilizamos la palabra reservada class . La nomenclatura del nombre de la clase es primera letra en may\u00fasculas y usar la regla CamelCase para palabras compuestas. public class Coche { } public: es un modificador de acceso, determina qu\u00e9 acceso queremos permitir a otros en la clase. Existen tres tipos de modificadores de acceso: public: en este caso, public especifica que no hay ninguna restricci\u00f3n de acceso. private: nadie puede acceder a la clase. protected: permite a las clases de este paquete acceder. class: identificador de clase. \u00bfDe qu\u00e9 forma nos ayudan las clases en nuestro c\u00f3digo? Bien, hasta ahora solo hemos trabajado con tipos de datos primitivos como int, short, char, etc. Este tipo de datos es bastante limitado. Por tanto, las clases se podr\u00edan considerar como un tipo de dato extra poderoso definido por el usuario que nos permite realizar acciones en las que los datos primitivos se quedan cortos.","title":"Clases"},{"location":"ud3/1metodoclase/#miembros-de-la-clase-atributos-y-metodos","text":"","title":"Miembros de la clase : atributos y m\u00e9todos"},{"location":"ud3/1metodoclase/#atributos-campos-de-la-clase-o-variables-de-instancia","text":"Hasta ahora hemos creado variables dentro de un m\u00e9todo. A \u00e9stas se les llama variables locales porque son propias del m\u00e9todo en si. Y no puedes acceder a ellas desde fuera de ese m\u00e9todo. Tambi\u00e9n vimos esto dentro de bloques de c\u00f3digo {}, donde las variables creadas en un bloque m\u00e1s interno no eran accesibles en bloques m\u00e1s externos. Ejemplo: public static void sumar () { int contador = 0 ; while ( contador < 10 ) { int suma = 0 ; suma += contador ; contador ++ ; } System . out . println ( suma ); // esto da error, la variable // suma aqu\u00ed no existe. } A diferencia de esto, las clases nos permiten crear variables que pueden ser accesibles desde cualquier lugar dentro de la clase que estamos creando. A estas variables se les conoce con el nombre de variables miembro/instancia , o de manera m\u00e1s com\u00fan como campos o atributos de la clase.","title":"Atributos, campos de la clase o variables de instancia"},{"location":"ud3/1metodoclase/#creacion-de-atributos-de-la-clase","text":"Para crear un campo de la clase se debe especificar un modificador de acceso(opcional) + tipo de dato + nombre de la variable + inicializaci\u00f3n(opcional). Si no se pone modificador utiliza el de por defecto en el que la variable es accesible por las clases dentro del mismo paquete. El modificador de acceso funciona de la misma forma a como lo hemos explicado anteriormente para la creaci\u00f3n de una clase. public class Coche { private int puertas ; private int ruedas ; private String modelo ; private String color ; } Estamos definiendo el estado del coche, es decir, sus caracter\u00edsticas.","title":"Creaci\u00f3n de atributos de la clase"},{"location":"ud3/1metodoclase/#modificadores-de-acceso-de-atributos","text":"Un buen dise\u00f1o de software refuerza la encapsulaci\u00f3n. Aqu\u00ed es donde las variables de instancia de un objeto son visibles solo para los propios m\u00e9todos del objeto. El c\u00f3digo fuera del objeto no puede acceder directamente a estas variables. Se utiliza para hacer esto el modificador de visibilidad privada. Como regla general, cuando definimos campos para la clase el modificador de acceso ser\u00e1 privado . Es decir, usamos el concepto de encapsulaci\u00f3n que es una clave fundamental de la programaci\u00f3n orientada a objetos. Lo que hacemos es ocultar los campos de la clase del acceso p\u00fablico para que nadie pueda acceder y modificar los campos de la clase. Significa que la representaci\u00f3n del objeto se ocultar\u00e1 a la vista, es decir, el funcionamiento interno del objeto. Existen los siguientes tipos de modificadores, ordenados de menor a mayor restricci\u00f3n: public : son accesibles desde cualquier lugar. protected : son accesibles desde dentro del mismo paquete y en clases heredadas. private : solo son accesibles desde la propia clase, no son accesibles desde fuera.","title":"Modificadores de acceso de atributos"},{"location":"ud3/1metodoclase/#metodos-de-instancia","text":"Para actualizar los campos de la clase, como su acceso es privado se utilizan los m\u00e9todos de instancia . Estos m\u00e9todos ya no van a ser public static como hemos visto hasta ahora. Para crear los m\u00e9todos que actualizan los campos debemos usar la siguiente nomenclatura: Setters: establecen el valor en el campo de la clase public void setNombreCampo( TipoDatoCampo nombreCampo ), donde el par\u00e1metro del m\u00e9todo debe ser del mismo tipo ya que vamos a actualizar su valor mediante el m\u00e9todo. Getters: devuelven el campo de la clase public tipoDatoCampo getNombreCampo() public class Coche { private int puertas ; private int ruedas ; private String modelo ; private String color ; public void setPuertas ( int puertas ) { this . puertas = puertas ; } public int getPuertas () { return this . puertas ; } public void setRuedas () { this . ruedas = ruedas ; } public int getRuedas () { return this . ruedas ; } public void setModelo ( String modelo ) { this . modelo = modelo ; } public String getModelo () { return this . modelo ; } public void setColor ( String color ) { this . color = color ; } public String getColor () { return this . color ; } }","title":"M\u00e9todos de instancia"},{"location":"ud3/1metodoclase/#palabra-reservada-this","text":"En un m\u00e9todo set como el nombre del par\u00e1metro del m\u00e9todo es igual al del campo de la clase, necesitamos algo que nos permita distinguir entre uno u otro. Para esto se utiliza la palabra reservada this que hace alusi\u00f3n al campo de la clase.","title":"Palabra reservada this"},{"location":"ud3/2constructor/","text":"Creaci\u00f3n e inicializaci\u00f3n de objetos de la clase Para crear objetos de la clase, podemos hacerlo de dos formas: Creando un variable de la clase como hemos hecho hasta ahora: Coche seat ; //(Aqu\u00ed la variable no est\u00e1 inicializada y // puede dar errores de compilaci\u00f3n). Utilizando la palabra resevada new m\u00e1s el nombre de la clase: Coche seat = new Coche (); //En este caso la variable es creada e inicializada Constructor Cuando usamos la palabra new Coche(); para crear un objeto de la clase Coche, en realidad estamos usando lo que se conoce como el constructor de la clase para crear el coche. El constructor por normal general da valor a los campos de la clase. Constructor por defecto En Java cuando creamos un objeto con la sentencia new Coche(), se lanza el llamado contructor por defecto. Si no se ha definido este en la clase, Java lo crea y lo lanza autom\u00e1ticamente e iniciliza los campos de la clase con valores por defecto. Si queremos definirlo nosotros tenemos que usar public m\u00e1s el nombre de la clase. public class Coche { private int puertas ; private String modelo ; private String color ; //Constructor por defecto public Coche () { } //getters y setters } Constructor parametrizado Un constructor parametrizado tiene uno o m\u00e1s par\u00e1metros. Podemos usar un constructor parametrizado en caso de que necesitemos pasar algunos valores iniciales a la variable miembro de la clase. public Coche ( int puertas , String color ) { this . puertas = puertas ; this . color = color ; } Constructor sobrecargado Ahora surge la pregunta de si una clase puede tener m\u00e1s de un constructor o si una clase solo puede tener un constructor. Podemos tener varios constructores en una clase. Los constructores pueden ser sobrecargados al igual que los m\u00e9todos, es decir, podemos tener m\u00e1s de un constructor en nuestra clase siempre que cambiemos el n\u00famero de par\u00e1metros. Por ejemplo: public Coche ( String modelo ) { this . modelo = modelo ; } public Coche ( int puertas , String color ) { this . puertas = puertas ; this . color = color ; } public Coche ( int puertas , String modelo , String color ) { this . puertas = puertas ; this . color = color ; this . modelo = modelo ; } Estos ser\u00edan dos constructores diferentes para el objeto Coche, donde en uno se construye usando el modelo y en el otro el n\u00famero de puertas. A estos constructores tambi\u00e9n se les conoce como constructor parametrizado. Warning Si se define un constructor con par\u00e1metros en la clase, Java entiende que la clase tiene una forma de construirse y no crear\u00e1 de forma autom\u00e1tica el constructor por defecto Coche(). Por tanto si tenemos c\u00f3digo como Coche coche = new Coche(); nos lanzar\u00e1 un error de compilaci\u00f3n. Llamar a un constructor desde otro dentro de la misma clase Hemos comentado que podemos tener m\u00e1s de un constructor en nuestra clase gracias a la sobrecarga. En corcondancia con esto, tambi\u00e9n podemos llamar a un constructor desde otro constructor. Por ejemplo, el constructor por defecto es llamado cuando hacemos new Coche(); pero dentro de este constructor no se inicializa ning\u00fan campo, y tal vez nosotros queramos crear el objeto con algunos valores predeterminados. Entonces llamar\u00edamos desde dentro del constructor por defecto a un constructor parametrizado. public Coche () { this ( 5 , \"blanco\" ); //invoco al constructor con 2 par\u00e1metros } public Coche ( int puertas , String color ) { this ( puertas , \"desconocido\" , color ); //invoco al constructor con 3 par\u00e1metros } public Coche ( int puertas , String modelo , String color ) { this . puertas = puertas ; this . color = color ; this . modelo = modelo ; } En el c\u00f3digo anterior, cada vez que creamos un coche vac\u00edo, le asignamos por defecto 5 puertas y color blanco como valores predeterminados. Con esto te aseguras que el objeto se crea con todos los campos inicializados. Constructor copia en Java El constructor copia es un tipo de constructor que recibe como par\u00e1metro un objeto de la misma clase. Es decir, en este caso estamos creando objetos de tipo coche, por lo que el constructor recibir\u00e1 por par\u00e1metro un objeto de este tipo. Veamos entonces un ejemplo donde se muestra este tipo de constructor: public class Coche { private int puertas ; private String modelo ; private String color ; //Constructor copia public Coche ( Coche objCoche ) { this . puertas = objCoche . puertas ; this . color = objCoche . color ; this . modelo = objCoche . modelo ; } } Destructor En algunos lenguajes de programaci\u00f3n, para destruir un objeto, existen varios m\u00e9todos o funciones que se ejecutan de forma autom\u00e1tica para destruirlo. Esta funci\u00f3n no devuelve ning\u00fan valor, (por lo tanto es de tipo void), y no recibe ning\u00fan par\u00e1metro. Por otro lado, es importante destacar que en java no existen destructores . Java es un lenguaje que posee un recolector de basura (garbage collector). Este recolector de basura, ejecuta autom\u00e1ticamente un m\u00e9todo llamado finalize() . Por lo tanto, cuando un programa java ya no est\u00e1 utilizando un objeto se realizan dos acciones: Por un lado entra en acci\u00f3n de forma autom\u00e1tica el garbage collector. Este recolector de basura llama al m\u00e9todo finalize() y lo ejecuta. Para finalizar, se destruye el objeto y se liberan los recursos utilizados en la memoria RAM del ordenador. Por \u00faltimo, debes conocer tambi\u00e9n a grandes rasgos que es la clase Object. Clase Object en java Tambi\u00e9n es llamada como clase c\u00f3smica, ya que la clase Object, es la clase que est\u00e1 por encima de todas las clases de la api de java. Esto quiere decir que todas las clases de java que vienen predefinidas en el lenguaje de programaci\u00f3n, como las que nosotros construimos, heredan de la clase object. Por eso cuando creamos un objeto, viene ya definido con ciertos m\u00e9todos que se han heredado de la clsae Object.","title":"3.2- Constructores y destructores"},{"location":"ud3/2constructor/#creacion-e-inicializacion-de-objetos-de-la-clase","text":"Para crear objetos de la clase, podemos hacerlo de dos formas: Creando un variable de la clase como hemos hecho hasta ahora: Coche seat ; //(Aqu\u00ed la variable no est\u00e1 inicializada y // puede dar errores de compilaci\u00f3n). Utilizando la palabra resevada new m\u00e1s el nombre de la clase: Coche seat = new Coche (); //En este caso la variable es creada e inicializada","title":"Creaci\u00f3n e inicializaci\u00f3n de objetos de la clase"},{"location":"ud3/2constructor/#constructor","text":"Cuando usamos la palabra new Coche(); para crear un objeto de la clase Coche, en realidad estamos usando lo que se conoce como el constructor de la clase para crear el coche. El constructor por normal general da valor a los campos de la clase.","title":"Constructor"},{"location":"ud3/2constructor/#constructor-por-defecto","text":"En Java cuando creamos un objeto con la sentencia new Coche(), se lanza el llamado contructor por defecto. Si no se ha definido este en la clase, Java lo crea y lo lanza autom\u00e1ticamente e iniciliza los campos de la clase con valores por defecto. Si queremos definirlo nosotros tenemos que usar public m\u00e1s el nombre de la clase. public class Coche { private int puertas ; private String modelo ; private String color ; //Constructor por defecto public Coche () { } //getters y setters }","title":"Constructor por defecto"},{"location":"ud3/2constructor/#constructor-parametrizado","text":"Un constructor parametrizado tiene uno o m\u00e1s par\u00e1metros. Podemos usar un constructor parametrizado en caso de que necesitemos pasar algunos valores iniciales a la variable miembro de la clase. public Coche ( int puertas , String color ) { this . puertas = puertas ; this . color = color ; }","title":"Constructor parametrizado"},{"location":"ud3/2constructor/#constructor-sobrecargado","text":"Ahora surge la pregunta de si una clase puede tener m\u00e1s de un constructor o si una clase solo puede tener un constructor. Podemos tener varios constructores en una clase. Los constructores pueden ser sobrecargados al igual que los m\u00e9todos, es decir, podemos tener m\u00e1s de un constructor en nuestra clase siempre que cambiemos el n\u00famero de par\u00e1metros. Por ejemplo: public Coche ( String modelo ) { this . modelo = modelo ; } public Coche ( int puertas , String color ) { this . puertas = puertas ; this . color = color ; } public Coche ( int puertas , String modelo , String color ) { this . puertas = puertas ; this . color = color ; this . modelo = modelo ; } Estos ser\u00edan dos constructores diferentes para el objeto Coche, donde en uno se construye usando el modelo y en el otro el n\u00famero de puertas. A estos constructores tambi\u00e9n se les conoce como constructor parametrizado. Warning Si se define un constructor con par\u00e1metros en la clase, Java entiende que la clase tiene una forma de construirse y no crear\u00e1 de forma autom\u00e1tica el constructor por defecto Coche(). Por tanto si tenemos c\u00f3digo como Coche coche = new Coche(); nos lanzar\u00e1 un error de compilaci\u00f3n.","title":"Constructor sobrecargado"},{"location":"ud3/2constructor/#llamar-a-un-constructor-desde-otro-dentro-de-la-misma-clase","text":"Hemos comentado que podemos tener m\u00e1s de un constructor en nuestra clase gracias a la sobrecarga. En corcondancia con esto, tambi\u00e9n podemos llamar a un constructor desde otro constructor. Por ejemplo, el constructor por defecto es llamado cuando hacemos new Coche(); pero dentro de este constructor no se inicializa ning\u00fan campo, y tal vez nosotros queramos crear el objeto con algunos valores predeterminados. Entonces llamar\u00edamos desde dentro del constructor por defecto a un constructor parametrizado. public Coche () { this ( 5 , \"blanco\" ); //invoco al constructor con 2 par\u00e1metros } public Coche ( int puertas , String color ) { this ( puertas , \"desconocido\" , color ); //invoco al constructor con 3 par\u00e1metros } public Coche ( int puertas , String modelo , String color ) { this . puertas = puertas ; this . color = color ; this . modelo = modelo ; } En el c\u00f3digo anterior, cada vez que creamos un coche vac\u00edo, le asignamos por defecto 5 puertas y color blanco como valores predeterminados. Con esto te aseguras que el objeto se crea con todos los campos inicializados.","title":"Llamar a un constructor desde otro dentro de la misma clase"},{"location":"ud3/2constructor/#constructor-copia-en-java","text":"El constructor copia es un tipo de constructor que recibe como par\u00e1metro un objeto de la misma clase. Es decir, en este caso estamos creando objetos de tipo coche, por lo que el constructor recibir\u00e1 por par\u00e1metro un objeto de este tipo. Veamos entonces un ejemplo donde se muestra este tipo de constructor: public class Coche { private int puertas ; private String modelo ; private String color ; //Constructor copia public Coche ( Coche objCoche ) { this . puertas = objCoche . puertas ; this . color = objCoche . color ; this . modelo = objCoche . modelo ; } }","title":"Constructor copia en Java"},{"location":"ud3/2constructor/#destructor","text":"En algunos lenguajes de programaci\u00f3n, para destruir un objeto, existen varios m\u00e9todos o funciones que se ejecutan de forma autom\u00e1tica para destruirlo. Esta funci\u00f3n no devuelve ning\u00fan valor, (por lo tanto es de tipo void), y no recibe ning\u00fan par\u00e1metro. Por otro lado, es importante destacar que en java no existen destructores . Java es un lenguaje que posee un recolector de basura (garbage collector). Este recolector de basura, ejecuta autom\u00e1ticamente un m\u00e9todo llamado finalize() . Por lo tanto, cuando un programa java ya no est\u00e1 utilizando un objeto se realizan dos acciones: Por un lado entra en acci\u00f3n de forma autom\u00e1tica el garbage collector. Este recolector de basura llama al m\u00e9todo finalize() y lo ejecuta. Para finalizar, se destruye el objeto y se liberan los recursos utilizados en la memoria RAM del ordenador. Por \u00faltimo, debes conocer tambi\u00e9n a grandes rasgos que es la clase Object.","title":"Destructor"},{"location":"ud3/2constructor/#clase-object-en-java","text":"Tambi\u00e9n es llamada como clase c\u00f3smica, ya que la clase Object, es la clase que est\u00e1 por encima de todas las clases de la api de java. Esto quiere decir que todas las clases de java que vienen predefinidas en el lenguaje de programaci\u00f3n, como las que nosotros construimos, heredan de la clase object. Por eso cuando creamos un objeto, viene ya definido con ciertos m\u00e9todos que se han heredado de la clsae Object.","title":"Clase Object en java"},{"location":"ud3/3sobrecargametodos/","text":"M\u00e9todos y sobrecarga de m\u00e9todos En el punto 2.6 del curso vimos una introducci\u00f3n a los m\u00e9todos, qu\u00e9 son, c\u00f3mo definirlos y sus partes. En los siguientes puntos vamos estudiar conceptos relacionados con los m\u00e9todos. Sobrecarga de m\u00e9todos La sobrecarga de m\u00e9todos es una caracter\u00edstica que nos permite tener m\u00e1s de un m\u00e9todo con el mismo nombre , siempre que usemos diferentes par\u00e1metros. Es la capacidad de crear m\u00faltiples m\u00e9todos con el mismo nombre pero diferentes implementaciones Esto tambi\u00e9n se aplica a los constructores como ya hemos visto, ten\u00edamos m\u00e1s de un constructor con el mismo nombre pero diferente n\u00famero de argumentos. No hay l\u00edmite en la cantidad de sobrecarga que se puede hacer al dise\u00f1ar constructores y m\u00e9todos, la \u00fanica restricci\u00f3n es que cada m\u00e9todo debe tener una signature distinta con el mismo nombre. La signature(firma) de un m\u00e9todo consta del nombre del m\u00e9todo, m\u00e1s el n\u00famero, los tipos y el orden de sus par\u00e1metros formales. Una clase no puede contener dos m\u00e9todos con la misma signature. \u00c1mbito de variables locales y argumentos El estado de un objeto consta de los datos que contiene en sus variables de instancia(campos o atributos). Las variables de instancia mantienen sus valores hasta que se cambian expl\u00edcitamente o hasta que se destruye el objeto. Los m\u00e9todos de un objeto suelen trabajar con otros valores que no se mantienen en las variables de instancia. Estos valores se mantienen en variables y par\u00e1metros locales. En el ejemplo de la clase Cuenta.java ten\u00edamos: public class Cuenta { private double balance ; ... public void ingresar ( double cantidad ) { this . balance = this . balance + cantidad ; System . out . println ( \"Balance actual \" + this . balance ); } } La persona que llama al m\u00e9todo ingresar utiliza el par\u00e1metro cantidad para enviar un valor al m\u00e9todo. A esto se le llama pasar un valor al m\u00e9todo . Desde el m\u00e9todo main() llamamos al m\u00e9todo ingresar que usa el par\u00e1metro para pasar un valor al m\u00e9todo: public static void main ( String [] args ) { Cuenta patriCuenta = new Cuenta ( \"1234567\" , 0.0 , \"Patricia\" ); c . ingresar ( 50 ); } Cuando se ejecuta al m\u00e9todo ingresar(50) , al par\u00e1metro cantidad se le da el valor 50, luego se ejecuta el interior del m\u00e9todo, y el valor se suma a la variable de instancia o campo balance. El m\u00e9todo termina y el control vuelve al m\u00e9todo main(), pero el balance del objeto patriCuenta ha cambiado. Las variables de instancia se utilizan para almacenar el estado de un objeto. Mantienen los valores mientras exista el objeto. Si intent\u00e1ramos usar la variable cantidad en otro m\u00e9todo, nos dar\u00eda error de compilaci\u00f3n, puesto que esa variable no existe fuera del m\u00e9todo ingresar , es lo que se conoce como una variable local . Podr\u00edamos tener otro m\u00e9todo que definiera o usara otra variable llamada cantidad . public class Cuenta { private double balance ; ... public void ingresar ( double cantidad ) { this . balance = this . balance + cantidad ; System . out . println ( \"Balance actual \" + this . balance ); } public void retirar ( double cantidad ) { this . balance = this . balance - cantidad ; } } En el m\u00e9todo retirar la variable cantidad es una variable diferente a la que usamos en el m\u00e9todo ingresar , aunque tengan el mismo nombre ya que est\u00e1n en \u00e1mbitos diferentes, no pueden verse entre ellas.","title":"3.3- M\u00e9todos y sobrecarga de m\u00e9todos"},{"location":"ud3/3sobrecargametodos/#metodos-y-sobrecarga-de-metodos","text":"En el punto 2.6 del curso vimos una introducci\u00f3n a los m\u00e9todos, qu\u00e9 son, c\u00f3mo definirlos y sus partes. En los siguientes puntos vamos estudiar conceptos relacionados con los m\u00e9todos.","title":"M\u00e9todos y sobrecarga de m\u00e9todos"},{"location":"ud3/3sobrecargametodos/#sobrecarga-de-metodos","text":"La sobrecarga de m\u00e9todos es una caracter\u00edstica que nos permite tener m\u00e1s de un m\u00e9todo con el mismo nombre , siempre que usemos diferentes par\u00e1metros. Es la capacidad de crear m\u00faltiples m\u00e9todos con el mismo nombre pero diferentes implementaciones Esto tambi\u00e9n se aplica a los constructores como ya hemos visto, ten\u00edamos m\u00e1s de un constructor con el mismo nombre pero diferente n\u00famero de argumentos. No hay l\u00edmite en la cantidad de sobrecarga que se puede hacer al dise\u00f1ar constructores y m\u00e9todos, la \u00fanica restricci\u00f3n es que cada m\u00e9todo debe tener una signature distinta con el mismo nombre. La signature(firma) de un m\u00e9todo consta del nombre del m\u00e9todo, m\u00e1s el n\u00famero, los tipos y el orden de sus par\u00e1metros formales. Una clase no puede contener dos m\u00e9todos con la misma signature.","title":"Sobrecarga de m\u00e9todos"},{"location":"ud3/3sobrecargametodos/#ambito-de-variables-locales-y-argumentos","text":"El estado de un objeto consta de los datos que contiene en sus variables de instancia(campos o atributos). Las variables de instancia mantienen sus valores hasta que se cambian expl\u00edcitamente o hasta que se destruye el objeto. Los m\u00e9todos de un objeto suelen trabajar con otros valores que no se mantienen en las variables de instancia. Estos valores se mantienen en variables y par\u00e1metros locales. En el ejemplo de la clase Cuenta.java ten\u00edamos: public class Cuenta { private double balance ; ... public void ingresar ( double cantidad ) { this . balance = this . balance + cantidad ; System . out . println ( \"Balance actual \" + this . balance ); } } La persona que llama al m\u00e9todo ingresar utiliza el par\u00e1metro cantidad para enviar un valor al m\u00e9todo. A esto se le llama pasar un valor al m\u00e9todo . Desde el m\u00e9todo main() llamamos al m\u00e9todo ingresar que usa el par\u00e1metro para pasar un valor al m\u00e9todo: public static void main ( String [] args ) { Cuenta patriCuenta = new Cuenta ( \"1234567\" , 0.0 , \"Patricia\" ); c . ingresar ( 50 ); } Cuando se ejecuta al m\u00e9todo ingresar(50) , al par\u00e1metro cantidad se le da el valor 50, luego se ejecuta el interior del m\u00e9todo, y el valor se suma a la variable de instancia o campo balance. El m\u00e9todo termina y el control vuelve al m\u00e9todo main(), pero el balance del objeto patriCuenta ha cambiado. Las variables de instancia se utilizan para almacenar el estado de un objeto. Mantienen los valores mientras exista el objeto. Si intent\u00e1ramos usar la variable cantidad en otro m\u00e9todo, nos dar\u00eda error de compilaci\u00f3n, puesto que esa variable no existe fuera del m\u00e9todo ingresar , es lo que se conoce como una variable local . Podr\u00edamos tener otro m\u00e9todo que definiera o usara otra variable llamada cantidad . public class Cuenta { private double balance ; ... public void ingresar ( double cantidad ) { this . balance = this . balance + cantidad ; System . out . println ( \"Balance actual \" + this . balance ); } public void retirar ( double cantidad ) { this . balance = this . balance - cantidad ; } } En el m\u00e9todo retirar la variable cantidad es una variable diferente a la que usamos en el m\u00e9todo ingresar , aunque tengan el mismo nombre ya que est\u00e1n en \u00e1mbitos diferentes, no pueden verse entre ellas.","title":"\u00c1mbito de variables locales y argumentos"},{"location":"ud3/4referencevalue/","text":"Paso de argumentos por valor y referencia Argumentos paso por valor Un par\u00e1metro es un \"mensaje unidireccional\" que la persona que llama usa para enviar valores a un m\u00e9todo. Dentro del cuerpo de un m\u00e9todo, un par\u00e1metro se usa como cualquier variable. Se puede utilizar en expresiones aritm\u00e9ticas, en sentencias de asignaci\u00f3n, etc. Sin embargo, los cambios realizados en el par\u00e1metro no tienen ning\u00fan efecto fuera del cuerpo del m\u00e9todo. Un par\u00e1metro es una copia local de cualquier valor que la persona que llama haya pasado al m\u00e9todo. Cualquier cambio realizado afectar\u00e1 solo a esta copia local. Esto ocurre cuando se pasa una dato de tipo primitivo. Por ejemplo: ------ Clase Cuenta public void cambiarCantidad ( double cantidad ) { cantidad -= 20 ; } ------------------ Clase Main public static void main () { Cuenta cuenta = new Cuenta ( \"Pepe\" , \"pepe@gmail.com\" , \"873463774\" ); int cantidad = 50 ; cuenta . ingresar ( cantidad ); System . out . println ( cantidad ); //imprime 50 cuenta . cambiarCantidad ( cantidad ); System . out . println ( cantidad ); //imprime 50 } cantidad es el nombre de la variable para el valor 50 que se ha enviado al m\u00e9todo cambiarCantidad(). Ese m\u00e9todo cambia el valor de la cantidad, pero esto no tiene ning\u00fan efecto sobre ninguna otra variable fuera del m\u00e9todo. Cuando el m\u00e9todo regresa a su llamador (main), el valor del par\u00e1metro cantidad se olvida. Una variable local es una variable que se declara dentro del cuerpo de un m\u00e9todo. El alcance de una variable local comienza desde donde se declara y termina al final del bloque en el que se encuentra. Recuerde que un bloque es un grupo de declaraciones entre llaves, {}. As\u00ed es como funciona el paso de par\u00e1metros por valor: Cuando la persona invoca un m\u00e9todo, es persona proporciona una lista de valores (los par\u00e1metros) en la lista de par\u00e1metros del m\u00e9todo. Cuando el m\u00e9todo invocado comienza a ejecutarse, estos valores se copian en los par\u00e1metros formales o argumentos. El m\u00e9todo invocado utiliza los par\u00e1metros formales para acceder a estos valores copiados. Cualquier cambio que realice el m\u00e9todo en el valor contenido en un par\u00e1metro formal cambia solo esa copia. El m\u00e9todo invocado no puede utilizar un par\u00e1metro formal para enviar un valor a la persona que ha invocado el m\u00e9todo. Como hemos visto un cambio en un par\u00e1metro dentro del m\u00e9todo no afecta a ninguna variable desde donde se invoc\u00f3. Entonces, \u00bfc\u00f3mo puede un m\u00e9todo enviar un valor a la persona que lo invoca? Para devolver un valor \u00fanico a la persona que invoca, un m\u00e9todo invocado puede utilizar la declaraci\u00f3n de retorno return junto con el valor que se devolver\u00e1. Paso por referencia Las referencias a objetos o variable de referencia pueden ser par\u00e1metros. Esto sigue siendo una llamada por valor, pero ahora el valor es una referencia de objeto. Esta referencia se puede utilizar para acceder al objeto y posiblemente cambiarlo. public class Test { public static void ingresarCienEuros ( Cuenta cuenta ) { System . out . println ( \"El balance es \" + cuenta . getBalance ()); cuenta . ingresar ( 100 ); System . out . println ( \"El balance es \" + cuenta . getBalance ()); } public static void main ( String [] args ) { Cuenta c = new Cuenta (); System . out . println ( \"El balance es \" + cuenta . getBalance ()); ingresarCienEuros ( c ); System . out . println ( \"El balance es \" + cuenta . getBalance ()); } } Las variables de instancia p\u00fablica de los objetos se pueden cambiar mediante cualquier m\u00e9todo que tenga una referencia al objeto. Como se ha hecho en el ejemplo anterior en la variable de instancia balance . Resumen Un par\u00e1metro formal es una variable en una declaraci\u00f3n de m\u00e9todo. Siempre consta de un tipo seguido de un identificador de variable. Un argumento es un valor que se pasa a un m\u00e9todo a trav\u00e9s de un par\u00e1metro formal cuando se invoca el m\u00e9todo. Los par\u00e1metros de un m\u00e9todo limitan el tipo de informaci\u00f3n que se puede pasar a un m\u00e9todo. El paso de par\u00e1metros siempre se realiza por valor. Si el par\u00e1metro de un m\u00e9todo es un tipo de datos primitivo, el m\u00e9todo puede cambiar el valor contenido en su par\u00e1metro, pero ese cambio no tiene ning\u00fan efecto en otros lugares. Sin embargo, si el par\u00e1metro de un m\u00e9todo es una referencia a un objeto, el m\u00e9todo puede usar la referencia para acceder al objeto y luego cambiar las variables de instancia del objeto (a menos que sean privadas o en un paquete diferente). Por supuesto, incluso si un m\u00e9todo tiene una referencia a un objeto, el objeto se puede cambiar solo si el objeto permite que se realicen cambios.","title":"3.4- Paso de par\u00e1metros por valor y referencia"},{"location":"ud3/4referencevalue/#paso-de-argumentos-por-valor-y-referencia","text":"","title":"Paso de argumentos por valor y referencia"},{"location":"ud3/4referencevalue/#argumentos-paso-por-valor","text":"Un par\u00e1metro es un \"mensaje unidireccional\" que la persona que llama usa para enviar valores a un m\u00e9todo. Dentro del cuerpo de un m\u00e9todo, un par\u00e1metro se usa como cualquier variable. Se puede utilizar en expresiones aritm\u00e9ticas, en sentencias de asignaci\u00f3n, etc. Sin embargo, los cambios realizados en el par\u00e1metro no tienen ning\u00fan efecto fuera del cuerpo del m\u00e9todo. Un par\u00e1metro es una copia local de cualquier valor que la persona que llama haya pasado al m\u00e9todo. Cualquier cambio realizado afectar\u00e1 solo a esta copia local. Esto ocurre cuando se pasa una dato de tipo primitivo. Por ejemplo: ------ Clase Cuenta public void cambiarCantidad ( double cantidad ) { cantidad -= 20 ; } ------------------ Clase Main public static void main () { Cuenta cuenta = new Cuenta ( \"Pepe\" , \"pepe@gmail.com\" , \"873463774\" ); int cantidad = 50 ; cuenta . ingresar ( cantidad ); System . out . println ( cantidad ); //imprime 50 cuenta . cambiarCantidad ( cantidad ); System . out . println ( cantidad ); //imprime 50 } cantidad es el nombre de la variable para el valor 50 que se ha enviado al m\u00e9todo cambiarCantidad(). Ese m\u00e9todo cambia el valor de la cantidad, pero esto no tiene ning\u00fan efecto sobre ninguna otra variable fuera del m\u00e9todo. Cuando el m\u00e9todo regresa a su llamador (main), el valor del par\u00e1metro cantidad se olvida. Una variable local es una variable que se declara dentro del cuerpo de un m\u00e9todo. El alcance de una variable local comienza desde donde se declara y termina al final del bloque en el que se encuentra. Recuerde que un bloque es un grupo de declaraciones entre llaves, {}. As\u00ed es como funciona el paso de par\u00e1metros por valor: Cuando la persona invoca un m\u00e9todo, es persona proporciona una lista de valores (los par\u00e1metros) en la lista de par\u00e1metros del m\u00e9todo. Cuando el m\u00e9todo invocado comienza a ejecutarse, estos valores se copian en los par\u00e1metros formales o argumentos. El m\u00e9todo invocado utiliza los par\u00e1metros formales para acceder a estos valores copiados. Cualquier cambio que realice el m\u00e9todo en el valor contenido en un par\u00e1metro formal cambia solo esa copia. El m\u00e9todo invocado no puede utilizar un par\u00e1metro formal para enviar un valor a la persona que ha invocado el m\u00e9todo. Como hemos visto un cambio en un par\u00e1metro dentro del m\u00e9todo no afecta a ninguna variable desde donde se invoc\u00f3. Entonces, \u00bfc\u00f3mo puede un m\u00e9todo enviar un valor a la persona que lo invoca? Para devolver un valor \u00fanico a la persona que invoca, un m\u00e9todo invocado puede utilizar la declaraci\u00f3n de retorno return junto con el valor que se devolver\u00e1.","title":"Argumentos paso por valor"},{"location":"ud3/4referencevalue/#paso-por-referencia","text":"Las referencias a objetos o variable de referencia pueden ser par\u00e1metros. Esto sigue siendo una llamada por valor, pero ahora el valor es una referencia de objeto. Esta referencia se puede utilizar para acceder al objeto y posiblemente cambiarlo. public class Test { public static void ingresarCienEuros ( Cuenta cuenta ) { System . out . println ( \"El balance es \" + cuenta . getBalance ()); cuenta . ingresar ( 100 ); System . out . println ( \"El balance es \" + cuenta . getBalance ()); } public static void main ( String [] args ) { Cuenta c = new Cuenta (); System . out . println ( \"El balance es \" + cuenta . getBalance ()); ingresarCienEuros ( c ); System . out . println ( \"El balance es \" + cuenta . getBalance ()); } } Las variables de instancia p\u00fablica de los objetos se pueden cambiar mediante cualquier m\u00e9todo que tenga una referencia al objeto. Como se ha hecho en el ejemplo anterior en la variable de instancia balance .","title":"Paso por referencia"},{"location":"ud3/4referencevalue/#resumen","text":"Un par\u00e1metro formal es una variable en una declaraci\u00f3n de m\u00e9todo. Siempre consta de un tipo seguido de un identificador de variable. Un argumento es un valor que se pasa a un m\u00e9todo a trav\u00e9s de un par\u00e1metro formal cuando se invoca el m\u00e9todo. Los par\u00e1metros de un m\u00e9todo limitan el tipo de informaci\u00f3n que se puede pasar a un m\u00e9todo. El paso de par\u00e1metros siempre se realiza por valor. Si el par\u00e1metro de un m\u00e9todo es un tipo de datos primitivo, el m\u00e9todo puede cambiar el valor contenido en su par\u00e1metro, pero ese cambio no tiene ning\u00fan efecto en otros lugares. Sin embargo, si el par\u00e1metro de un m\u00e9todo es una referencia a un objeto, el m\u00e9todo puede usar la referencia para acceder al objeto y luego cambiar las variables de instancia del objeto (a menos que sean privadas o en un paquete diferente). Por supuesto, incluso si un m\u00e9todo tiene una referencia a un objeto, el objeto se puede cambiar solo si el objeto permite que se realicen cambios.","title":"Resumen"},{"location":"ud3/5static/","text":"Variables, m\u00e9todos y clases est\u00e1ticas Una clase, m\u00e9todo o campo declarado como est\u00e1tico puede ser accedido o invocado sin la necesidad de tener que instanciar un objeto de la clase. Para entender mejor que son las variables y m\u00e9todos est\u00e1ticos vamos a ver las diferencias de cada uno de ellos con variables y m\u00e9todos de instancia. Variables est\u00e1ticas Si una variable se declara est\u00e1tica, hay exactamente una copia de esa variable creada sin importar cu\u00e1ntas veces se instancia su clase. Se declaran usando la palabra reservada static . Cada instancia de la clase comparte la misma variable est\u00e1tica , por lo que si se realizan cambios en esa variable est\u00e1tica todas las dem\u00e1s instancias de esa clase ver\u00e1 el efecto de ese cambio. No se usan muy amenudo. class Persona { private static String name ; public Persona ( String name ) { Persona . name = name ; } public void printName () { System . out . println ( name ); } } public class Main { public static void main ( String [] args ) { Persona p1 = new Persona ( \"Patricia\" ); Persona p2 = new Persona ( \"Maxi\" ); p1 . printName (); //imprime Maxi p2 . printName (); //imprime Maxi } } Variables constantes est\u00e1ticas Tambi\u00e9n se puede declarar un variable constante (final) como est\u00e1tica, esto significa que solo habr\u00e1 una copia de la constante aunque hayan muchas instancias de esa clase. Son tambi\u00e9n llamadas constantes de clase : private static final int NUMERO_JUGADORES = 2 ; No todas las constantes son constantes de clase. Es decir, no todas las constantes se declaran est\u00e1ticas. Sin embargo, la idea de asociar constantes con una clase tiene sentido. Ya que te permite ahorrar recursos de memoria, al crear una \u00fanica copia de la constante. Otra ventaja de las constantes de clase es que se pueden usar antes de que existan instancias de la clase. Por ejemplo, una constante de clase (a diferencia de una constante de instancia) se puede usar durante la instanciaci\u00f3n de objetos: public class Game { public static final int MULTIPLAYER = 2 ; public static final int ONE_PLAYER = 1 ; private int numeroJugadores ; public Game ( int jugadores ) { this . numeroJugadores = jugadores ; } public static void main ( String [] args ) { Game game = new Game ( Game . MULTIPLAYER ); } } Variables de instancia Las variables de instancia tambi\u00e9n son conocidas como campos o atributos. Las variables de instancia pertenecen a una instancia de la clase . Cada instancia tiene su propia copia de una variable de instancia, as\u00ed que cada instancia puede tener un valor(estado) diferente. Las variables de instancia representan el estado de una instancia . class Persona { private String name ; public Persona ( String name ) { this . name = name ; } public void printName () { System . out . println ( name ); } } public class Main { public static void main ( String [] args ) { Persona p1 = new Persona ( \"Patricia\" ); Persona p2 = new Persona ( \"Maxi\" ); p1 . printName (); //imprime Patricia p2 . printName (); //imprime Maxi } } M\u00e9todos est\u00e1ticos Los m\u00e9todos est\u00e1ticos son declarados usando el modificador static . No se puede acceder desde los m\u00e9todos est\u00e1ticos a m\u00e9todos de instancia o variables de instancia directamente. Para invocar a un m\u00e9todo est\u00e1tico se utiliza el nombre de la clase + \".\" + el nombre del m\u00e9todo, o solamente el nombre del m\u00e9todo si est\u00e1 en la misma clase.(VEASE EJEMPLO) Normalmente se usan para operaciones que no requieren ning\u00fan dato de instancia de la clase, es decir, nada que venga de this. Dentro de un m\u00e9todo est\u00e1tico no podemos usar la palabra this . Cada vez que veas un m\u00e9todo que no utilice variables de instancia , significa que ese m\u00e9todo deber\u00eda declararse como est\u00e1tico. Por ejemplo, el main es declarado como est\u00e1tico y es llamado por la JVM cuando se lanza la aplicaci\u00f3n. public class Calculadora { public static void printSuma ( int a , int b ) { System . out . println ( a + b ); } } public class Main { public static void main ( String [] args ) { Calculadora . printSuma ( 5 , 6 ); printHolaMundo (); } public static void printHolaMundo () { System . out . println ( \"Hola mundo.\" ); } } M\u00e9todos de instancia Los m\u00e9todos de instancia pertenecen a una instancia espec\u00edfica de la clase. Para usar un m\u00e9todo de instancia tenemos que instanciar un objeto de la clase primero, normalmente utilizando la palabra resevada new . Los m\u00e9todos de instancia pueden acceder a otros m\u00e9todos de instancia y variables de instancia directamente. Los m\u00e9todos de instancia pueden tambi\u00e9n acceder a m\u00e9todos est\u00e1ticos y variables est\u00e1ticas . \u00bfM\u00e9todo est\u00e1tico o m\u00e9todo de instancia? Cuando voy a crear un m\u00e9todo y tengo dudas sobre si crearlo est\u00e1tico o de instancia debo seguir la siguiente l\u00f3gica: \u00bfEl m\u00e9todo usa alg\u00fan campo o variable de instancia o invoca en su interior a alg\u00fan m\u00e9todo de instancia? SI --> Entonces deber\u00eda crear un m\u00e9todo de instancia. NO --> Deber\u00eda crear un m\u00e9todo est\u00e1tico. Clases est\u00e1ticas En el lenguaje Java, no podemos crear una clase externa como una clase est\u00e1tica, pero existe el privilegio de crear una clase interna anidada como una clase est\u00e1tica. Una clase interna est\u00e1tica nunca puede acceder a un miembro no est\u00e1tico de la clase externa. Una clase interna est\u00e1tica no necesita ninguna referencia de clase externa para acceder a las variables miembro. La clase est\u00e1tica nunca se puede instanciar. Por lo tanto, los m\u00e9todos son directamente accesibles por el nombre de la clase. public class Estatica { static int i = 1 ; int j = 9 ; public static void main ( String [] args ) { Estatica s = new Estatica (); //s.ClaseInterna.printNum(); NO ES CORRECTO //Estatica.ClaseInterna.printNum(); SI se podr\u00eda hacer ClaseInterna . printNum (); } public static class ClaseInterna { public static void printNum () { System . out . println ( i ); //System.out.println(j); //NO PODEMOS ACCEDER A ATRIBUTOS NO EST\u00c1TICOS } } } Bloques est\u00e1ticos Es posible declarar bloques de c\u00f3digo como est\u00e1ticos, de tal manera que sean ejecutados cuando se cargue la clase. Este tipo de bloques se conocen como bloques de inicializaci\u00f3n est\u00e1ticos (static initializer block). Si no se declara un bloque de este tipo de forma expl\u00edcita, el compilador Just-in-Time combina todos los campos est\u00e1ticos en un bloque y los ejecuta durante la carga de clases. public class Objeto { private static int campo1 ; static { campo1 = 10 ; } } Imports est\u00e1ticos Una de las caracter\u00edsticas incluidas en Java 5 fu\u00e9 la capacidad de importar los m\u00e9todos y variables est\u00e1ticas de un m\u00f3dulo y acceder a ellos como si hubieran sido declarados en la propia clase. Es especialmente \u00fatil, y mejora la legibilidad, cuando se est\u00e1n definiendo test unitarios, ya que la mayor\u00eda de los m\u00e9todos de aserci\u00f3n de JUnit son est\u00e1ticos. import static java.lang.Math.PI ; public static void main ( String [] args ) { double a = PI ; }","title":"3.5- Variables, m\u00e9todos y clases est\u00e1ticas"},{"location":"ud3/5static/#variables-metodos-y-clases-estaticas","text":"Una clase, m\u00e9todo o campo declarado como est\u00e1tico puede ser accedido o invocado sin la necesidad de tener que instanciar un objeto de la clase. Para entender mejor que son las variables y m\u00e9todos est\u00e1ticos vamos a ver las diferencias de cada uno de ellos con variables y m\u00e9todos de instancia.","title":"Variables, m\u00e9todos y clases est\u00e1ticas"},{"location":"ud3/5static/#variables-estaticas","text":"Si una variable se declara est\u00e1tica, hay exactamente una copia de esa variable creada sin importar cu\u00e1ntas veces se instancia su clase. Se declaran usando la palabra reservada static . Cada instancia de la clase comparte la misma variable est\u00e1tica , por lo que si se realizan cambios en esa variable est\u00e1tica todas las dem\u00e1s instancias de esa clase ver\u00e1 el efecto de ese cambio. No se usan muy amenudo. class Persona { private static String name ; public Persona ( String name ) { Persona . name = name ; } public void printName () { System . out . println ( name ); } } public class Main { public static void main ( String [] args ) { Persona p1 = new Persona ( \"Patricia\" ); Persona p2 = new Persona ( \"Maxi\" ); p1 . printName (); //imprime Maxi p2 . printName (); //imprime Maxi } }","title":"Variables est\u00e1ticas"},{"location":"ud3/5static/#variables-constantes-estaticas","text":"Tambi\u00e9n se puede declarar un variable constante (final) como est\u00e1tica, esto significa que solo habr\u00e1 una copia de la constante aunque hayan muchas instancias de esa clase. Son tambi\u00e9n llamadas constantes de clase : private static final int NUMERO_JUGADORES = 2 ; No todas las constantes son constantes de clase. Es decir, no todas las constantes se declaran est\u00e1ticas. Sin embargo, la idea de asociar constantes con una clase tiene sentido. Ya que te permite ahorrar recursos de memoria, al crear una \u00fanica copia de la constante. Otra ventaja de las constantes de clase es que se pueden usar antes de que existan instancias de la clase. Por ejemplo, una constante de clase (a diferencia de una constante de instancia) se puede usar durante la instanciaci\u00f3n de objetos: public class Game { public static final int MULTIPLAYER = 2 ; public static final int ONE_PLAYER = 1 ; private int numeroJugadores ; public Game ( int jugadores ) { this . numeroJugadores = jugadores ; } public static void main ( String [] args ) { Game game = new Game ( Game . MULTIPLAYER ); } }","title":"Variables constantes est\u00e1ticas"},{"location":"ud3/5static/#variables-de-instancia","text":"Las variables de instancia tambi\u00e9n son conocidas como campos o atributos. Las variables de instancia pertenecen a una instancia de la clase . Cada instancia tiene su propia copia de una variable de instancia, as\u00ed que cada instancia puede tener un valor(estado) diferente. Las variables de instancia representan el estado de una instancia . class Persona { private String name ; public Persona ( String name ) { this . name = name ; } public void printName () { System . out . println ( name ); } } public class Main { public static void main ( String [] args ) { Persona p1 = new Persona ( \"Patricia\" ); Persona p2 = new Persona ( \"Maxi\" ); p1 . printName (); //imprime Patricia p2 . printName (); //imprime Maxi } }","title":"Variables de instancia"},{"location":"ud3/5static/#metodos-estaticos","text":"Los m\u00e9todos est\u00e1ticos son declarados usando el modificador static . No se puede acceder desde los m\u00e9todos est\u00e1ticos a m\u00e9todos de instancia o variables de instancia directamente. Para invocar a un m\u00e9todo est\u00e1tico se utiliza el nombre de la clase + \".\" + el nombre del m\u00e9todo, o solamente el nombre del m\u00e9todo si est\u00e1 en la misma clase.(VEASE EJEMPLO) Normalmente se usan para operaciones que no requieren ning\u00fan dato de instancia de la clase, es decir, nada que venga de this. Dentro de un m\u00e9todo est\u00e1tico no podemos usar la palabra this . Cada vez que veas un m\u00e9todo que no utilice variables de instancia , significa que ese m\u00e9todo deber\u00eda declararse como est\u00e1tico. Por ejemplo, el main es declarado como est\u00e1tico y es llamado por la JVM cuando se lanza la aplicaci\u00f3n. public class Calculadora { public static void printSuma ( int a , int b ) { System . out . println ( a + b ); } } public class Main { public static void main ( String [] args ) { Calculadora . printSuma ( 5 , 6 ); printHolaMundo (); } public static void printHolaMundo () { System . out . println ( \"Hola mundo.\" ); } }","title":"M\u00e9todos est\u00e1ticos"},{"location":"ud3/5static/#metodos-de-instancia","text":"Los m\u00e9todos de instancia pertenecen a una instancia espec\u00edfica de la clase. Para usar un m\u00e9todo de instancia tenemos que instanciar un objeto de la clase primero, normalmente utilizando la palabra resevada new . Los m\u00e9todos de instancia pueden acceder a otros m\u00e9todos de instancia y variables de instancia directamente. Los m\u00e9todos de instancia pueden tambi\u00e9n acceder a m\u00e9todos est\u00e1ticos y variables est\u00e1ticas .","title":"M\u00e9todos de instancia"},{"location":"ud3/5static/#metodo-estatico-o-metodo-de-instancia","text":"Cuando voy a crear un m\u00e9todo y tengo dudas sobre si crearlo est\u00e1tico o de instancia debo seguir la siguiente l\u00f3gica: \u00bfEl m\u00e9todo usa alg\u00fan campo o variable de instancia o invoca en su interior a alg\u00fan m\u00e9todo de instancia? SI --> Entonces deber\u00eda crear un m\u00e9todo de instancia. NO --> Deber\u00eda crear un m\u00e9todo est\u00e1tico.","title":"\u00bfM\u00e9todo est\u00e1tico o m\u00e9todo de instancia?"},{"location":"ud3/5static/#clases-estaticas","text":"En el lenguaje Java, no podemos crear una clase externa como una clase est\u00e1tica, pero existe el privilegio de crear una clase interna anidada como una clase est\u00e1tica. Una clase interna est\u00e1tica nunca puede acceder a un miembro no est\u00e1tico de la clase externa. Una clase interna est\u00e1tica no necesita ninguna referencia de clase externa para acceder a las variables miembro. La clase est\u00e1tica nunca se puede instanciar. Por lo tanto, los m\u00e9todos son directamente accesibles por el nombre de la clase. public class Estatica { static int i = 1 ; int j = 9 ; public static void main ( String [] args ) { Estatica s = new Estatica (); //s.ClaseInterna.printNum(); NO ES CORRECTO //Estatica.ClaseInterna.printNum(); SI se podr\u00eda hacer ClaseInterna . printNum (); } public static class ClaseInterna { public static void printNum () { System . out . println ( i ); //System.out.println(j); //NO PODEMOS ACCEDER A ATRIBUTOS NO EST\u00c1TICOS } } }","title":"Clases est\u00e1ticas"},{"location":"ud3/5static/#bloques-estaticos","text":"Es posible declarar bloques de c\u00f3digo como est\u00e1ticos, de tal manera que sean ejecutados cuando se cargue la clase. Este tipo de bloques se conocen como bloques de inicializaci\u00f3n est\u00e1ticos (static initializer block). Si no se declara un bloque de este tipo de forma expl\u00edcita, el compilador Just-in-Time combina todos los campos est\u00e1ticos en un bloque y los ejecuta durante la carga de clases. public class Objeto { private static int campo1 ; static { campo1 = 10 ; } }","title":"Bloques est\u00e1ticos"},{"location":"ud3/5static/#imports-estaticos","text":"Una de las caracter\u00edsticas incluidas en Java 5 fu\u00e9 la capacidad de importar los m\u00e9todos y variables est\u00e1ticas de un m\u00f3dulo y acceder a ellos como si hubieran sido declarados en la propia clase. Es especialmente \u00fatil, y mejora la legibilidad, cuando se est\u00e1n definiendo test unitarios, ya que la mayor\u00eda de los m\u00e9todos de aserci\u00f3n de JUnit son est\u00e1ticos. import static java.lang.Math.PI ; public static void main ( String [] args ) { double a = PI ; }","title":"Imports est\u00e1ticos"},{"location":"ud3/6recursion/","text":"Recursividad Un m\u00e9todo recursivo es un m\u00e9todo que se llama a s\u00ed mismo . Un m\u00e9todo iterativo es un m\u00e9todo que usa un bucle para repetir una acci\u00f3n. En cierto sentido, la recursividad es una alternativa a las estructuras de control iterativas (en bucle). Por ejemplo, tenemos el siguiente m\u00e9todo iterativo: public void hola ( int n ) { for ( int k = 0 ; k < n ; k ++ ) { System . out . println ( \"Hola\" ); } } Una versi\u00f3n recursiva de ese m\u00e9todo ser\u00eda: public void hola ( int n ) { if ( n > 0 ) { System . out . println ( \"Hola\" ); hola ( n \u2212 1 ); //Llamada recursiva } } Este m\u00e9todo es recursivo porque se llama a s\u00ed mismo cuando n es mayor que 0. Sin embargo, ten en cuenta que cuando se llama a s\u00ed mismo, pasa n - 1 como el valor de su par\u00e1metro. Si este m\u00e9todo se llama inicialmente con n igual a 5, lo siguiente es una pila de lo que sucede. Las indentaciones indican cada vez que el m\u00e9todo se llama a s\u00ed mismo: hola(5) imprime \"Hola\" hola(4) imprime \"Hola\" hola(3) imprime \"Hola\" hola(2) imprime \"Hola\" hola(1) imprime \"Hola\" hola(0) En el ejemplo anterior, es mucho menos eficiente llamar a un m\u00e9todo cinco veces que repetir un bucle for cinco veces. Las llamadas a m\u00e9todos ocupan m\u00e1s memoria que los bucles e implican m\u00e1s sobrecarga computacional, en tareas como pasar par\u00e1metros, asignar almacenamiento para las variables locales del m\u00e9todo y devolver los resultados del m\u00e9todo. Note Los algoritmos y m\u00e9todos iterativos son generalmente m\u00e1s eficientes que los algoritmos recursivos que hacen lo mismo. Recursividad como un enfoque de resoluci\u00f3n de problemas Dado que la recursividad no es realmente necesaria, si un lenguaje de programaci\u00f3n tiene bucles, y no es m\u00e1s eficiente que los bucles, \u00bfpor qu\u00e9 es tan importante? Porque la recursividad es un enfoque eficaz para la resoluci\u00f3n de problemas. Es una forma de ver un problema. La recursividad se basa en dos conceptos clave de resoluci\u00f3n de problemas: divide y vencer\u00e1s y auto-similaridad. En la resoluci\u00f3n de problemas recursivos, utilizamos la estrategia de divide y vencer\u00e1s repetidamente para dividir un gran problema en una secuencia de problemas cada vez m\u00e1s peque\u00f1os hasta que llegamos a un problema que es pr\u00e1cticamente trivial de resolver. Lo que nos permite crear esta serie de subproblemas es que cada subproblema es similar al problema original, es decir, cada subproblema es solo una versi\u00f3n m\u00e1s peque\u00f1a del problema original. La capacidad de ver un problema, por uno compuesto por problemas m\u00e1s peque\u00f1os y similares es el n\u00facleo del enfoque recursivo. Parte recursiva y caso base Una definici\u00f3n recursiva consta de dos partes: una parte recursiva que se repite y reduce el problema en una versi\u00f3n m\u00e1s peque\u00f1a del problema original, y un caso base o l\u00edmite no recursivo, que define una condici\u00f3n l\u00edmite y se utiliza para detener la recursividad. Veamos esto con un ejemplo: EJEMPLO 1: Factorial: N! Recordamos como se hac\u00eda el c\u00e1lculo de n!: n! = n * (n-1) * n(n-2) * .... mientras n > 0 Adem\u00e1s, 0! se define como 1. Ejemplos: 4! = 4 * 3 * 2 * 1 = 24 3! = 3 * 2 * 1 = 6 1! = 1 0! = 1 Como vemos en el ejemplo, podemos deducir que el factorial se repite en t\u00e9rminos de (n-1) y el \u00fanico caso donde no se calcula el factorial es 0!, esto nos lleva a que: n! = 1 --> if n = 0 //caso base n! = n * (n-1) --> if n > 0 //caso recursivo De forma que el factorial de un n\u00famero quedar\u00eda codificado de la siguiente forma: public static int factorial ( int n ) { if ( n <= 0 ) { return 1 ; } else { return n * factorial ( n - 1 ); } } Traza factorial(4) 4 * factorial(3) 3 * factorial(2) 2 * factorial(1) 1 * factorial(0) return 1 return 1 * 1 --> 1 return 2 * 1 --> 2 return 3 * 2 --> 6 return 4 * 6 --> 24 return 24 EJEMPLO 2: Verificar si un n\u00famero es pal\u00edndromo Un n\u00famero es pal\u00edndromo si al leerse en ambos sentidos, tanto de izquierda a derecha como de derecha a izquierda, se obtiene el mismo n\u00famero. Por ejemplo: 121, 1001, etc. public static int revertir ( int n , int reverso ) { if ( n > 0 ) { int ud = n % 10 ; reverso = reverso * 10 ; return revertir ( n / 10 , ud + reverso ); } else { return reverso ; } } public static void main ( String [] args ) { int reverso = revertir ( 121 , 0 ); if ( reverso == n ) System . out . println ( \"Son pal\u00edndromos.\" ); else System . out . println ( \"No lo son\" ); } EJEMPLO 3: Revertir un String Para revertir un String, nos quedamos con el primer car\u00e1cter que iremos a\u00f1adiendo al final de la recursividad, y vamos acortando el String para llegar al caso base. public static String reverseRecursive ( String str ) { if ( str . isEmpty ()) { //caso base return \"\" ; } return reverseRecursive ( str . substring ( 1 )) + str . charAt ( 0 ); }","title":"3.6- Recursividad"},{"location":"ud3/6recursion/#recursividad","text":"Un m\u00e9todo recursivo es un m\u00e9todo que se llama a s\u00ed mismo . Un m\u00e9todo iterativo es un m\u00e9todo que usa un bucle para repetir una acci\u00f3n. En cierto sentido, la recursividad es una alternativa a las estructuras de control iterativas (en bucle). Por ejemplo, tenemos el siguiente m\u00e9todo iterativo: public void hola ( int n ) { for ( int k = 0 ; k < n ; k ++ ) { System . out . println ( \"Hola\" ); } } Una versi\u00f3n recursiva de ese m\u00e9todo ser\u00eda: public void hola ( int n ) { if ( n > 0 ) { System . out . println ( \"Hola\" ); hola ( n \u2212 1 ); //Llamada recursiva } } Este m\u00e9todo es recursivo porque se llama a s\u00ed mismo cuando n es mayor que 0. Sin embargo, ten en cuenta que cuando se llama a s\u00ed mismo, pasa n - 1 como el valor de su par\u00e1metro. Si este m\u00e9todo se llama inicialmente con n igual a 5, lo siguiente es una pila de lo que sucede. Las indentaciones indican cada vez que el m\u00e9todo se llama a s\u00ed mismo: hola(5) imprime \"Hola\" hola(4) imprime \"Hola\" hola(3) imprime \"Hola\" hola(2) imprime \"Hola\" hola(1) imprime \"Hola\" hola(0) En el ejemplo anterior, es mucho menos eficiente llamar a un m\u00e9todo cinco veces que repetir un bucle for cinco veces. Las llamadas a m\u00e9todos ocupan m\u00e1s memoria que los bucles e implican m\u00e1s sobrecarga computacional, en tareas como pasar par\u00e1metros, asignar almacenamiento para las variables locales del m\u00e9todo y devolver los resultados del m\u00e9todo. Note Los algoritmos y m\u00e9todos iterativos son generalmente m\u00e1s eficientes que los algoritmos recursivos que hacen lo mismo.","title":"Recursividad"},{"location":"ud3/6recursion/#recursividad-como-un-enfoque-de-resolucion-de-problemas","text":"Dado que la recursividad no es realmente necesaria, si un lenguaje de programaci\u00f3n tiene bucles, y no es m\u00e1s eficiente que los bucles, \u00bfpor qu\u00e9 es tan importante? Porque la recursividad es un enfoque eficaz para la resoluci\u00f3n de problemas. Es una forma de ver un problema. La recursividad se basa en dos conceptos clave de resoluci\u00f3n de problemas: divide y vencer\u00e1s y auto-similaridad. En la resoluci\u00f3n de problemas recursivos, utilizamos la estrategia de divide y vencer\u00e1s repetidamente para dividir un gran problema en una secuencia de problemas cada vez m\u00e1s peque\u00f1os hasta que llegamos a un problema que es pr\u00e1cticamente trivial de resolver. Lo que nos permite crear esta serie de subproblemas es que cada subproblema es similar al problema original, es decir, cada subproblema es solo una versi\u00f3n m\u00e1s peque\u00f1a del problema original. La capacidad de ver un problema, por uno compuesto por problemas m\u00e1s peque\u00f1os y similares es el n\u00facleo del enfoque recursivo.","title":"Recursividad como un enfoque de resoluci\u00f3n de problemas"},{"location":"ud3/6recursion/#parte-recursiva-y-caso-base","text":"Una definici\u00f3n recursiva consta de dos partes: una parte recursiva que se repite y reduce el problema en una versi\u00f3n m\u00e1s peque\u00f1a del problema original, y un caso base o l\u00edmite no recursivo, que define una condici\u00f3n l\u00edmite y se utiliza para detener la recursividad. Veamos esto con un ejemplo:","title":"Parte recursiva y caso base"},{"location":"ud3/6recursion/#ejemplo-1-factorial-n","text":"Recordamos como se hac\u00eda el c\u00e1lculo de n!: n! = n * (n-1) * n(n-2) * .... mientras n > 0 Adem\u00e1s, 0! se define como 1. Ejemplos: 4! = 4 * 3 * 2 * 1 = 24 3! = 3 * 2 * 1 = 6 1! = 1 0! = 1 Como vemos en el ejemplo, podemos deducir que el factorial se repite en t\u00e9rminos de (n-1) y el \u00fanico caso donde no se calcula el factorial es 0!, esto nos lleva a que: n! = 1 --> if n = 0 //caso base n! = n * (n-1) --> if n > 0 //caso recursivo De forma que el factorial de un n\u00famero quedar\u00eda codificado de la siguiente forma: public static int factorial ( int n ) { if ( n <= 0 ) { return 1 ; } else { return n * factorial ( n - 1 ); } }","title":"EJEMPLO 1: Factorial: N!"},{"location":"ud3/6recursion/#traza","text":"factorial(4) 4 * factorial(3) 3 * factorial(2) 2 * factorial(1) 1 * factorial(0) return 1 return 1 * 1 --> 1 return 2 * 1 --> 2 return 3 * 2 --> 6 return 4 * 6 --> 24 return 24","title":"Traza"},{"location":"ud3/6recursion/#ejemplo-2-verificar-si-un-numero-es-palindromo","text":"Un n\u00famero es pal\u00edndromo si al leerse en ambos sentidos, tanto de izquierda a derecha como de derecha a izquierda, se obtiene el mismo n\u00famero. Por ejemplo: 121, 1001, etc. public static int revertir ( int n , int reverso ) { if ( n > 0 ) { int ud = n % 10 ; reverso = reverso * 10 ; return revertir ( n / 10 , ud + reverso ); } else { return reverso ; } } public static void main ( String [] args ) { int reverso = revertir ( 121 , 0 ); if ( reverso == n ) System . out . println ( \"Son pal\u00edndromos.\" ); else System . out . println ( \"No lo son\" ); }","title":"EJEMPLO 2: Verificar si un n\u00famero es pal\u00edndromo"},{"location":"ud3/6recursion/#ejemplo-3-revertir-un-string","text":"Para revertir un String, nos quedamos con el primer car\u00e1cter que iremos a\u00f1adiendo al final de la recursividad, y vamos acortando el String para llegar al caso base. public static String reverseRecursive ( String str ) { if ( str . isEmpty ()) { //caso base return \"\" ; } return reverseRecursive ( str . substring ( 1 )) + str . charAt ( 0 ); }","title":"EJEMPLO 3: Revertir un String"},{"location":"ud3/7nullvalue/","text":"Valor nulo Una variable de referencia contiene informaci\u00f3n sobre la ubicaci\u00f3n de un objeto. No contiene el objeto en s\u00ed. Por ejemplo el siguiente c\u00f3digo: String str ; Persona p ; declara dos variables de referencia pero no construye ning\u00fan objeto. Con el siguiente c\u00f3digo: str = \"Programaci\u00f3n\" ; p = new Persona ( \"Patricia\" ); se construyen los objetos y se colocan referencias en las variables. null es un valor especial que significa \"sin objeto\". Se establece una variable de referencia a null cuando no se refiere a ning\u00fan objeto. Las variables a menudo se asignan en nulas cuando se declaran: String str = null ; Persona p = null ; str y p todav\u00eda no son objetos, son variables que en un futuro pueden referenciar a objetos. Podemos asignar el valor null a cualquier variable de tipo referencia, ya sea un objeto, string, array, etc. Una variable de referencia a veces hace referencia a un objeto y otras veces no, y puede referirse a diferentes objetos en diferentes momentos. Por tanto, necesitamos una forma de decir que una variable ahora no se refiere a un objeto. Para ello, se le asigna un valor null a la variable. El objeto Persona con el nombre de Patricia se destruir\u00e1 eventualmente por el garbage collector ya que no es referenciado por nadie.","title":"3.7- Null value"},{"location":"ud3/7nullvalue/#valor-nulo","text":"Una variable de referencia contiene informaci\u00f3n sobre la ubicaci\u00f3n de un objeto. No contiene el objeto en s\u00ed. Por ejemplo el siguiente c\u00f3digo: String str ; Persona p ; declara dos variables de referencia pero no construye ning\u00fan objeto. Con el siguiente c\u00f3digo: str = \"Programaci\u00f3n\" ; p = new Persona ( \"Patricia\" ); se construyen los objetos y se colocan referencias en las variables. null es un valor especial que significa \"sin objeto\". Se establece una variable de referencia a null cuando no se refiere a ning\u00fan objeto. Las variables a menudo se asignan en nulas cuando se declaran: String str = null ; Persona p = null ; str y p todav\u00eda no son objetos, son variables que en un futuro pueden referenciar a objetos. Podemos asignar el valor null a cualquier variable de tipo referencia, ya sea un objeto, string, array, etc. Una variable de referencia a veces hace referencia a un objeto y otras veces no, y puede referirse a diferentes objetos en diferentes momentos. Por tanto, necesitamos una forma de decir que una variable ahora no se refiere a un objeto. Para ello, se le asigna un valor null a la variable. El objeto Persona con el nombre de Patricia se destruir\u00e1 eventualmente por el garbage collector ya que no es referenciado por nadie.","title":"Valor nulo"},{"location":"ud4/1arrays/","text":"Arrays de datos primitivos Los arrays es una estructura de datos que te permite almacenar una secuencia de valores todos del mismo tipo. Un array est\u00e1 hecho de bloques contiguos de memoria que se divide en varias celdas. Cada celda tiene un valor y todos los valores son del mismo tipo. A veces, las celdas de un array se denominan slots. En el array de la imagen cada celda contiene un int. En el ejemplo de la imagen hemos creado un array de enteros. Tambi\u00e9n se podr\u00eda crear un array de caracteres, de String, etc. Esto se podr\u00eda hacer tanto para tipos de datos primitivos como para objetos. Las celdas est\u00e1n numeradas secuencialmente empezando por cero. Si hay N celdas en un array, entonces los \u00edndices van del 0 hasta N-1. La longitud de un array es el n\u00famero de celdas. Al valor almacenado en la celda de un array se le suele llamar elemento . Es muy importante tener en cuenta que los arrays empiezan siempre en la posici\u00f3n cero. Por tanto, si se desea acceder al primer elemento del array, estar\u00e1 almacenado en la posici\u00f3n 0. Declaraci\u00f3n y reseva de memoria Para declarar un array, se hace de la misma forma que har\u00edamos si quisi\u00e9ramos declarar una variable pero a\u00f1adiendo [ ] : int miVariable ; //declaramos una variable normal int [] miArray ; //declaramos una variable array Si usamos la declaraci\u00f3n tipo[] arrayName crea una referencia a una variable de tipo de array, pero no construye el objeto. Los arrays en Java se crean como objetos, y como cualquier otro objeto en Java, para construirlo utilizamos la palabra reservada new . Para inicializar un array usaremos la palabra new + tipo de dato + tama\u00f1o del array entre corchetes[]: int [] miArray = new int [ 10 ] ; //creamos y reservamos memoria para el array con 10 elementos // y valores 0 en cada posici\u00f3n double [] dArray = new double [ 5 ] ; Una vez ha sido construido no es posible cambiar su tama\u00f1o. La variable miArray va a ser un array con espacio para 10 elementos de tipo entero. Acceso a los elementos del array Para guardar un valor dentro de una celda del array tenemos que acceder a su posici\u00f3n dentro del array. int [] miArray = new int [ 10 ] ; miArray [ 2 ] = 5 ; //guardamos en la posici\u00f3n 2 del array el valor 5 Warning Recuerda que los elementos del array empiezan con \u00edndice 0, por tanto, en realidad la posici\u00f3n 2 ser\u00eda la 3. Para acceder a un valor de una determinada posici\u00f3n del array y mostrarlo lo har\u00edamos de la siguiente forma: int elemento = miArray [ 2 ] ; //almacenamos el valor 5 en la variable entera elemento System . out . println ( elemento ); // o tambi\u00e9n podemos hacer directamente System . out . println ( miArray [ 2 ] ); Inicializaci\u00f3n del array Hay varias formas de inicializar un array. Por ejemplo, si quisi\u00e9ramos darle valor a todas las posiciones del array podr\u00edamos hacerlo de la forma: miArray [ 0 ] = 2 ; miArray [ 1 ] = 31 ; miArray [ 2 ] = 5 ; .... miArray [ 10 ] = 4 ; Lo cual es una forma muy pesada y tediosa. Java nos ofrece otras formas de inicializar los arrays en una sola l\u00ednea de c\u00f3digo que solo es aplicable a la vez que definimos la variable: int [] miArray = { 2 , 31 , 5 , 7 , 12 , 89 , 6 , 11 , 50 , 4 }; //correcto //no puedo inicializar el array despu\u00e9s de haberlo creado miArray = { 2 , 31 , 5 , 7 , 12 , 89 , 6 , 11 , 50 , 4 }; //eso da ERROR De esa forma, tambi\u00e9n le indicamos indirectamente el tama\u00f1o del array. Java cuenta el n\u00famero de elementos que hay entre {} y crea un array de ese tama\u00f1o y adem\u00e1s los asigna en posiciones consecutivas dentro del array. Los \u00edndices en un array son enteros que especifican la posici\u00f3n que ocupa el elemento dentro del array. Por tanto podemos manejar los \u00edndices con variables enteras. Una tercera forma ser\u00eda utilizando la estructura de bucle for , para esto, debemos saber con antelaci\u00f3n el valor de los elementos del array: int [] miArray = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { miArray [ i ] = i * 10 ; } Lo que hacemos es inicializar cada posici\u00f3n del array utilizando el bucle. Estamos almacenando dentro del array el valor del \u00edndice multiplicado por 10, de forma que tendremos, {0, 10, 20, ...., 90}. La estructura for tambi\u00e9n es de gran ayuda si queremos imprimir los valores que est\u00e1n guardados en cada posici\u00f3n del array: for ( int i = 0 ; i < 10 ; i ++ ) { System . out . println ( \"Elemento \" + i + \" valor \" + miArray [ i ] ); } A falta de cualquier otra informaci\u00f3n, las celdas de un array se inicializan con el valor predeterminado para su tipo. Cada celda de un array de tipo num\u00e9rico se inicializa a cero. Y cada celda de un array de referencias a objetos se inicializa en nulo (null) . Longitud del array Una buena pr\u00e1ctica, es utilizar una propiedad integrada dentro de array, en vez de hardcodear literales de tama\u00f1o dentro del bucle. Esta propiedad es length : for ( int i = 0 ; i < miArray . length ; i ++ ) { System . out . println ( \"Elemento \" + i + \" valor \" + miArray [ i ] ); } Si ahora cambiamos la longitud del array en su definici\u00f3n, no se ver\u00eda afectado ning\u00fan bucle o lugar donde se utilizara miArray.length . Pasar un array como argumento en un m\u00e9todo Al igual que hac\u00edamos con las variables simples, tambi\u00e9n podemos pasar arrays a los m\u00e9todos. public static void imprimirArray ( int [] array ) { for ( int i = 0 ; i < array . length ; i ++ ) { System . out . println ( \"Elemento \" + i + \" valor \" + array [ i ] ); } } public static void main () { int [] miArray = new int [ 10 ] ; imprimirArray ( miArray ); } Devolver un array en un m\u00e9todo Para devolver un objeto de tipo array en un m\u00e9todo simplemente a\u00f1adiremos []: public static int [] calcular () { int [] miArray = new int [ 10 ] ; .... //realizo calculos con el array return miArray ; } Caso pr\u00e1ctico real uso de un array Vamos a presentar un ejemplo de un caso real para el que los arrays son muy efectivos. Por ejemplo pedir al usuario que inserte n\u00fameros y mostrar la media de los n\u00fameros insertados. public class MiArray { private static Scanner sc = new Scanner ( System . in ); public static void main ( String [] args ) { int [] enteros = leerEnteros ( 5 ); //imprimimos los valores for ( int i = 0 ; i < enteros . length ; i ++ ) { System . out . println ( \"Elemento en posici\u00f3n \" + i + \" valor \" + enteros [ i ] ); } System . out . println ( \"La media del array es \" + calcularMedia ( enteros )); } public static int [] leerEnteros ( int elementos ) { System . out . println ( \"Inserta \" + elementos + \" de tipo entero.\" ); int [] array = new int [ elementos ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = sc . nextInt (); } return array ; } public static double calcularMedia ( int [] array ) { int suma = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { suma += array [ i ] ; } return ( double ) suma / ( double ) array . length ; } }","title":"4.1- Introducci\u00f3n"},{"location":"ud4/1arrays/#arrays-de-datos-primitivos","text":"Los arrays es una estructura de datos que te permite almacenar una secuencia de valores todos del mismo tipo. Un array est\u00e1 hecho de bloques contiguos de memoria que se divide en varias celdas. Cada celda tiene un valor y todos los valores son del mismo tipo. A veces, las celdas de un array se denominan slots. En el array de la imagen cada celda contiene un int. En el ejemplo de la imagen hemos creado un array de enteros. Tambi\u00e9n se podr\u00eda crear un array de caracteres, de String, etc. Esto se podr\u00eda hacer tanto para tipos de datos primitivos como para objetos. Las celdas est\u00e1n numeradas secuencialmente empezando por cero. Si hay N celdas en un array, entonces los \u00edndices van del 0 hasta N-1. La longitud de un array es el n\u00famero de celdas. Al valor almacenado en la celda de un array se le suele llamar elemento . Es muy importante tener en cuenta que los arrays empiezan siempre en la posici\u00f3n cero. Por tanto, si se desea acceder al primer elemento del array, estar\u00e1 almacenado en la posici\u00f3n 0.","title":"Arrays de datos primitivos"},{"location":"ud4/1arrays/#declaracion-y-reseva-de-memoria","text":"Para declarar un array, se hace de la misma forma que har\u00edamos si quisi\u00e9ramos declarar una variable pero a\u00f1adiendo [ ] : int miVariable ; //declaramos una variable normal int [] miArray ; //declaramos una variable array Si usamos la declaraci\u00f3n tipo[] arrayName crea una referencia a una variable de tipo de array, pero no construye el objeto. Los arrays en Java se crean como objetos, y como cualquier otro objeto en Java, para construirlo utilizamos la palabra reservada new . Para inicializar un array usaremos la palabra new + tipo de dato + tama\u00f1o del array entre corchetes[]: int [] miArray = new int [ 10 ] ; //creamos y reservamos memoria para el array con 10 elementos // y valores 0 en cada posici\u00f3n double [] dArray = new double [ 5 ] ; Una vez ha sido construido no es posible cambiar su tama\u00f1o. La variable miArray va a ser un array con espacio para 10 elementos de tipo entero.","title":"Declaraci\u00f3n y reseva de memoria"},{"location":"ud4/1arrays/#acceso-a-los-elementos-del-array","text":"Para guardar un valor dentro de una celda del array tenemos que acceder a su posici\u00f3n dentro del array. int [] miArray = new int [ 10 ] ; miArray [ 2 ] = 5 ; //guardamos en la posici\u00f3n 2 del array el valor 5 Warning Recuerda que los elementos del array empiezan con \u00edndice 0, por tanto, en realidad la posici\u00f3n 2 ser\u00eda la 3. Para acceder a un valor de una determinada posici\u00f3n del array y mostrarlo lo har\u00edamos de la siguiente forma: int elemento = miArray [ 2 ] ; //almacenamos el valor 5 en la variable entera elemento System . out . println ( elemento ); // o tambi\u00e9n podemos hacer directamente System . out . println ( miArray [ 2 ] );","title":"Acceso a los elementos del array"},{"location":"ud4/1arrays/#inicializacion-del-array","text":"Hay varias formas de inicializar un array. Por ejemplo, si quisi\u00e9ramos darle valor a todas las posiciones del array podr\u00edamos hacerlo de la forma: miArray [ 0 ] = 2 ; miArray [ 1 ] = 31 ; miArray [ 2 ] = 5 ; .... miArray [ 10 ] = 4 ; Lo cual es una forma muy pesada y tediosa. Java nos ofrece otras formas de inicializar los arrays en una sola l\u00ednea de c\u00f3digo que solo es aplicable a la vez que definimos la variable: int [] miArray = { 2 , 31 , 5 , 7 , 12 , 89 , 6 , 11 , 50 , 4 }; //correcto //no puedo inicializar el array despu\u00e9s de haberlo creado miArray = { 2 , 31 , 5 , 7 , 12 , 89 , 6 , 11 , 50 , 4 }; //eso da ERROR De esa forma, tambi\u00e9n le indicamos indirectamente el tama\u00f1o del array. Java cuenta el n\u00famero de elementos que hay entre {} y crea un array de ese tama\u00f1o y adem\u00e1s los asigna en posiciones consecutivas dentro del array. Los \u00edndices en un array son enteros que especifican la posici\u00f3n que ocupa el elemento dentro del array. Por tanto podemos manejar los \u00edndices con variables enteras. Una tercera forma ser\u00eda utilizando la estructura de bucle for , para esto, debemos saber con antelaci\u00f3n el valor de los elementos del array: int [] miArray = new int [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { miArray [ i ] = i * 10 ; } Lo que hacemos es inicializar cada posici\u00f3n del array utilizando el bucle. Estamos almacenando dentro del array el valor del \u00edndice multiplicado por 10, de forma que tendremos, {0, 10, 20, ...., 90}. La estructura for tambi\u00e9n es de gran ayuda si queremos imprimir los valores que est\u00e1n guardados en cada posici\u00f3n del array: for ( int i = 0 ; i < 10 ; i ++ ) { System . out . println ( \"Elemento \" + i + \" valor \" + miArray [ i ] ); } A falta de cualquier otra informaci\u00f3n, las celdas de un array se inicializan con el valor predeterminado para su tipo. Cada celda de un array de tipo num\u00e9rico se inicializa a cero. Y cada celda de un array de referencias a objetos se inicializa en nulo (null) .","title":"Inicializaci\u00f3n del array"},{"location":"ud4/1arrays/#longitud-del-array","text":"Una buena pr\u00e1ctica, es utilizar una propiedad integrada dentro de array, en vez de hardcodear literales de tama\u00f1o dentro del bucle. Esta propiedad es length : for ( int i = 0 ; i < miArray . length ; i ++ ) { System . out . println ( \"Elemento \" + i + \" valor \" + miArray [ i ] ); } Si ahora cambiamos la longitud del array en su definici\u00f3n, no se ver\u00eda afectado ning\u00fan bucle o lugar donde se utilizara miArray.length .","title":"Longitud del array"},{"location":"ud4/1arrays/#pasar-un-array-como-argumento-en-un-metodo","text":"Al igual que hac\u00edamos con las variables simples, tambi\u00e9n podemos pasar arrays a los m\u00e9todos. public static void imprimirArray ( int [] array ) { for ( int i = 0 ; i < array . length ; i ++ ) { System . out . println ( \"Elemento \" + i + \" valor \" + array [ i ] ); } } public static void main () { int [] miArray = new int [ 10 ] ; imprimirArray ( miArray ); }","title":"Pasar un array como argumento en un m\u00e9todo"},{"location":"ud4/1arrays/#devolver-un-array-en-un-metodo","text":"Para devolver un objeto de tipo array en un m\u00e9todo simplemente a\u00f1adiremos []: public static int [] calcular () { int [] miArray = new int [ 10 ] ; .... //realizo calculos con el array return miArray ; }","title":"Devolver un array en un m\u00e9todo"},{"location":"ud4/1arrays/#caso-practico-real-uso-de-un-array","text":"Vamos a presentar un ejemplo de un caso real para el que los arrays son muy efectivos. Por ejemplo pedir al usuario que inserte n\u00fameros y mostrar la media de los n\u00fameros insertados. public class MiArray { private static Scanner sc = new Scanner ( System . in ); public static void main ( String [] args ) { int [] enteros = leerEnteros ( 5 ); //imprimimos los valores for ( int i = 0 ; i < enteros . length ; i ++ ) { System . out . println ( \"Elemento en posici\u00f3n \" + i + \" valor \" + enteros [ i ] ); } System . out . println ( \"La media del array es \" + calcularMedia ( enteros )); } public static int [] leerEnteros ( int elementos ) { System . out . println ( \"Inserta \" + elementos + \" de tipo entero.\" ); int [] array = new int [ elementos ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = sc . nextInt (); } return array ; } public static double calcularMedia ( int [] array ) { int suma = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { suma += array [ i ] ; } return ( double ) suma / ( double ) array . length ; } }","title":"Caso pr\u00e1ctico real uso de un array"},{"location":"ud4/2usefularrays/","text":"Algoritmos de arrays \u00fatiles Un array que utiliza un solo \u00edndice para acceder a sus valores se denomina array unidimensional , ya que utilizamos el \u00edndice para acceder a todas las celdas del array. \u00c9stas celdas est\u00e1n alineadas de forma secuencial. Un array bidimensional necesita dos \u00edndices para acceder a los valores. En este caso las celdas est\u00e1n dispuestas en forma de matriz, como una estructura rectangular. Es posible crear arrays de mayores dimensiones aunque rara vez se utilizan. Contar los elementos que contiene un array Cuando utilizamos arrays, es muy molesto contar los elementos de un array para saber su tama\u00f1o. Afortunadamente, todo objeto de tipo array tiene una variable de instancia llamada length que contiene el tama\u00f1o del array, es decir, el n\u00famero de celdas. Imprimir los elementos de un array Un algoritmo muy utilizado cuando trabajamos con arrays es mostrar los valores que contiene el array en cada una de sus celdas. Para ello nos ayudamos del campo length que nos devuelve la longitud del array. public static void imprimirArray ( int [] array ) { for ( int i = 0 ; i < array . length ; i ++ ) { System . out . println ( \"Elemento \" + i + \" valor \" + array [ i ] ); } } Leer y rellenar los elementos de un array por teclado Es muy com\u00fan que los elementos de un array sean valores introducidos de alguna forma por el usuario. El ejemplo m\u00e1s sencillo es leerlos directamente desde la entrada de flujo, a la vez que leemos el valor insertado por el usuario se lo asignamos al array. int [] array = new int [ elementos ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = sc . nextInt (); } Algoritmo Cualquier procedimiento sistem\u00e1tico utilizado para calcular algo se llama algoritmo . Por ejemplo si queremos sumar todos los elementos de un array realizaremos un algoritmo. Un algoritmo es una descripci\u00f3n de c\u00f3mo hacer algo. No est\u00e1 vinculado a ning\u00fan idioma en particular. Un algoritmo se puede implementar en cualquier lenguaje de programaci\u00f3n de computadoras. El programa siguiente muestra un ejemplo de un algoritmo. Aqu\u00ed la variable suma juega el papel de almacenar la suma de los elementos que se van leyendo. El programa recorre elementos del array comenzando en el \u00edndice 0 y yendo hasta el final. public static int suma ( int [] array ) { int suma = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { suma += array [ i ] ; } return suma ; } Cl\u00e1sico error 1: no testear los l\u00edmites del array Cuando trabajamos con arrays, a menudo nos puede ocurrir que olvidamos el \u00faltimo elemento del array, si cambiamos la condici\u00f3n del bucle por i < array.length -1 , o olvidamos el primer elemento si establecemos el \u00edndice en int i = 1 porque creemos que el primer elemento est\u00e1 en la posici\u00f3n 1 del array. Estos son errores cl\u00e1sicos: no probar los l\u00edmites de los arrays, es decir, el primer elemento o el \u00faltimo. Por ejemplo, en el siguiente c\u00f3digo no quiero tener n\u00fameros de una cifra en mi array. int [] array = { 2 , 19 , 1 , 5 , 1 , 27 , 9 , 5 }; for ( int i = 0 ; i < array . length - 1 ; i ++ ) { if ( array [ i ] < 10 ) array [ i ] = array [ i ] * 10 ; } Cuando recorro el array, el \u00faltimo elemento no ser\u00eda testeado por tanto me devolver\u00eda un 5 en vez de 50. El programa ser\u00eda incorrecto. Cl\u00e1sico error 2: exceder los l\u00edmites del array Al contrario que, en el apartado anterior, si intentamos acceder a una celda del array que no existe, se lanzar\u00e1 una ArrayIndexOutOfBoundsException y el programa se detendr\u00e1. Los errores de acceso a la \u00faltima posici\u00f3n del array + 1 son muy comunes. Un ejemplo ser\u00eda: int [] array = { 2 , 19 , 1 , 5 , 1 , 27 , 9 , 5 }; for ( int i = 0 ; i <= array . length ; i ++ ) { if ( array [ i ] < 10 ) array [ i ] = array [ i ] * 10 ; } Bucle foreach (enhanced for loop) Para evitar que los errores mencionados anteriormente ocurran, Java dispone de un bucle mejorado que visita cada elemento del array en orden sin necesidad de establecer un \u00edndice. Por tanto, los errores de exceder los l\u00edmites del array se eliminan autom\u00e1ticamente con este bucle. La sintaxis es la siguiente: Este bucle de lee en voz alta de la siguiente manera: \"para cada valor del array...\" (for each value in array...) El tipo de dato de la variable que se crea en el bucle es igual al de cada una de las celdas del array, y va a contener los valores de ellas. En la primera iteraci\u00f3n contrendr\u00e1 el valor de la primera celda del array, y as\u00ed sucesivamente hasta llegar a la \u00faltima celda del array. Ejemplo: int [] array = { 2 , 19 , 1 , 5 , 1 , 27 , 9 , 5 }; int suma = 0 ; for ( int numero : array ) { suma += numero ; } Comparar si dos arrays son iguales Es muy usual utilizar el operador \"==\" cuando queremos comparar si dos arrays son iguales, es decir, si contienen los mismos elementos. Pero si ejecutamos el siguiente c\u00f3digo: int [] array1 = { 1 , 2 , 3 }; int [] array2 = { 1 , 2 , 3 }; System . out . println ( array1 == array2 ); //imprime false Obtenemos false , esta situaci\u00f3n es parecida a cuando intent\u00e1bamos comparar dos String. Recordar que utilizar el operador \"==\" era incorrecto ya que son objetos diferentes aunque tuvieran el mismo contenido. Si utilizamos el m\u00e9todo equals() para arrays, devolver\u00eda el mismo valor booleano que el operador \"==\". System . out . println ( array1 . equals ( array2 )); //imprime false Para comprobar que dos arrays contienen los mismos elementos se utiliza la clase Arrays . La clase Arrays contiene muchos m\u00e9todos est\u00e1ticos para manipular matrices. Dado que los m\u00e9todos son est\u00e1ticos, los invoca utilizando el nombre de la clase . int [] array1 = { 1 , 2 , 3 }; int [] array2 = { 1 , 2 , 3 }; System . out . println ( Arrays . equals ( array1 , array2 )); //imprime true El m\u00e9todo Arrays.equals comprueba que dos arrays son iguales si tienen la misma longitud y contienen los mismos elementos en el mismo orden.","title":"4.2- Algoritmos \u00fatiles en arrays"},{"location":"ud4/2usefularrays/#algoritmos-de-arrays-utiles","text":"Un array que utiliza un solo \u00edndice para acceder a sus valores se denomina array unidimensional , ya que utilizamos el \u00edndice para acceder a todas las celdas del array. \u00c9stas celdas est\u00e1n alineadas de forma secuencial. Un array bidimensional necesita dos \u00edndices para acceder a los valores. En este caso las celdas est\u00e1n dispuestas en forma de matriz, como una estructura rectangular. Es posible crear arrays de mayores dimensiones aunque rara vez se utilizan.","title":"Algoritmos de arrays \u00fatiles"},{"location":"ud4/2usefularrays/#contar-los-elementos-que-contiene-un-array","text":"Cuando utilizamos arrays, es muy molesto contar los elementos de un array para saber su tama\u00f1o. Afortunadamente, todo objeto de tipo array tiene una variable de instancia llamada length que contiene el tama\u00f1o del array, es decir, el n\u00famero de celdas.","title":"Contar los elementos que contiene un array"},{"location":"ud4/2usefularrays/#imprimir-los-elementos-de-un-array","text":"Un algoritmo muy utilizado cuando trabajamos con arrays es mostrar los valores que contiene el array en cada una de sus celdas. Para ello nos ayudamos del campo length que nos devuelve la longitud del array. public static void imprimirArray ( int [] array ) { for ( int i = 0 ; i < array . length ; i ++ ) { System . out . println ( \"Elemento \" + i + \" valor \" + array [ i ] ); } }","title":"Imprimir los elementos de un array"},{"location":"ud4/2usefularrays/#leer-y-rellenar-los-elementos-de-un-array-por-teclado","text":"Es muy com\u00fan que los elementos de un array sean valores introducidos de alguna forma por el usuario. El ejemplo m\u00e1s sencillo es leerlos directamente desde la entrada de flujo, a la vez que leemos el valor insertado por el usuario se lo asignamos al array. int [] array = new int [ elementos ] ; for ( int i = 0 ; i < array . length ; i ++ ) { array [ i ] = sc . nextInt (); }","title":"Leer y rellenar los elementos de un array por teclado"},{"location":"ud4/2usefularrays/#algoritmo","text":"Cualquier procedimiento sistem\u00e1tico utilizado para calcular algo se llama algoritmo . Por ejemplo si queremos sumar todos los elementos de un array realizaremos un algoritmo. Un algoritmo es una descripci\u00f3n de c\u00f3mo hacer algo. No est\u00e1 vinculado a ning\u00fan idioma en particular. Un algoritmo se puede implementar en cualquier lenguaje de programaci\u00f3n de computadoras. El programa siguiente muestra un ejemplo de un algoritmo. Aqu\u00ed la variable suma juega el papel de almacenar la suma de los elementos que se van leyendo. El programa recorre elementos del array comenzando en el \u00edndice 0 y yendo hasta el final. public static int suma ( int [] array ) { int suma = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { suma += array [ i ] ; } return suma ; }","title":"Algoritmo"},{"location":"ud4/2usefularrays/#clasico-error-1-no-testear-los-limites-del-array","text":"Cuando trabajamos con arrays, a menudo nos puede ocurrir que olvidamos el \u00faltimo elemento del array, si cambiamos la condici\u00f3n del bucle por i < array.length -1 , o olvidamos el primer elemento si establecemos el \u00edndice en int i = 1 porque creemos que el primer elemento est\u00e1 en la posici\u00f3n 1 del array. Estos son errores cl\u00e1sicos: no probar los l\u00edmites de los arrays, es decir, el primer elemento o el \u00faltimo. Por ejemplo, en el siguiente c\u00f3digo no quiero tener n\u00fameros de una cifra en mi array. int [] array = { 2 , 19 , 1 , 5 , 1 , 27 , 9 , 5 }; for ( int i = 0 ; i < array . length - 1 ; i ++ ) { if ( array [ i ] < 10 ) array [ i ] = array [ i ] * 10 ; } Cuando recorro el array, el \u00faltimo elemento no ser\u00eda testeado por tanto me devolver\u00eda un 5 en vez de 50. El programa ser\u00eda incorrecto.","title":"Cl\u00e1sico error 1: no testear los l\u00edmites del array"},{"location":"ud4/2usefularrays/#clasico-error-2-exceder-los-limites-del-array","text":"Al contrario que, en el apartado anterior, si intentamos acceder a una celda del array que no existe, se lanzar\u00e1 una ArrayIndexOutOfBoundsException y el programa se detendr\u00e1. Los errores de acceso a la \u00faltima posici\u00f3n del array + 1 son muy comunes. Un ejemplo ser\u00eda: int [] array = { 2 , 19 , 1 , 5 , 1 , 27 , 9 , 5 }; for ( int i = 0 ; i <= array . length ; i ++ ) { if ( array [ i ] < 10 ) array [ i ] = array [ i ] * 10 ; }","title":"Cl\u00e1sico error 2: exceder los l\u00edmites del array"},{"location":"ud4/2usefularrays/#bucle-foreach-enhanced-for-loop","text":"Para evitar que los errores mencionados anteriormente ocurran, Java dispone de un bucle mejorado que visita cada elemento del array en orden sin necesidad de establecer un \u00edndice. Por tanto, los errores de exceder los l\u00edmites del array se eliminan autom\u00e1ticamente con este bucle. La sintaxis es la siguiente: Este bucle de lee en voz alta de la siguiente manera: \"para cada valor del array...\" (for each value in array...) El tipo de dato de la variable que se crea en el bucle es igual al de cada una de las celdas del array, y va a contener los valores de ellas. En la primera iteraci\u00f3n contrendr\u00e1 el valor de la primera celda del array, y as\u00ed sucesivamente hasta llegar a la \u00faltima celda del array. Ejemplo: int [] array = { 2 , 19 , 1 , 5 , 1 , 27 , 9 , 5 }; int suma = 0 ; for ( int numero : array ) { suma += numero ; }","title":"Bucle foreach (enhanced for loop)"},{"location":"ud4/2usefularrays/#comparar-si-dos-arrays-son-iguales","text":"Es muy usual utilizar el operador \"==\" cuando queremos comparar si dos arrays son iguales, es decir, si contienen los mismos elementos. Pero si ejecutamos el siguiente c\u00f3digo: int [] array1 = { 1 , 2 , 3 }; int [] array2 = { 1 , 2 , 3 }; System . out . println ( array1 == array2 ); //imprime false Obtenemos false , esta situaci\u00f3n es parecida a cuando intent\u00e1bamos comparar dos String. Recordar que utilizar el operador \"==\" era incorrecto ya que son objetos diferentes aunque tuvieran el mismo contenido. Si utilizamos el m\u00e9todo equals() para arrays, devolver\u00eda el mismo valor booleano que el operador \"==\". System . out . println ( array1 . equals ( array2 )); //imprime false Para comprobar que dos arrays contienen los mismos elementos se utiliza la clase Arrays . La clase Arrays contiene muchos m\u00e9todos est\u00e1ticos para manipular matrices. Dado que los m\u00e9todos son est\u00e1ticos, los invoca utilizando el nombre de la clase . int [] array1 = { 1 , 2 , 3 }; int [] array2 = { 1 , 2 , 3 }; System . out . println ( Arrays . equals ( array1 , array2 )); //imprime true El m\u00e9todo Arrays.equals comprueba que dos arrays son iguales si tienen la misma longitud y contienen los mismos elementos en el mismo orden.","title":"Comparar si dos arrays son iguales"},{"location":"ud4/3referencetypearrays/","text":"Tipos de referencia vs tipos de valor Sabemos que los tipos de datos primitivos como int, double, etc. son tipos de datos primitivos, es decir, son tipos de valor ya que almacenan valores. A diferencia de \u00e9stos, los arrays son tipos de referencia como tambi\u00e9n los son los String. Cuando creamos una variable de tipo valor, se asigna un solo espacio en la memoria para almacenar su valor y esa variable contiene directamente el valor. Si creamos otra variable y le asignamos esa variable como se ve en el siguiente c\u00f3digo: int variable = 2 ; int otraVariable = variable ; //asignamos un 2 a otraVariable otraVariable = 5 ; System . out . println ( variable ); //imprime 2 System . out . println ( otraVariable ); //imprime 5 El valor es copiado directamente y ambas variables trabajan independientemente. Cada una tiene su propia copia del valor espec\u00edfico, en este caso 2. Ahora bien, tipos de referencia, como clases o arrays trabajan de forma diferente. Utilizamos la palabra new para crear un nuevo objeto. int [] array = new int [ 5 ] ; En este caso, tenemos una referencia a un array. Los tipos de referencia son usados por una referencia. Por lo tanto, una referencia contiene una referencia o una direcci\u00f3n de objeto pero no el objeto en s\u00ed. En el ejemplo anterior, la variable array contiene una referencia o direcci\u00f3n al array en la memoria. Con los tipos de referencia, usamos una referencia para controlar el objeto en memoria, no podemos acceder al objeto directamente. Una referencia es como una direcci\u00f3n de alg\u00fan objeto en memoria . int [] array = new int [ 5 ] ; int [] otroArray = array ; En el c\u00f3digo anterior, hemos declarado otroArray que es una referencia al mismo array en memoria. Es decir, ahora tenemos dos referencias apuntando al mismo array en memoria. O dicho de otra forma, tanto array como otroArray contienen la misma direcci\u00f3n en memoria. Como se puede observar, una forma de saber si es de tipo de referencia es con el operador new , ya que este crea un nuevo objeto en memoria. Para imprimir el contenido de un array, podemos usar un m\u00e9todo integrado en Java en la clase Arrays.toString . Este m\u00e9todo imprime el contenido del array en una sola l\u00ednea separando los elementos con comas. int [] array = new int [ 5 ] ; int [] otroArray = array ; System . out . println ( Arrays . toString ( array )); System . out . println ( Arrays . toString ( otroArray )); Ahora mismo, los arrays est\u00e1n vac\u00edos por tanto se imprime todo con valores 0. Vamos a ver que ocurre si modificamos un valor en el array otroArray . int [] array = new int [ 5 ] ; int [] otroArray = array ; System . out . println ( Arrays . toString ( array )); System . out . println ( Arrays . toString ( otroArray )); otroArray [ 0 ] = 3 ; System . out . println ( Arrays . toString ( array )); System . out . println ( Arrays . toString ( otroArray )); Si ejecutamos el c\u00f3digo, veremos que ambos arrays han cambiado. Esto ocurre porque las dos variables apuntan al mismo array en memoria. Solo hay una copia del array en la memoria . Las dos variables contienen la direcci\u00f3n que apunta al array en memoria. Para desreferenciar un array y que apunte a otro array en memoria tenemos que usar el operador new : int [] array = new int [ 5 ] ; int [] otroArray = array ; System . out . println ( Arrays . toString ( array )); System . out . println ( Arrays . toString ( otroArray )); array = new int [] { 1 , 2 , 3 }; otroArray [ 0 ] = 3 ; System . out . println ( Arrays . toString ( array )); System . out . println ( Arrays . toString ( otroArray )); M\u00e9todos: paso por referencia Recuerda que Java usa llamada por valor para pasar datos a m\u00e9todos, esto es que env\u00eda una copia del dato, por tanto cualquier modificaci\u00f3n de la copia dentro del m\u00e9todo no afecta al original. Con par\u00e1metros de tipo array es diferente. Si pasamos a un m\u00e9todo el array, ya que le estamos pasando la referencia al array, crear\u00eda una nueva variable dentro del m\u00e9todo pero \u00e9sta apuntar\u00eda al mismo array en memoria. Cualquier modificaci\u00f3n dentro del m\u00e9todo en el array se ver\u00eda fuera del m\u00e9todo puesto que solo hay un objeto array en memoria.","title":"4.3- Tipos de referencia y tipos de valor"},{"location":"ud4/3referencetypearrays/#tipos-de-referencia-vs-tipos-de-valor","text":"Sabemos que los tipos de datos primitivos como int, double, etc. son tipos de datos primitivos, es decir, son tipos de valor ya que almacenan valores. A diferencia de \u00e9stos, los arrays son tipos de referencia como tambi\u00e9n los son los String. Cuando creamos una variable de tipo valor, se asigna un solo espacio en la memoria para almacenar su valor y esa variable contiene directamente el valor. Si creamos otra variable y le asignamos esa variable como se ve en el siguiente c\u00f3digo: int variable = 2 ; int otraVariable = variable ; //asignamos un 2 a otraVariable otraVariable = 5 ; System . out . println ( variable ); //imprime 2 System . out . println ( otraVariable ); //imprime 5 El valor es copiado directamente y ambas variables trabajan independientemente. Cada una tiene su propia copia del valor espec\u00edfico, en este caso 2. Ahora bien, tipos de referencia, como clases o arrays trabajan de forma diferente. Utilizamos la palabra new para crear un nuevo objeto. int [] array = new int [ 5 ] ; En este caso, tenemos una referencia a un array. Los tipos de referencia son usados por una referencia. Por lo tanto, una referencia contiene una referencia o una direcci\u00f3n de objeto pero no el objeto en s\u00ed. En el ejemplo anterior, la variable array contiene una referencia o direcci\u00f3n al array en la memoria. Con los tipos de referencia, usamos una referencia para controlar el objeto en memoria, no podemos acceder al objeto directamente. Una referencia es como una direcci\u00f3n de alg\u00fan objeto en memoria . int [] array = new int [ 5 ] ; int [] otroArray = array ; En el c\u00f3digo anterior, hemos declarado otroArray que es una referencia al mismo array en memoria. Es decir, ahora tenemos dos referencias apuntando al mismo array en memoria. O dicho de otra forma, tanto array como otroArray contienen la misma direcci\u00f3n en memoria. Como se puede observar, una forma de saber si es de tipo de referencia es con el operador new , ya que este crea un nuevo objeto en memoria. Para imprimir el contenido de un array, podemos usar un m\u00e9todo integrado en Java en la clase Arrays.toString . Este m\u00e9todo imprime el contenido del array en una sola l\u00ednea separando los elementos con comas. int [] array = new int [ 5 ] ; int [] otroArray = array ; System . out . println ( Arrays . toString ( array )); System . out . println ( Arrays . toString ( otroArray )); Ahora mismo, los arrays est\u00e1n vac\u00edos por tanto se imprime todo con valores 0. Vamos a ver que ocurre si modificamos un valor en el array otroArray . int [] array = new int [ 5 ] ; int [] otroArray = array ; System . out . println ( Arrays . toString ( array )); System . out . println ( Arrays . toString ( otroArray )); otroArray [ 0 ] = 3 ; System . out . println ( Arrays . toString ( array )); System . out . println ( Arrays . toString ( otroArray )); Si ejecutamos el c\u00f3digo, veremos que ambos arrays han cambiado. Esto ocurre porque las dos variables apuntan al mismo array en memoria. Solo hay una copia del array en la memoria . Las dos variables contienen la direcci\u00f3n que apunta al array en memoria. Para desreferenciar un array y que apunte a otro array en memoria tenemos que usar el operador new : int [] array = new int [ 5 ] ; int [] otroArray = array ; System . out . println ( Arrays . toString ( array )); System . out . println ( Arrays . toString ( otroArray )); array = new int [] { 1 , 2 , 3 }; otroArray [ 0 ] = 3 ; System . out . println ( Arrays . toString ( array )); System . out . println ( Arrays . toString ( otroArray ));","title":"Tipos de referencia vs tipos de valor"},{"location":"ud4/3referencetypearrays/#metodos-paso-por-referencia","text":"Recuerda que Java usa llamada por valor para pasar datos a m\u00e9todos, esto es que env\u00eda una copia del dato, por tanto cualquier modificaci\u00f3n de la copia dentro del m\u00e9todo no afecta al original. Con par\u00e1metros de tipo array es diferente. Si pasamos a un m\u00e9todo el array, ya que le estamos pasando la referencia al array, crear\u00eda una nueva variable dentro del m\u00e9todo pero \u00e9sta apuntar\u00eda al mismo array en memoria. Cualquier modificaci\u00f3n dentro del m\u00e9todo en el array se ver\u00eda fuera del m\u00e9todo puesto que solo hay un objeto array en memoria.","title":"M\u00e9todos: paso por referencia"},{"location":"ud4/4arrayobjects/","text":"Array de objetos Una caracter\u00edstica importante de los arrays, es que todos los elementos deben ser del mismo tipo. Hasta ahora, hemos estudiado arrays con elementos de tipos primitivos. Sin embargo, tambi\u00e9n se puede crear arrays con elementos de cualquier tipo de datos, incluidas las referencias a objetos. Recordemos que, cuando hacemos String str; , se declara una variable llamada str que almacena la referencia a un objeto de tipo String, pero el objeto todav\u00eda no ha sido creado. Un objeto existe solo despu\u00e9s de haber sido construido. Los objetos se construyen solo mientras se ejecuta un programa cuando se invoca el constructor . Una vez construido, se accede a un objeto siguiendo una referencia al objeto. A menudo, la referencia se mantiene en una variable de referencia como str . En el siguiente ejemplo, se declara una variable de referencia, se construye un objeto y luego la referencia al objeto se coloca en la variable de referencia: String str ; // declara una variable de tipo referencia str = \"Hello World\" ; // construye el objeto y // almacena su referencia Array de Strings Para declarar un array de Strings ser realizar\u00eda de la siguiente forma: String [] array = new String [ 5 ] ; array [ 0 ] = \"Hello\" ; array [ 1 ] = \"World\" ; ... Cada objeto String del ejemplo es un String normal. Nada en \u00e9l ha cambiado porque su referencia se mantiene en el array. Cada cadena puede tener cualquier n\u00famero de caracteres. Argumentos de l\u00ednea de comandos Como ya sabemos el m\u00e9todo main recibe un array de Strings como par\u00e1metro: public static void main ( String [] args ) { } Es decir, main recibe una referencia a un array de referencias de String. Este array es construido por el sistema Java justo antes de que main() obtenga el control. Los elementos que contiene el array son cadenas de texto que se pasan en la l\u00ednea de comando que inicia el programa. Por ejemplo, digamos que un programa se inicia con esta l\u00ednea de comando: java Demo cadena1 cadena1 Donde Demo es el nombre del programa, cadena1 es el primer argumento y cadena2 el segudno. Por tanto args[0] contendr\u00e1 cadena1 y args[1] cadena2. Puede haber cualquier n\u00famero de argumentos en la l\u00ednea de comandos. Los argumentos son siempre cadenas de caracteres. Cada argumento est\u00e1 separado del resto por espacios. A veces, se quieren enviar n\u00famero por l\u00ednea de comandos. Por tanto necesitaremos convertir las cadenas de d\u00edgitos en n\u00fameros. Para ello, utilizaremos el m\u00e9todo Integer.parseInt(String) o Double.parseDouble(String) . Espacio de memoria en arrays de objetos Como hemos comentado, en arrays de objetos, Java almacena solo la referencia al objeto en el propio array, en lugar de todo el objeto. Esto conserva la memoria, ya que las referencias requieren solo 4 bytes cada una, mientras que cada objeto puede requerir cientos de bytes. Ejemplo, para un array de 15 enteros, sabiendo que cada entero requiere 4 bytes de almacenamiento, se almacenar\u00e1 60 bytes contiguos de memoria.","title":"4.4- Array de objetos"},{"location":"ud4/4arrayobjects/#array-de-objetos","text":"Una caracter\u00edstica importante de los arrays, es que todos los elementos deben ser del mismo tipo. Hasta ahora, hemos estudiado arrays con elementos de tipos primitivos. Sin embargo, tambi\u00e9n se puede crear arrays con elementos de cualquier tipo de datos, incluidas las referencias a objetos. Recordemos que, cuando hacemos String str; , se declara una variable llamada str que almacena la referencia a un objeto de tipo String, pero el objeto todav\u00eda no ha sido creado. Un objeto existe solo despu\u00e9s de haber sido construido. Los objetos se construyen solo mientras se ejecuta un programa cuando se invoca el constructor . Una vez construido, se accede a un objeto siguiendo una referencia al objeto. A menudo, la referencia se mantiene en una variable de referencia como str . En el siguiente ejemplo, se declara una variable de referencia, se construye un objeto y luego la referencia al objeto se coloca en la variable de referencia: String str ; // declara una variable de tipo referencia str = \"Hello World\" ; // construye el objeto y // almacena su referencia","title":"Array de objetos"},{"location":"ud4/4arrayobjects/#array-de-strings","text":"Para declarar un array de Strings ser realizar\u00eda de la siguiente forma: String [] array = new String [ 5 ] ; array [ 0 ] = \"Hello\" ; array [ 1 ] = \"World\" ; ... Cada objeto String del ejemplo es un String normal. Nada en \u00e9l ha cambiado porque su referencia se mantiene en el array. Cada cadena puede tener cualquier n\u00famero de caracteres.","title":"Array de Strings"},{"location":"ud4/4arrayobjects/#argumentos-de-linea-de-comandos","text":"Como ya sabemos el m\u00e9todo main recibe un array de Strings como par\u00e1metro: public static void main ( String [] args ) { } Es decir, main recibe una referencia a un array de referencias de String. Este array es construido por el sistema Java justo antes de que main() obtenga el control. Los elementos que contiene el array son cadenas de texto que se pasan en la l\u00ednea de comando que inicia el programa. Por ejemplo, digamos que un programa se inicia con esta l\u00ednea de comando: java Demo cadena1 cadena1 Donde Demo es el nombre del programa, cadena1 es el primer argumento y cadena2 el segudno. Por tanto args[0] contendr\u00e1 cadena1 y args[1] cadena2. Puede haber cualquier n\u00famero de argumentos en la l\u00ednea de comandos. Los argumentos son siempre cadenas de caracteres. Cada argumento est\u00e1 separado del resto por espacios. A veces, se quieren enviar n\u00famero por l\u00ednea de comandos. Por tanto necesitaremos convertir las cadenas de d\u00edgitos en n\u00fameros. Para ello, utilizaremos el m\u00e9todo Integer.parseInt(String) o Double.parseDouble(String) .","title":"Argumentos de l\u00ednea de comandos"},{"location":"ud4/4arrayobjects/#espacio-de-memoria-en-arrays-de-objetos","text":"Como hemos comentado, en arrays de objetos, Java almacena solo la referencia al objeto en el propio array, en lugar de todo el objeto. Esto conserva la memoria, ya que las referencias requieren solo 4 bytes cada una, mientras que cada objeto puede requerir cientos de bytes. Ejemplo, para un array de 15 enteros, sabiendo que cada entero requiere 4 bytes de almacenamiento, se almacenar\u00e1 60 bytes contiguos de memoria.","title":"Espacio de memoria en arrays de objetos"},{"location":"ud4/5sortarrays/","text":"Algoritmos de ordenaci\u00f3n La ordenaci\u00f3n es una de las t\u00e9cnicas fundamentales que se utilizan en la resoluci\u00f3n de problemas, especialmente en los relacionados con la escritura y la implementaci\u00f3n de algoritmos eficientes. Por lo general, la ordenaci\u00f3n se combina con la b\u00fasqueda, lo que significa que primero ordenamos los elementos de la colecci\u00f3n dada, luego buscamos algo dentro de ella, ya que generalmente es m\u00e1s f\u00e1cil buscar algo en una colecci\u00f3n ordenada, en lugar de sin ordenar. Ordenar un array es el proceso de ordenar sus elementos en orden ascendente o descendente. Los algoritmos de ordenaci\u00f3n se encuentran entre los algoritmos m\u00e1s utilizados en computaci\u00f3n. Bubble sort (Burbuja) Funciona intercambiando elementos adyacentes si no est\u00e1n en el orden deseado. Este proceso se repite desde el principio del array hasta que todos los elementos est\u00e1n en orden. Sabemos que todos los elementos est\u00e1n en orden cuando logramos hacer toda la iteraci\u00f3n del array sin intercambiar ning\u00fan elemento en absoluto; entonces, todos los elementos que comparamos estaban en el orden deseado con sus elementos adyacentes y, por extensi\u00f3n, todo el array. Ejemplo: [4, 2, 1, 5, 3] - Paso 1: como 4 > 2, los intercambiamos [2, 4, 1, 5, 3] - Paso 2: como 4 > 1, los intercambiamos [2, 1, 4, 5, 3] - Paso 3: como no se cumple 4 > 5, los dejamos igual [2, 1, 4, 5, 3] - Paso 4: como 5 > 3, los intercambiamos [2, 1, 4, 3, 5] - Este es el resultado del array despu\u00e9s de la primera iteraci\u00f3n del bucle externo. Como al menos se produjo un intercambio durante la primera iteraci\u00f3n (en realidad hubo tres), debemos revisar todo el array otra vez y repetir el mismo proceso. Repetiremos este proceso, hasta que no se realicen m\u00e1s intercambios , que ser\u00e1 cuando tengamos el array ordenado. La raz\u00f3n por la que este algoritmo se llama Bubble sort es porque los n\u00fameros \"burbujean\" hasta la \"superficie\". Si seguimos haciendo trazas en el ejemplo, siguiendo un n\u00famero en particular (4 es un gran ejemplo), ver\u00e1s que se mueve lentamente hacia la derecha durante el proceso. Complejidad temporal Para calcular la complejidad temporal de Bubble Sort, necesitamos mirar el peor escenario posible. \u00bfCu\u00e1l es la cantidad m\u00e1xima de veces que necesitamos pasar por todo el array antes de ordenarlo? El peor escenario ser\u00eda [5, 4, 3, 2, 1] . En la primera iteraci\u00f3n, 5 \"burbujear\u00e1 hasta la superficie\", pero el resto de los elementos permanecer\u00e1n en orden descendente. Tendr\u00edamos que hacer una iteraci\u00f3n para cada elemento excepto 1, y luego otra iteraci\u00f3n para verificar que todo est\u00e9 en orden, por lo que un total de 5 iteraciones. Si pensamos en un array de n elementos, eso significa que necesitamos hacer n iteraciones. Cada una de esas n veces estamos iterando a trav\u00e9s de todo el array, lo que significa que la complejidad temporal en el peor de los casos ser\u00eda Big-O: O(n^2). Counting sort El ordenamiento por conteo es un algoritmo de ordenamiento que ordena los elementos de un array contando el n\u00famero de apariciones de cada elemento \u00fanico en el array. El recuento se almacena en un array auxiliar y la ordenaci\u00f3n se realiza mapeando la cuenta como un \u00edndice del array auxiliar. \u00bfC\u00f3mo funciona? Encuentra el elemento m\u00e1ximo max del array dado. Crea un array de longitud max + 1 con todos los elementos a 0. Este array se utiliza para almacenar el recuento de los elementos del array. Almacena el recuento de cada elemento en su \u00edndice respectivo en el array de recuento. Por ejemplo: si el elemento 3 aparece 2 veces en el array, entonces 2 se almacena en la tercera posici\u00f3n del array de recuentos. Si el elemento \"5\" no est\u00e1 presente en el array, entonces 0 se almacena en la quinta posici\u00f3n. Almacena la suma acumulativa de los elementos del array de recuentos. Es \u00fatil colocar los elementos en el \u00edndice correcto del array ordenado. Encuentra el \u00edndice de cada elemento del array original en el array de conteo. Esto da el recuento acumulativo. Coloca el elemento en el \u00edndice calculado como se muestra en la figura siguiente. Despu\u00e9s de colocar el elemento en la posici\u00f3n correcta del array ordenado, disminuye el array de recuento para ese \u00edndice en uno. Complejidad La complejidad temporal en el peor caso es Big-O: O(n).","title":"4.5- Algoritmos de ordenaci\u00f3n"},{"location":"ud4/5sortarrays/#algoritmos-de-ordenacion","text":"La ordenaci\u00f3n es una de las t\u00e9cnicas fundamentales que se utilizan en la resoluci\u00f3n de problemas, especialmente en los relacionados con la escritura y la implementaci\u00f3n de algoritmos eficientes. Por lo general, la ordenaci\u00f3n se combina con la b\u00fasqueda, lo que significa que primero ordenamos los elementos de la colecci\u00f3n dada, luego buscamos algo dentro de ella, ya que generalmente es m\u00e1s f\u00e1cil buscar algo en una colecci\u00f3n ordenada, en lugar de sin ordenar. Ordenar un array es el proceso de ordenar sus elementos en orden ascendente o descendente. Los algoritmos de ordenaci\u00f3n se encuentran entre los algoritmos m\u00e1s utilizados en computaci\u00f3n.","title":"Algoritmos de ordenaci\u00f3n"},{"location":"ud4/5sortarrays/#bubble-sort-burbuja","text":"Funciona intercambiando elementos adyacentes si no est\u00e1n en el orden deseado. Este proceso se repite desde el principio del array hasta que todos los elementos est\u00e1n en orden. Sabemos que todos los elementos est\u00e1n en orden cuando logramos hacer toda la iteraci\u00f3n del array sin intercambiar ning\u00fan elemento en absoluto; entonces, todos los elementos que comparamos estaban en el orden deseado con sus elementos adyacentes y, por extensi\u00f3n, todo el array. Ejemplo: [4, 2, 1, 5, 3] - Paso 1: como 4 > 2, los intercambiamos [2, 4, 1, 5, 3] - Paso 2: como 4 > 1, los intercambiamos [2, 1, 4, 5, 3] - Paso 3: como no se cumple 4 > 5, los dejamos igual [2, 1, 4, 5, 3] - Paso 4: como 5 > 3, los intercambiamos [2, 1, 4, 3, 5] - Este es el resultado del array despu\u00e9s de la primera iteraci\u00f3n del bucle externo. Como al menos se produjo un intercambio durante la primera iteraci\u00f3n (en realidad hubo tres), debemos revisar todo el array otra vez y repetir el mismo proceso. Repetiremos este proceso, hasta que no se realicen m\u00e1s intercambios , que ser\u00e1 cuando tengamos el array ordenado. La raz\u00f3n por la que este algoritmo se llama Bubble sort es porque los n\u00fameros \"burbujean\" hasta la \"superficie\". Si seguimos haciendo trazas en el ejemplo, siguiendo un n\u00famero en particular (4 es un gran ejemplo), ver\u00e1s que se mueve lentamente hacia la derecha durante el proceso.","title":"Bubble sort (Burbuja)"},{"location":"ud4/5sortarrays/#complejidad-temporal","text":"Para calcular la complejidad temporal de Bubble Sort, necesitamos mirar el peor escenario posible. \u00bfCu\u00e1l es la cantidad m\u00e1xima de veces que necesitamos pasar por todo el array antes de ordenarlo? El peor escenario ser\u00eda [5, 4, 3, 2, 1] . En la primera iteraci\u00f3n, 5 \"burbujear\u00e1 hasta la superficie\", pero el resto de los elementos permanecer\u00e1n en orden descendente. Tendr\u00edamos que hacer una iteraci\u00f3n para cada elemento excepto 1, y luego otra iteraci\u00f3n para verificar que todo est\u00e9 en orden, por lo que un total de 5 iteraciones. Si pensamos en un array de n elementos, eso significa que necesitamos hacer n iteraciones. Cada una de esas n veces estamos iterando a trav\u00e9s de todo el array, lo que significa que la complejidad temporal en el peor de los casos ser\u00eda Big-O: O(n^2).","title":"Complejidad temporal"},{"location":"ud4/5sortarrays/#counting-sort","text":"El ordenamiento por conteo es un algoritmo de ordenamiento que ordena los elementos de un array contando el n\u00famero de apariciones de cada elemento \u00fanico en el array. El recuento se almacena en un array auxiliar y la ordenaci\u00f3n se realiza mapeando la cuenta como un \u00edndice del array auxiliar.","title":"Counting sort"},{"location":"ud4/5sortarrays/#como-funciona","text":"Encuentra el elemento m\u00e1ximo max del array dado. Crea un array de longitud max + 1 con todos los elementos a 0. Este array se utiliza para almacenar el recuento de los elementos del array. Almacena el recuento de cada elemento en su \u00edndice respectivo en el array de recuento. Por ejemplo: si el elemento 3 aparece 2 veces en el array, entonces 2 se almacena en la tercera posici\u00f3n del array de recuentos. Si el elemento \"5\" no est\u00e1 presente en el array, entonces 0 se almacena en la quinta posici\u00f3n. Almacena la suma acumulativa de los elementos del array de recuentos. Es \u00fatil colocar los elementos en el \u00edndice correcto del array ordenado. Encuentra el \u00edndice de cada elemento del array original en el array de conteo. Esto da el recuento acumulativo. Coloca el elemento en el \u00edndice calculado como se muestra en la figura siguiente. Despu\u00e9s de colocar el elemento en la posici\u00f3n correcta del array ordenado, disminuye el array de recuento para ese \u00edndice en uno.","title":"\u00bfC\u00f3mo funciona?"},{"location":"ud4/5sortarrays/#complejidad","text":"La complejidad temporal en el peor caso es Big-O: O(n).","title":"Complejidad"},{"location":"ud4/6searcharrays/","text":"Algoritmos de b\u00fasqueda Supongamos que tenemos un array de grandes dimensiones y necesitamos encontrar uno de sus elementos. Necesitamos un algoritmo para buscar en el array un valor particular, generalmente llamado clave . Si los elementos del array no est\u00e1n organizados en ning\u00fan orden en particular, la \u00fanica forma en que podemos estar seguros de encontrar la clave, asumiendo que est\u00e1 en el array, es buscar cada elemento, comenzando por el primer elemento, hasta encontrarlo. Este algoritmo es conocido como b\u00fasqueda lineal o secuencial . B\u00fasqueda secuencial En la b\u00fasqueda secuencial, cada elemento del array se examinar\u00e1 en secuencia hasta que se encuentre la clave (o se llegue al final del array). Algoritmo b\u00fasqueda secuencial Este algoritmo se puede implementar f\u00e1cilmente en un m\u00e9todo que busca un array de enteros, que se pasa como par\u00e1metro del m\u00e9todo y la clave a buscar. Si la clave se encuentra en el array, se devuelve su ubicaci\u00f3n. Si no se encuentra, se devuelve \u22121 para indicar fallo. public class Search { public static int sequentialSearch ( int [] array , int key ) { for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == key ) { return i ; } } return - 1 ; //no lo ha encontrado } } La notaci\u00f3n Big-O de una b\u00fasqueda secuencial es O(n). B\u00fasqueda binaria La b\u00fasqueda binaria es un algoritmo de b\u00fasqueda para encontrar la posici\u00f3n de un elemento en un array ordenado. La b\u00fasqueda binaria solo se puede implementar en una lista ordenada de elementos . Si los elementos no est\u00e1n ordenados, primero debemos ordenarlos. El algoritmo de b\u00fasqueda binaria se puede implementar de dos formas diferentes: M\u00e9todo iterativo M\u00e9todo recursivo. El m\u00e9todo recursivo sigue el enfoque de divide y vencer\u00e1s . \u00bfC\u00f3mo se hace? El array en el que se va a realizar la b\u00fasqueda es. Sea x = 4 el elemento a buscar. Establezce dos punteros low y high en las posiciones m\u00e1s baja y m\u00e1s alta, respectivamente. Encuentra el elemento del medio mid en la mitad del array, es decir, mid = (low + high)/2; array[mid] = 6 . Si x == array[mid] , devuelve mid . De lo contrario, compara el elemento que se va a buscar con m . Si x > array[mid] , comparamos x con el elemento medio de los elementos en el lado derecho de mid . Esto se hace estableciendo low a low = mid + 1 . De lo contrario, comparamos x con el elemento central de los elementos en el lado izquierdo de mid . Esto se hace estableciendo high a high = mid - 1 . Repetimos los pasos 3 a 6 mientras que low sea menor igual que high . x = 4 se ha encontrado. Al m\u00e9todo se le pasa el array , la clave , y las posiciones low y high . La notaci\u00f3n Big-O para la b\u00fasqueda binaria es O(log N).","title":"4.6- Algoritmos de b\u00fasqueda"},{"location":"ud4/6searcharrays/#algoritmos-de-busqueda","text":"Supongamos que tenemos un array de grandes dimensiones y necesitamos encontrar uno de sus elementos. Necesitamos un algoritmo para buscar en el array un valor particular, generalmente llamado clave . Si los elementos del array no est\u00e1n organizados en ning\u00fan orden en particular, la \u00fanica forma en que podemos estar seguros de encontrar la clave, asumiendo que est\u00e1 en el array, es buscar cada elemento, comenzando por el primer elemento, hasta encontrarlo. Este algoritmo es conocido como b\u00fasqueda lineal o secuencial .","title":"Algoritmos de b\u00fasqueda"},{"location":"ud4/6searcharrays/#busqueda-secuencial","text":"En la b\u00fasqueda secuencial, cada elemento del array se examinar\u00e1 en secuencia hasta que se encuentre la clave (o se llegue al final del array).","title":"B\u00fasqueda secuencial"},{"location":"ud4/6searcharrays/#algoritmo-busqueda-secuencial","text":"Este algoritmo se puede implementar f\u00e1cilmente en un m\u00e9todo que busca un array de enteros, que se pasa como par\u00e1metro del m\u00e9todo y la clave a buscar. Si la clave se encuentra en el array, se devuelve su ubicaci\u00f3n. Si no se encuentra, se devuelve \u22121 para indicar fallo. public class Search { public static int sequentialSearch ( int [] array , int key ) { for ( int i = 0 ; i < array . length ; i ++ ) { if ( array [ i ] == key ) { return i ; } } return - 1 ; //no lo ha encontrado } } La notaci\u00f3n Big-O de una b\u00fasqueda secuencial es O(n).","title":"Algoritmo b\u00fasqueda secuencial"},{"location":"ud4/6searcharrays/#busqueda-binaria","text":"La b\u00fasqueda binaria es un algoritmo de b\u00fasqueda para encontrar la posici\u00f3n de un elemento en un array ordenado. La b\u00fasqueda binaria solo se puede implementar en una lista ordenada de elementos . Si los elementos no est\u00e1n ordenados, primero debemos ordenarlos. El algoritmo de b\u00fasqueda binaria se puede implementar de dos formas diferentes: M\u00e9todo iterativo M\u00e9todo recursivo. El m\u00e9todo recursivo sigue el enfoque de divide y vencer\u00e1s .","title":"B\u00fasqueda binaria"},{"location":"ud4/6searcharrays/#como-se-hace","text":"El array en el que se va a realizar la b\u00fasqueda es. Sea x = 4 el elemento a buscar. Establezce dos punteros low y high en las posiciones m\u00e1s baja y m\u00e1s alta, respectivamente. Encuentra el elemento del medio mid en la mitad del array, es decir, mid = (low + high)/2; array[mid] = 6 . Si x == array[mid] , devuelve mid . De lo contrario, compara el elemento que se va a buscar con m . Si x > array[mid] , comparamos x con el elemento medio de los elementos en el lado derecho de mid . Esto se hace estableciendo low a low = mid + 1 . De lo contrario, comparamos x con el elemento central de los elementos en el lado izquierdo de mid . Esto se hace estableciendo high a high = mid - 1 . Repetimos los pasos 3 a 6 mientras que low sea menor igual que high . x = 4 se ha encontrado. Al m\u00e9todo se le pasa el array , la clave , y las posiciones low y high . La notaci\u00f3n Big-O para la b\u00fasqueda binaria es O(log N).","title":"\u00bfC\u00f3mo se hace?"},{"location":"ud4/7twodimensionarray/","text":"Arrays multidimensionales Un array bidimensional o matriz, es un array cuyos componentes son ellos mismos arrays, y es necesario o \u00fatil para ciertos tipos de problemas. Por ejemplo, imagina una clase de 7 estudiantes que tienen un examen cada semana durante 5 semanas. El profesor registra las calificaciones en una tabla. Una celda particular de la tabla se designa por n\u00famero de estudiante y n\u00famero de semana. En Java, una tabla se puede implementar como una matriz 2D. Cada celda de la matriz es una variable que puede contener un valor y funciona como cualquier variable. Al igual que con los arrays unidimensionales, todas las celdas de una matriz 2D son del mismo tipo. El tipo puede ser un tipo primitivo o un tipo de referencia de objeto. Importante: cada celda de la matriz se especifica con un n\u00famero de fila y columna, en ese orden. matriz[fila][col] Al igual que con los arrays unidimensionales, los \u00edndices comienzan en cero. Para acceder a la posici\u00f3n 0,2 lo har\u00edamos con matriz[0][2] y esto devuelve el entero 4. Al igual que con una matriz 1D o un arrar, un \u00edndice de matriz puede ser un literal entero, una variable de tipo entero, un m\u00e9todo que se eval\u00faa como un n\u00famero entero o una expresi\u00f3n aritm\u00e9tica que involucra todas estas cosas: matriz [ 3 ][ j ] = 34 ; suma = matriz [ i ][ j ] + suma [ i ][ j + 1 ] ; value = matriz [ 2 ][ someFunction () ] ; matriz [ 1 ][ 0 ] = matriz [ i + 3 ][ algunaFunci\u00f3n () - 2 ] ; Declaraci\u00f3n de un array 2D o matriz 2D Recordamos que al igual que los arrays unidimensionales, las matrices bidimensionales son objetos. Para declara un array bidimensional se puede crear una lista. La lista debe contener las filas cada una separada por una coma; y cada fila es una lista de valores. Ejemplo: int [][] myArray = { { 8 , 1 , 2 , 2 , 9 }, { 1 , 9 , 4 , 0 , 3 }, { 0 , 3 , 0 , 0 , 7 } }; //tambi\u00e9n se puede hacer as\u00ed int [][] matriz = new int [ 5 ][ 7 ] ; //inicializa todo a 0s Cada fila de una matriz 2D puede tener un n\u00famero diferente de celdas. Si un programa intenta acceder a una celda que no existe, se lanzar\u00e1 una excepci\u00f3n (que generalmente detendr\u00e1 su programa). Hacer una asignaci\u00f3n a una celda que no existe es un error. Longitud de una matriz 2D La longitud de una matriz 2D es el n\u00famero de filas que tiene. Se puede adivinar que \"longitud\" podr\u00eda definirse como un par de n\u00fameros (filas, columnas). Pero el n\u00famero de columnas puede variar de una fila a otra, por lo que esto no funcionar\u00e1. Sin embargo, el n\u00famero de filas no cambia, por lo que funciona como una longitud. Cada fila de una matriz 2D puede tener un n\u00famero diferente de celdas (columnas), por lo que cada fila tiene su propia longitud. Entender mejor los arrays o matrices 2D Un array bidimensional se implementa como un array unidimensionales. La declaracion int [][] myArray; // 1. declara una variable llamada myArray que en el futuro puede hacer referencia a un objeto de matriz. En este punto, no se ha dicho nada sobre el n\u00famero de filas o columnas. Para crear una matriz de 3 filas, har\u00edamos: myArray = new int [3][]; // 2. Ahora myArray hace referencia a un objeto de matriz. El objeto de matriz tiene 3 celdas. Cada celda puede hacer referencia (en el futuro) a una matriz de int, un objeto int []. Sin embargo, ninguna de las celdas se refiere todav\u00eda a un objeto. Se inicializan a nulo. Una forma de crear la fila 0 es esta: myArray[0] = new int [3]; // 3. Esto crea un objeto array 1D y coloca su referencia en la celda 0 de myArray. Las celdas del array 1D se inicializan a 0. Una matriz o array 1D construida previamente se puede asignar a una fila: int [] x = { 0 , 2 }; int [] y = { 0 , 1 , 2 , 3 , 4 }; myArray [ 1 ] = x ; myArray [ 2 ] = y ; // 4. No es necesario que las filas tengan el mismo n\u00famero de celdas. Las declaraciones anteriores construyen la matriz 2D paso a paso. \u00bfC\u00f3mo se podr\u00edan reemplazar las celdas individuales de cada fila dentro de una matriz? Si quisieras reemplazar la fila uno del ejemplo anterior con la siguiente sentencia: myArray [0] = {1, 9, 4}; No funcionar\u00e1. Una lista de inicializadores entre llaves { } solo se puede usar para inicializar una matriz, no para asignarle valores despu\u00e9s de que ya se ha creado y existe. Si has pensado en hacer algo as\u00ed: int [] x = { 1 , 9 , 4 }; // declarar e iniciar x myArray [ 0 ] = x ; // asignar a myArray Esto si funcionar\u00eda, pero no har\u00edamos exactamente lo que se pidi\u00f3 en la pregunta. Es decir, de esta forma reemplazar\u00edamos la antigua fila 0 con una nueva fila. Lo que hacemos es construir un nuevo objeto de matriz 1D (un array) que contiene los valores deseados en sus celdas y luego asigna ese objeto a la fila 0 de myArray . La fila 0 anterior ahora es basura. Lo correcto ser\u00eda recorrer la fila 0 y reemplazar el valor de cada celda.","title":"4.7- Arrays multidimensionales"},{"location":"ud4/7twodimensionarray/#arrays-multidimensionales","text":"Un array bidimensional o matriz, es un array cuyos componentes son ellos mismos arrays, y es necesario o \u00fatil para ciertos tipos de problemas. Por ejemplo, imagina una clase de 7 estudiantes que tienen un examen cada semana durante 5 semanas. El profesor registra las calificaciones en una tabla. Una celda particular de la tabla se designa por n\u00famero de estudiante y n\u00famero de semana. En Java, una tabla se puede implementar como una matriz 2D. Cada celda de la matriz es una variable que puede contener un valor y funciona como cualquier variable. Al igual que con los arrays unidimensionales, todas las celdas de una matriz 2D son del mismo tipo. El tipo puede ser un tipo primitivo o un tipo de referencia de objeto. Importante: cada celda de la matriz se especifica con un n\u00famero de fila y columna, en ese orden. matriz[fila][col] Al igual que con los arrays unidimensionales, los \u00edndices comienzan en cero. Para acceder a la posici\u00f3n 0,2 lo har\u00edamos con matriz[0][2] y esto devuelve el entero 4. Al igual que con una matriz 1D o un arrar, un \u00edndice de matriz puede ser un literal entero, una variable de tipo entero, un m\u00e9todo que se eval\u00faa como un n\u00famero entero o una expresi\u00f3n aritm\u00e9tica que involucra todas estas cosas: matriz [ 3 ][ j ] = 34 ; suma = matriz [ i ][ j ] + suma [ i ][ j + 1 ] ; value = matriz [ 2 ][ someFunction () ] ; matriz [ 1 ][ 0 ] = matriz [ i + 3 ][ algunaFunci\u00f3n () - 2 ] ;","title":"Arrays multidimensionales"},{"location":"ud4/7twodimensionarray/#declaracion-de-un-array-2d-o-matriz-2d","text":"Recordamos que al igual que los arrays unidimensionales, las matrices bidimensionales son objetos. Para declara un array bidimensional se puede crear una lista. La lista debe contener las filas cada una separada por una coma; y cada fila es una lista de valores. Ejemplo: int [][] myArray = { { 8 , 1 , 2 , 2 , 9 }, { 1 , 9 , 4 , 0 , 3 }, { 0 , 3 , 0 , 0 , 7 } }; //tambi\u00e9n se puede hacer as\u00ed int [][] matriz = new int [ 5 ][ 7 ] ; //inicializa todo a 0s Cada fila de una matriz 2D puede tener un n\u00famero diferente de celdas. Si un programa intenta acceder a una celda que no existe, se lanzar\u00e1 una excepci\u00f3n (que generalmente detendr\u00e1 su programa). Hacer una asignaci\u00f3n a una celda que no existe es un error.","title":"Declaraci\u00f3n de un array 2D o matriz 2D"},{"location":"ud4/7twodimensionarray/#longitud-de-una-matriz-2d","text":"La longitud de una matriz 2D es el n\u00famero de filas que tiene. Se puede adivinar que \"longitud\" podr\u00eda definirse como un par de n\u00fameros (filas, columnas). Pero el n\u00famero de columnas puede variar de una fila a otra, por lo que esto no funcionar\u00e1. Sin embargo, el n\u00famero de filas no cambia, por lo que funciona como una longitud. Cada fila de una matriz 2D puede tener un n\u00famero diferente de celdas (columnas), por lo que cada fila tiene su propia longitud.","title":"Longitud de una matriz 2D"},{"location":"ud4/7twodimensionarray/#entender-mejor-los-arrays-o-matrices-2d","text":"Un array bidimensional se implementa como un array unidimensionales. La declaracion int [][] myArray; // 1. declara una variable llamada myArray que en el futuro puede hacer referencia a un objeto de matriz. En este punto, no se ha dicho nada sobre el n\u00famero de filas o columnas. Para crear una matriz de 3 filas, har\u00edamos: myArray = new int [3][]; // 2. Ahora myArray hace referencia a un objeto de matriz. El objeto de matriz tiene 3 celdas. Cada celda puede hacer referencia (en el futuro) a una matriz de int, un objeto int []. Sin embargo, ninguna de las celdas se refiere todav\u00eda a un objeto. Se inicializan a nulo. Una forma de crear la fila 0 es esta: myArray[0] = new int [3]; // 3. Esto crea un objeto array 1D y coloca su referencia en la celda 0 de myArray. Las celdas del array 1D se inicializan a 0. Una matriz o array 1D construida previamente se puede asignar a una fila: int [] x = { 0 , 2 }; int [] y = { 0 , 1 , 2 , 3 , 4 }; myArray [ 1 ] = x ; myArray [ 2 ] = y ; // 4. No es necesario que las filas tengan el mismo n\u00famero de celdas. Las declaraciones anteriores construyen la matriz 2D paso a paso.","title":"Entender mejor los arrays o matrices 2D"},{"location":"ud4/7twodimensionarray/#como-se-podrian-reemplazar-las-celdas-individuales-de-cada-fila-dentro-de-una-matriz","text":"Si quisieras reemplazar la fila uno del ejemplo anterior con la siguiente sentencia: myArray [0] = {1, 9, 4}; No funcionar\u00e1. Una lista de inicializadores entre llaves { } solo se puede usar para inicializar una matriz, no para asignarle valores despu\u00e9s de que ya se ha creado y existe. Si has pensado en hacer algo as\u00ed: int [] x = { 1 , 9 , 4 }; // declarar e iniciar x myArray [ 0 ] = x ; // asignar a myArray Esto si funcionar\u00eda, pero no har\u00edamos exactamente lo que se pidi\u00f3 en la pregunta. Es decir, de esta forma reemplazar\u00edamos la antigua fila 0 con una nueva fila. Lo que hacemos es construir un nuevo objeto de matriz 1D (un array) que contiene los valores deseados en sus celdas y luego asigna ese objeto a la fila 0 de myArray . La fila 0 anterior ahora es basura. Lo correcto ser\u00eda recorrer la fila 0 y reemplazar el valor de cada celda.","title":"\u00bfC\u00f3mo se podr\u00edan reemplazar las celdas individuales de cada fila dentro de una matriz?"},{"location":"ud5/1herencia/","text":"Herencia Cuando tenemos una clase con una serie de caracter\u00edsticas y nuestro programa se actualiza o amplia, tal vez se necesita de una clase con unas caracter\u00edsticas similares, como por ejemplo, Ordenador, posee un ram, cpu, tama\u00f1o de disco, etc. Si ahora queremos a\u00f1adir la clase Tablet Android en nuestro sistema, como posee todas esas caracter\u00edsticas de ordenador adem\u00e1s de algunas espec\u00edficas, copiar\u00edamos todo lo que hay en ordenador y agregar\u00edamos lo que fuera espec\u00edfico para Tablet. Lo mismo tendr\u00edamos que realizar si a\u00f1adi\u00e9ramos P\u00f3rtatil Mac. Como te habr\u00e1s dado cuenta, este proceso genera mucho c\u00f3digo repetido. Y arreglar un error en \u00e9l puede ser tambi\u00e9n complicado. Para ello utilizamos la herencia. \u00bfC\u00f3mo se relacionan las clases entre s\u00ed? En Java, y en cualquier otro lenguaje orientado a objetos, las clases se organizan en una jerarqu\u00eda de clases . Una jerarqu\u00eda de clases es como un \u00e1rbol al rev\u00e9s. En lo m\u00e1s alto de la jerarqu\u00eda se encuentra la clase m\u00e1s general, en Java, la clase Object . Las clases debajo de Object en la jerarqu\u00eda se conocen como sus subclases . Dado que todos los objetos que usamos en nuestros programas pertenecen a una clase u otra, esto es como decir que todos los objetos son Object . En Java, todas las clases heredan de la clase java.lang.Object . La Figura muestra el concepto de jerarqu\u00eda de clases. Observa que la clase Object se encuentra en la parte superior de la jerarqu\u00eda. Es la clase m\u00e1s generalizada. Tiene caracter\u00edsticas que son comunes a todos los objetos Java. A medida que desciende en la jerarqu\u00eda, las clases se vuelven cada vez m\u00e1s espec\u00edficas . Un rect\u00e1ngulo es un objeto, pero contiene atributos (largo y ancho) que son comunes a todos los rect\u00e1ngulos, pero no a otros objetos de la jerarqu\u00eda. Por ejemplo, un objeto Vehicle no tiene necesariamente una longitud y una anchura. Tambi\u00e9n est\u00e1 la clase Square en la jerarqu\u00eda. Un Square (cuadrado) es un tipo especial de rect\u00e1ngulo, es decir, uno cuyo largo es igual a su ancho. Usando la terminolog\u00eda asociada con este tipo de jerarqu\u00eda, decimos que la clase Rectangle es una subclase de la clase Object . La clase Square es una subclase de Rectangle y Object . Se dice que las clases que se encuentran por encima de una clase dada en la jerarqu\u00eda son sus superclases . Por lo tanto, la clase Rectangle y tambi\u00e9n Object es una superclase de la clase Square . En general, decimos que una subclase extiende una superclase, lo que significa que agrega elementos adicionales (atributos y / o m\u00e9todos) a los contenidos en sus superclases. Como el caso de la clase Square que agrega la caracter\u00edstica de que su largo y ancho son siempre iguales. Hay tres conjuntos de terminolog\u00eda para describir las relaciones de herencia: padre / hijo clase base / clase derivada superclase / subclase El concepto importante asociado con una jerarqu\u00eda de clases es la noci\u00f3n de herencia de clases, mediante la cual una subclase hereda elementos (atributos y / o m\u00e9todos, excepto el constructor) de sus superclases. Nota Los atributos y m\u00e9todos declarados como private no se heredan. Para ilustrar c\u00f3mo funciona la herencia pensemos en un ajedrez. Hay varios tipos diferentes de piezas de ajedrez. Hay peones, caballeros, reinas y reyes. Un par de atributos que todas las piezas de ajedrez tienen en com\u00fan es su posici\u00f3n de fila y columna en el tablero de ajedrez. Debido a que todas las piezas de ajedrez tienen estos atributos en com\u00fan, habr\u00e1 una clase en la jerarqu\u00eda superior llamada PiezaAjedrez con estos atributos que ser\u00e1n heredados por todas las subclases de PiezaAjedrez . Una de las acciones que todas las piezas de ajedrez tienen en com\u00fan es que pueden moverse a una casilla determinada del tablero de ajedrez. Pero los diferentes tipos de piezas de ajedrez tienen diferentes formas de moverse. Por ejemplo, un alfil solo puede moverse a lo largo de diagonales en el tablero de ajedrez, mientras que una torre solo puede moverse a lo largo de una fila o columna en el tablero de ajedrez. Entonces, claramente, no podemos describir un m\u00e9todo moveTo() que funcione para todas las piezas de ajedrez. Es por eso que colocamos el m\u00e9todo moveTo() en todas las subclases de PiezaAjedrez . La clase PiezaAjedrez tambi\u00e9n tiene un m\u00e9todo moveTo() , pero tenga en cuenta que su nombre est\u00e1 en cursiva. Esto indica que no se puede definir completamente a ese nivel. En el ajedrez, el rey tiene ciertos atributos y acciones especiales. Por tanto, s\u00f3lo el rey puede ser puesto bajo control. Esto significa que el rey est\u00e1 siendo atacado y en peligro de ser capturado, poniendo fin al juego. Del mismo modo, solo el rey tiene la capacidad de enrocar. Este es un movimiento especial que un rey puede realizar junto con una de sus torres bajo ciertas condiciones. Por lo tanto, la clase Rey tiene ciertas caracter\u00edsticas particulares. En los diagramas, la flecha apunta del hijo al padre y muestra la relaci\u00f3n \"es-un\". La flecha apunta a la clase principal de la clase secundaria. La imagen se puede leer como \"un rey es una pieza de ajedrez\". Como vemos, una jerarqu\u00eda de clases representa una especializaci\u00f3n de clases a medida que avanza de arriba hacia abajo. La clase m\u00e1s general, PiezaAjedrez , est\u00e1 en la parte superior de la jerarqu\u00eda. Sus atributos y m\u00e9todos se transmiten (heredan) sus subclases. Sin embargo, adem\u00e1s de los atributos y m\u00e9todos que heredan de sus superclases, las subclases definen sus propios atributos y m\u00e9todos especiales. Cada una de las subclases, Pe\u00f3n, Alfil, etc., representa alg\u00fan tipo de especializaci\u00f3n de la superclase. Herencia simple En Java, (a diferencia de los humanos) los hijos heredan caracter\u00edsticas de un solo padre. A esto se le llama herencia simple . Aunque algunos lenguajes de programaci\u00f3n permiten que una clase hija herede de m\u00e1s de una clase padre. A esto se le llama herencia m\u00faltiple . Con la herencia m\u00faltiple, a veces es dif\u00edcil saber qu\u00e9 padre contribuy\u00f3 con qu\u00e9 caracter\u00edsticas al hijo. Java evita estos problemas mediante el uso de herencia simple. Una clase padre puede tener m\u00faltiples hijos. La herencia es entre clases, no entre objetos. Sintaxis herencia en Java - extends La sintaxis para heredar de una superclase es: public class Child extends Parent { // los nuevos miembros y constructores de la clase hija van aqu\u00ed } Los miembros (variables y m\u00e9todos) de la clase padre se incluyen autom\u00e1ticamente en el hijo por herencia. Si se quieren agregar miembros adicionales en la clase hija se hace en su definici\u00f3n de clase. Las clases declaradas como final no pueden ser extendidas. Ejemplo clase Animal Vamos a crear una clase base Animal que tendr\u00e1 una serie de caracter\u00edsticas comunes para todos los animales como puede ser, nombre, peso, tama\u00f1o, etc. public class Animal { private String name ; private int size ; private int weight ; public Animal ( String name , int size , int weight ) { this . name = name ; this . size = size ; this . weight = weight ; } //getters y setters } Ahora queremos crear un tipo de animal Dog que contendr\u00e1 todas las caracter\u00edsticas (atributos y m\u00e9todos) de la clase Animal : public class Dog extends Animal { } Cuando creamos una subclase, necesitamos llamar al constructor de la superclase para inicializarla, ya que hereda de ella. As\u00ed que tendremos que crear el constructor en la clase Dog que llame dentro al constructor de la superclase ( Animal ): public class Dog extends Animal { public Dog ( String name , int size , int weight ) { super ( name , size , weight ); } } Al crear una clase hija Dog que hereda de la clase padre Animal , lo que estamos haciendo es heredar todo su comportamiento (atributos y m\u00e9todos) y adem\u00e1s nos permite a\u00f1adir atributos espec\u00edficos y \u00fanicos para esa clase hija que son particulares de los perros y no comunes o aplicables a todos los animales. Super keyword La palabra reservada super se utiliza para llamar al constructor de la clase de la que estamos heredando, es decir, llamar a la clase padre o superclase. En nuestro caso, para invocar al constructor de la superclase Animal . Esto nos permite inicializar la clase Animal , ya que Dog es una clase derivada que se basa en ella. La primera l\u00ednea dentro del constructor de la clase hija debe ser la llamada al constructor padre con super() . Si no se especifica expl\u00edcitamente entonces el compilador Java llama por defecto a super(); , es decir, al constructor por defecto (sin argumentos) de la clase padre. Si el padre no tiene un constructor sin argumentos, entonces provoca un error. Note Si se proporciona un constructor con par\u00e1metros en una clase, el compilador de Java no crear\u00e1 autom\u00e1ticamente el constructor sin par\u00e1metros. En la clase hija vamos a crear algunos campos espec\u00edficos para los perros como ojos, piernas, etc. Porque recuerda que no todos los animales tienen piernas u ojos pero si todos los perros. public class Dog extends Animal { private int eyes ; private int legs ; private int tail ; public Dog ( String name , int size , int weight ) { super ( name , size , weight ); } } Adem\u00e1s de los campos que se necesitan para crear un objeto Animal , tambi\u00e9n hay que inicializar los campos propios de la clase Dog en el constructor: public class Dog extends Animal { private int eyes ; private int legs ; private int tail ; public Dog ( String name , int size , int weight , int eyes , int legs , int tail ) { super ( name , size , weight ); this . eyes = eyes ; this . legs = legs ; this . tail = tail ; } } En la clase base, vamos a a\u00f1adir comportamiento, que ser\u00e1 com\u00fan para todos los animales, comer y moverse: public class Animal { private String name ; private int size ; private int weight ; public Animal ( String name , int size , int weight ) { this . name = name ; this . size = size ; this . weight = weight ; } public void eat () { //c\u00f3digo } public void move () { //c\u00f3digo } } Al hacer esto, y crearlos como public ( protected tambi\u00e9n servir\u00eda), significa que ahora est\u00e1n disponibles en la clase Dog autom\u00e1ticamente. Es decir, el m\u00e9todo eat y move se hereda a la clase Dog . Probar funcionamiento Vamos a probar c\u00f3mo funciona la herencia, para ello creamos un clase Main con un m\u00e9todo main . public static void main ( String [] args ) { Animal animal = new Animal ( \"\" , 0 , 1 ); Dog dog = new Dog ( \"Maxi\" , 2 , 5 , 2 , 4 , 1 ); } Vemos que crear un animal no tiene mucho sentido, puesto que no sabemos mucho sobre \u00e9l. Cuando creamos un perro, podemos ser m\u00e1s espec\u00edficos en nuestra definici\u00f3n y dar valores relativos solo para perros. Adem\u00e1s, desde perro tenemos acceso a los m\u00e9todos definidos en la clase padre ( Animal ) como p\u00fablicos o protected. Por ejemplo, dog.eat() invocar\u00e1 al m\u00e9todo comer que se encuentra en la clase padre, ya que la clase Dog no tiene ning\u00fan m\u00e9todo eat . Sobreescribir m\u00e9todos de la clase padre en los hijos La herencia nos aporta la opci\u00f3n de la sobreescritura de m\u00e9todos. Es decir, redefinir los m\u00e9todos de una clase padre en las clases hijas. Por ejemplo, en la clase Dog podemos sobreescribir el m\u00e9todo eat() con una funcionalidad m\u00e1s espec\u00edfica. El IntelliJ nos ofrece un atajo para sobreescritura de m\u00e9todos. Bot\u00f3n derecho --> Generate... IntelliJ nos muestra todos los m\u00e9todos que est\u00e1n en la clase Animal y podemos sobreescribir: Si seleccionamos el m\u00e9todo eat() , tenemos: public class Dog extends Animal { private int eyes ; private int legs ; private int tail ; public Dog ( String name , int size , int weight , int eyes , int legs , int tail ) { super ( name , size , weight ); this . eyes = eyes ; this . legs = legs ; this . tail = tail ; } @Override public void eat () { super . eat (); //C\u00f3digo que se crea autom\u00e1ticamente y llama al m\u00e9todo eat de la clase padre } } Ahora la clase hija Dog tiene su propio m\u00e9todo eat() con c\u00f3digo espec\u00edfico para esta clase. public class Dog extends Animal { private int eyes ; private int legs ; private int tail ; public Dog ( String name , int years , int weight , int eyes , int legs , int tail ) { super ( name , years , weight ); this . eyes = eyes ; this . legs = legs ; this . tail = tail ; } //M\u00e9todo privado solo de la clase Dog private void chew () { } @Override public void eat () { System . out . println ( \"Dog eat\" ); chew (); super . eat (); } } En t\u00e9rminos de sobreescritura, debemos de llevar cuidado con el m\u00e9todo que se invoca: public class Dog extends Animal { private int eyes ; private int legs ; private int tail ; public Dog ( String name , int years , int weight , int eyes , int legs , int tail ) { super ( name , years , weight ); this . eyes = eyes ; this . legs = legs ; this . tail = tail ; } //M\u00e9todo privado solo de la clase Dog private void chew () { } @Override public void eat () { System . out . println ( \"Dog eat\" ); chew (); super . eat (); } public void walk () { move (); } } Si no sobreescribimos el m\u00e9todo move() en la clase Dog , cuando lo invocamos dentro del m\u00e9todo walk() se llamar\u00eda al m\u00e9todo de la clase Animal .","title":"Concepto de herencia"},{"location":"ud5/1herencia/#herencia","text":"Cuando tenemos una clase con una serie de caracter\u00edsticas y nuestro programa se actualiza o amplia, tal vez se necesita de una clase con unas caracter\u00edsticas similares, como por ejemplo, Ordenador, posee un ram, cpu, tama\u00f1o de disco, etc. Si ahora queremos a\u00f1adir la clase Tablet Android en nuestro sistema, como posee todas esas caracter\u00edsticas de ordenador adem\u00e1s de algunas espec\u00edficas, copiar\u00edamos todo lo que hay en ordenador y agregar\u00edamos lo que fuera espec\u00edfico para Tablet. Lo mismo tendr\u00edamos que realizar si a\u00f1adi\u00e9ramos P\u00f3rtatil Mac. Como te habr\u00e1s dado cuenta, este proceso genera mucho c\u00f3digo repetido. Y arreglar un error en \u00e9l puede ser tambi\u00e9n complicado. Para ello utilizamos la herencia. \u00bfC\u00f3mo se relacionan las clases entre s\u00ed? En Java, y en cualquier otro lenguaje orientado a objetos, las clases se organizan en una jerarqu\u00eda de clases . Una jerarqu\u00eda de clases es como un \u00e1rbol al rev\u00e9s. En lo m\u00e1s alto de la jerarqu\u00eda se encuentra la clase m\u00e1s general, en Java, la clase Object . Las clases debajo de Object en la jerarqu\u00eda se conocen como sus subclases . Dado que todos los objetos que usamos en nuestros programas pertenecen a una clase u otra, esto es como decir que todos los objetos son Object . En Java, todas las clases heredan de la clase java.lang.Object . La Figura muestra el concepto de jerarqu\u00eda de clases. Observa que la clase Object se encuentra en la parte superior de la jerarqu\u00eda. Es la clase m\u00e1s generalizada. Tiene caracter\u00edsticas que son comunes a todos los objetos Java. A medida que desciende en la jerarqu\u00eda, las clases se vuelven cada vez m\u00e1s espec\u00edficas . Un rect\u00e1ngulo es un objeto, pero contiene atributos (largo y ancho) que son comunes a todos los rect\u00e1ngulos, pero no a otros objetos de la jerarqu\u00eda. Por ejemplo, un objeto Vehicle no tiene necesariamente una longitud y una anchura. Tambi\u00e9n est\u00e1 la clase Square en la jerarqu\u00eda. Un Square (cuadrado) es un tipo especial de rect\u00e1ngulo, es decir, uno cuyo largo es igual a su ancho. Usando la terminolog\u00eda asociada con este tipo de jerarqu\u00eda, decimos que la clase Rectangle es una subclase de la clase Object . La clase Square es una subclase de Rectangle y Object . Se dice que las clases que se encuentran por encima de una clase dada en la jerarqu\u00eda son sus superclases . Por lo tanto, la clase Rectangle y tambi\u00e9n Object es una superclase de la clase Square . En general, decimos que una subclase extiende una superclase, lo que significa que agrega elementos adicionales (atributos y / o m\u00e9todos) a los contenidos en sus superclases. Como el caso de la clase Square que agrega la caracter\u00edstica de que su largo y ancho son siempre iguales. Hay tres conjuntos de terminolog\u00eda para describir las relaciones de herencia: padre / hijo clase base / clase derivada superclase / subclase El concepto importante asociado con una jerarqu\u00eda de clases es la noci\u00f3n de herencia de clases, mediante la cual una subclase hereda elementos (atributos y / o m\u00e9todos, excepto el constructor) de sus superclases. Nota Los atributos y m\u00e9todos declarados como private no se heredan. Para ilustrar c\u00f3mo funciona la herencia pensemos en un ajedrez. Hay varios tipos diferentes de piezas de ajedrez. Hay peones, caballeros, reinas y reyes. Un par de atributos que todas las piezas de ajedrez tienen en com\u00fan es su posici\u00f3n de fila y columna en el tablero de ajedrez. Debido a que todas las piezas de ajedrez tienen estos atributos en com\u00fan, habr\u00e1 una clase en la jerarqu\u00eda superior llamada PiezaAjedrez con estos atributos que ser\u00e1n heredados por todas las subclases de PiezaAjedrez . Una de las acciones que todas las piezas de ajedrez tienen en com\u00fan es que pueden moverse a una casilla determinada del tablero de ajedrez. Pero los diferentes tipos de piezas de ajedrez tienen diferentes formas de moverse. Por ejemplo, un alfil solo puede moverse a lo largo de diagonales en el tablero de ajedrez, mientras que una torre solo puede moverse a lo largo de una fila o columna en el tablero de ajedrez. Entonces, claramente, no podemos describir un m\u00e9todo moveTo() que funcione para todas las piezas de ajedrez. Es por eso que colocamos el m\u00e9todo moveTo() en todas las subclases de PiezaAjedrez . La clase PiezaAjedrez tambi\u00e9n tiene un m\u00e9todo moveTo() , pero tenga en cuenta que su nombre est\u00e1 en cursiva. Esto indica que no se puede definir completamente a ese nivel. En el ajedrez, el rey tiene ciertos atributos y acciones especiales. Por tanto, s\u00f3lo el rey puede ser puesto bajo control. Esto significa que el rey est\u00e1 siendo atacado y en peligro de ser capturado, poniendo fin al juego. Del mismo modo, solo el rey tiene la capacidad de enrocar. Este es un movimiento especial que un rey puede realizar junto con una de sus torres bajo ciertas condiciones. Por lo tanto, la clase Rey tiene ciertas caracter\u00edsticas particulares. En los diagramas, la flecha apunta del hijo al padre y muestra la relaci\u00f3n \"es-un\". La flecha apunta a la clase principal de la clase secundaria. La imagen se puede leer como \"un rey es una pieza de ajedrez\". Como vemos, una jerarqu\u00eda de clases representa una especializaci\u00f3n de clases a medida que avanza de arriba hacia abajo. La clase m\u00e1s general, PiezaAjedrez , est\u00e1 en la parte superior de la jerarqu\u00eda. Sus atributos y m\u00e9todos se transmiten (heredan) sus subclases. Sin embargo, adem\u00e1s de los atributos y m\u00e9todos que heredan de sus superclases, las subclases definen sus propios atributos y m\u00e9todos especiales. Cada una de las subclases, Pe\u00f3n, Alfil, etc., representa alg\u00fan tipo de especializaci\u00f3n de la superclase.","title":"Herencia"},{"location":"ud5/1herencia/#herencia-simple","text":"En Java, (a diferencia de los humanos) los hijos heredan caracter\u00edsticas de un solo padre. A esto se le llama herencia simple . Aunque algunos lenguajes de programaci\u00f3n permiten que una clase hija herede de m\u00e1s de una clase padre. A esto se le llama herencia m\u00faltiple . Con la herencia m\u00faltiple, a veces es dif\u00edcil saber qu\u00e9 padre contribuy\u00f3 con qu\u00e9 caracter\u00edsticas al hijo. Java evita estos problemas mediante el uso de herencia simple. Una clase padre puede tener m\u00faltiples hijos. La herencia es entre clases, no entre objetos.","title":"Herencia simple"},{"location":"ud5/1herencia/#sintaxis-herencia-en-java-extends","text":"La sintaxis para heredar de una superclase es: public class Child extends Parent { // los nuevos miembros y constructores de la clase hija van aqu\u00ed } Los miembros (variables y m\u00e9todos) de la clase padre se incluyen autom\u00e1ticamente en el hijo por herencia. Si se quieren agregar miembros adicionales en la clase hija se hace en su definici\u00f3n de clase. Las clases declaradas como final no pueden ser extendidas.","title":"Sintaxis herencia en Java - extends"},{"location":"ud5/1herencia/#ejemplo-clase-animal","text":"Vamos a crear una clase base Animal que tendr\u00e1 una serie de caracter\u00edsticas comunes para todos los animales como puede ser, nombre, peso, tama\u00f1o, etc. public class Animal { private String name ; private int size ; private int weight ; public Animal ( String name , int size , int weight ) { this . name = name ; this . size = size ; this . weight = weight ; } //getters y setters } Ahora queremos crear un tipo de animal Dog que contendr\u00e1 todas las caracter\u00edsticas (atributos y m\u00e9todos) de la clase Animal : public class Dog extends Animal { } Cuando creamos una subclase, necesitamos llamar al constructor de la superclase para inicializarla, ya que hereda de ella. As\u00ed que tendremos que crear el constructor en la clase Dog que llame dentro al constructor de la superclase ( Animal ): public class Dog extends Animal { public Dog ( String name , int size , int weight ) { super ( name , size , weight ); } } Al crear una clase hija Dog que hereda de la clase padre Animal , lo que estamos haciendo es heredar todo su comportamiento (atributos y m\u00e9todos) y adem\u00e1s nos permite a\u00f1adir atributos espec\u00edficos y \u00fanicos para esa clase hija que son particulares de los perros y no comunes o aplicables a todos los animales.","title":"Ejemplo clase Animal"},{"location":"ud5/1herencia/#super-keyword","text":"La palabra reservada super se utiliza para llamar al constructor de la clase de la que estamos heredando, es decir, llamar a la clase padre o superclase. En nuestro caso, para invocar al constructor de la superclase Animal . Esto nos permite inicializar la clase Animal , ya que Dog es una clase derivada que se basa en ella. La primera l\u00ednea dentro del constructor de la clase hija debe ser la llamada al constructor padre con super() . Si no se especifica expl\u00edcitamente entonces el compilador Java llama por defecto a super(); , es decir, al constructor por defecto (sin argumentos) de la clase padre. Si el padre no tiene un constructor sin argumentos, entonces provoca un error. Note Si se proporciona un constructor con par\u00e1metros en una clase, el compilador de Java no crear\u00e1 autom\u00e1ticamente el constructor sin par\u00e1metros. En la clase hija vamos a crear algunos campos espec\u00edficos para los perros como ojos, piernas, etc. Porque recuerda que no todos los animales tienen piernas u ojos pero si todos los perros. public class Dog extends Animal { private int eyes ; private int legs ; private int tail ; public Dog ( String name , int size , int weight ) { super ( name , size , weight ); } } Adem\u00e1s de los campos que se necesitan para crear un objeto Animal , tambi\u00e9n hay que inicializar los campos propios de la clase Dog en el constructor: public class Dog extends Animal { private int eyes ; private int legs ; private int tail ; public Dog ( String name , int size , int weight , int eyes , int legs , int tail ) { super ( name , size , weight ); this . eyes = eyes ; this . legs = legs ; this . tail = tail ; } } En la clase base, vamos a a\u00f1adir comportamiento, que ser\u00e1 com\u00fan para todos los animales, comer y moverse: public class Animal { private String name ; private int size ; private int weight ; public Animal ( String name , int size , int weight ) { this . name = name ; this . size = size ; this . weight = weight ; } public void eat () { //c\u00f3digo } public void move () { //c\u00f3digo } } Al hacer esto, y crearlos como public ( protected tambi\u00e9n servir\u00eda), significa que ahora est\u00e1n disponibles en la clase Dog autom\u00e1ticamente. Es decir, el m\u00e9todo eat y move se hereda a la clase Dog .","title":"Super keyword"},{"location":"ud5/1herencia/#probar-funcionamiento","text":"Vamos a probar c\u00f3mo funciona la herencia, para ello creamos un clase Main con un m\u00e9todo main . public static void main ( String [] args ) { Animal animal = new Animal ( \"\" , 0 , 1 ); Dog dog = new Dog ( \"Maxi\" , 2 , 5 , 2 , 4 , 1 ); } Vemos que crear un animal no tiene mucho sentido, puesto que no sabemos mucho sobre \u00e9l. Cuando creamos un perro, podemos ser m\u00e1s espec\u00edficos en nuestra definici\u00f3n y dar valores relativos solo para perros. Adem\u00e1s, desde perro tenemos acceso a los m\u00e9todos definidos en la clase padre ( Animal ) como p\u00fablicos o protected. Por ejemplo, dog.eat() invocar\u00e1 al m\u00e9todo comer que se encuentra en la clase padre, ya que la clase Dog no tiene ning\u00fan m\u00e9todo eat .","title":"Probar funcionamiento"},{"location":"ud5/1herencia/#sobreescribir-metodos-de-la-clase-padre-en-los-hijos","text":"La herencia nos aporta la opci\u00f3n de la sobreescritura de m\u00e9todos. Es decir, redefinir los m\u00e9todos de una clase padre en las clases hijas. Por ejemplo, en la clase Dog podemos sobreescribir el m\u00e9todo eat() con una funcionalidad m\u00e1s espec\u00edfica. El IntelliJ nos ofrece un atajo para sobreescritura de m\u00e9todos. Bot\u00f3n derecho --> Generate... IntelliJ nos muestra todos los m\u00e9todos que est\u00e1n en la clase Animal y podemos sobreescribir: Si seleccionamos el m\u00e9todo eat() , tenemos: public class Dog extends Animal { private int eyes ; private int legs ; private int tail ; public Dog ( String name , int size , int weight , int eyes , int legs , int tail ) { super ( name , size , weight ); this . eyes = eyes ; this . legs = legs ; this . tail = tail ; } @Override public void eat () { super . eat (); //C\u00f3digo que se crea autom\u00e1ticamente y llama al m\u00e9todo eat de la clase padre } } Ahora la clase hija Dog tiene su propio m\u00e9todo eat() con c\u00f3digo espec\u00edfico para esta clase. public class Dog extends Animal { private int eyes ; private int legs ; private int tail ; public Dog ( String name , int years , int weight , int eyes , int legs , int tail ) { super ( name , years , weight ); this . eyes = eyes ; this . legs = legs ; this . tail = tail ; } //M\u00e9todo privado solo de la clase Dog private void chew () { } @Override public void eat () { System . out . println ( \"Dog eat\" ); chew (); super . eat (); } } En t\u00e9rminos de sobreescritura, debemos de llevar cuidado con el m\u00e9todo que se invoca: public class Dog extends Animal { private int eyes ; private int legs ; private int tail ; public Dog ( String name , int years , int weight , int eyes , int legs , int tail ) { super ( name , years , weight ); this . eyes = eyes ; this . legs = legs ; this . tail = tail ; } //M\u00e9todo privado solo de la clase Dog private void chew () { } @Override public void eat () { System . out . println ( \"Dog eat\" ); chew (); super . eat (); } public void walk () { move (); } } Si no sobreescribimos el m\u00e9todo move() en la clase Dog , cuando lo invocamos dentro del m\u00e9todo walk() se llamar\u00eda al m\u00e9todo de la clase Animal .","title":"Sobreescribir m\u00e9todos de la clase padre en los hijos"},{"location":"ud5/1thisvssuper/","text":"This vs Super La palabra reservada super se usa para acceder a los miembros (atributos y m\u00e9todos) de la clase padre. La palabra reservada this se utiliza para acceder a los miembros (atributos y m\u00e9todos) de la clase actual en la que se usa. Las dos palabras pueden usarse en cualquier lugar excepto en bloques de c\u00f3digo est\u00e1tico. This this es generalmente usada en constructores y en los m\u00e9todos setters, y opcionalmente en los getters ya que no tenemos par\u00e1metro de entrada con el mismo nombre: public class Coche { private int ruedas ; public Coche ( int ruedas ) { this . ruedas = ruedas ; } public void setRuedas ( int ruedas ) { this . ruedas = ruedas ; } public int getRuedas () { return ruedas ; } } Super super es generalmente usada en sobreescritura de m\u00e9todos al usar herencia. Es decir, se utiliza para llamar desde las clases hijas al m\u00e9todo con el mismo nombre en la clase padre. @Override public void eat () { System . out . println ( \"Dog eat\" ); chew (); super . eat (); } Sin la palabra reservada super , se producir\u00eda una llamada recursiva al mismo m\u00e9todo de forma infinita. this() Usamos this() en forma de m\u00e9todo dentro del cuerpo de un constructor cuando queremos invocar a otro constructor sobrecargado dentro de la misma clase. this() solo puede usarse en un constructor; y debe de ser la primera sentencia que aparece en el constructor. super() Usamos super() en forma de m\u00e9todo dentro del cuerpo de un constructor cuando queremos invocar a un constructor de la clase padre. super() solo puede usarse en un constructor; y debe de ser la primera sentencia que aparece en el constructor. Recordemos que el compilador de Java agrega de forma autom\u00e1tica la sentencia super() en el constructor de la clase hija si nosotros no lo a\u00f1adimos. Note Un constructor puede tener las sentencias this() o super() pero nunca ambas. En el siguiente ejemplo, usamos las dos sentencias: class Transporte { private int puertas ; private int precio ; public Transporte ( int puertas , int precio ) { this . puertas = puertas ; this . precio = precio ; } } public class Coche extends Transporte { private String modelo ; private String marca ; public Coche ( String modelo , String marca ) { this ( 0 , 0 , modelo , marca ); } public Coche ( int puertas , int precio , String modelo , String marca ) { super ( puertas , precio ); this . modelo = modelo ; this . marca = marca ; } }","title":"This vs super"},{"location":"ud5/1thisvssuper/#this-vs-super","text":"La palabra reservada super se usa para acceder a los miembros (atributos y m\u00e9todos) de la clase padre. La palabra reservada this se utiliza para acceder a los miembros (atributos y m\u00e9todos) de la clase actual en la que se usa. Las dos palabras pueden usarse en cualquier lugar excepto en bloques de c\u00f3digo est\u00e1tico.","title":"This vs Super"},{"location":"ud5/1thisvssuper/#this","text":"this es generalmente usada en constructores y en los m\u00e9todos setters, y opcionalmente en los getters ya que no tenemos par\u00e1metro de entrada con el mismo nombre: public class Coche { private int ruedas ; public Coche ( int ruedas ) { this . ruedas = ruedas ; } public void setRuedas ( int ruedas ) { this . ruedas = ruedas ; } public int getRuedas () { return ruedas ; } }","title":"This"},{"location":"ud5/1thisvssuper/#super","text":"super es generalmente usada en sobreescritura de m\u00e9todos al usar herencia. Es decir, se utiliza para llamar desde las clases hijas al m\u00e9todo con el mismo nombre en la clase padre. @Override public void eat () { System . out . println ( \"Dog eat\" ); chew (); super . eat (); } Sin la palabra reservada super , se producir\u00eda una llamada recursiva al mismo m\u00e9todo de forma infinita.","title":"Super"},{"location":"ud5/1thisvssuper/#this_1","text":"Usamos this() en forma de m\u00e9todo dentro del cuerpo de un constructor cuando queremos invocar a otro constructor sobrecargado dentro de la misma clase. this() solo puede usarse en un constructor; y debe de ser la primera sentencia que aparece en el constructor.","title":"this()"},{"location":"ud5/1thisvssuper/#super_1","text":"Usamos super() en forma de m\u00e9todo dentro del cuerpo de un constructor cuando queremos invocar a un constructor de la clase padre. super() solo puede usarse en un constructor; y debe de ser la primera sentencia que aparece en el constructor. Recordemos que el compilador de Java agrega de forma autom\u00e1tica la sentencia super() en el constructor de la clase hija si nosotros no lo a\u00f1adimos. Note Un constructor puede tener las sentencias this() o super() pero nunca ambas. En el siguiente ejemplo, usamos las dos sentencias: class Transporte { private int puertas ; private int precio ; public Transporte ( int puertas , int precio ) { this . puertas = puertas ; this . precio = precio ; } } public class Coche extends Transporte { private String modelo ; private String marca ; public Coche ( String modelo , String marca ) { this ( 0 , 0 , modelo , marca ); } public Coche ( int puertas , int precio , String modelo , String marca ) { super ( puertas , precio ); this . modelo = modelo ; this . marca = marca ; } }","title":"super()"},{"location":"ud5/2composicion/","text":"Composici\u00f3n La composici\u00f3n es otro componente de la programaci\u00f3n orientada a objetos y es muy utilizada. Es el mecanismo en el cual una clase se construye a partir de otros objetos de igual o distinto tipo, pudi\u00e9ndolos combinar para obtener la funcionalidad deseada. En la composici\u00f3n la nueva clase, mantiene una relaci\u00f3n \u201cUsa/Tiene un\u201d, con los objetos que son parte de la clase. Vamos a ver un ejemplo de la clase Car que extiende Vehicle : public class Vehicle { private String name ; } public class Car extends Vehicle { private int doors ; private int seats ; public Car ( int doors , int seats ) { this . doors = doors ; this . seats = seats ; } } Estas dos clases tienen una relaci\u00f3n de herencia, el significado es que un coche es un veh\u00edculo. Pero la composici\u00f3n es diferente a la herencia tambi\u00e9n es un tipo de relaci\u00f3n. Por ejemplo, pensemos en un ordenador. Un ordenador se compone de una CPU, pantalla, rat\u00f3n y teclado. Pero una pantalla no es un ordenador, un rat\u00f3n no es un ordenador. Decimos que un ordenador tiene una pantalla, un ordenador tiene un teclado, etc. Eso es la composici\u00f3n, un todo que se construye con partes. Vamos a ver como se implementa esto: public class Procesador { private String modelo ; private int ramSlots ; private int cardSlots ; public Procesador ( String modelo , int ramSlots , int cardSlots ) { this . modelo = modelo ; this . ramSlots = ramSlots ; this . cardSlots = cardSlots ; } public void presionarBotonEncendido () { System . out . println ( \"Iniciando el pc\" ); } public void cargarPrograma ( String nombre ) { System . out . println ( nombre ); } public String getModelo () { return modelo ; } public void setModelo ( String modelo ) { this . modelo = modelo ; } public int getRamSlots () { return ramSlots ; } public void setRamSlots ( int ramSlots ) { this . ramSlots = ramSlots ; } public int getCardSlots () { return cardSlots ; } public void setCardSlots ( int cardSlots ) { this . cardSlots = cardSlots ; } } public class Monitor { private String modelo ; private String resolucion ; private int tam ; public Monitor ( String modelo , String resolucion , int tam ) { this . modelo = modelo ; this . resolucion = resolucion ; this . tam = tam ; } public void dibujarPixel ( int x , int y ) { System . out . println ( \"Pixel en \" + x + y ); } public String getModelo () { return modelo ; } public void setModelo ( String modelo ) { this . modelo = modelo ; } public String getResolucion () { return resolucion ; } public void setResolucion ( String resolucion ) { this . resolucion = resolucion ; } public int getTam () { return tam ; } public void setTam ( int tam ) { this . tam = tam ; } } public class Teclado { private String color ; private int teclas ; public Teclado ( String color , int teclas ) { this . color = color ; this . teclas = teclas ; } public void pushKey ( char key ) { System . out . println ( \"Se ha presionado la tecla \" + key ); } public String getColor () { return color ; } public void setColor ( String color ) { this . color = color ; } public int getTeclas () { return teclas ; } public void setTeclas ( int teclas ) { this . teclas = teclas ; } } Hemos creado las clases Monitor , Teclado y Procesador . Ahora vamos a crear una clase Ordenador que se compondr\u00e1n de las otras tres clases de la forma: public class Ordenador { private Procesador procesador ; private Teclado teclado ; private Monitor monitor ; public Ordenador ( Procesador procesador , Teclado teclado , Monitor monitor ) { this . procesador = procesador ; this . teclado = teclado ; this . monitor = monitor ; } public Procesador getProcesador () { return procesador ; } public void setProcesador ( Procesador procesador ) { this . procesador = procesador ; } public Teclado getTeclado () { return teclado ; } public void setTeclado ( Teclado teclado ) { this . teclado = teclado ; } public Monitor getMonitor () { return monitor ; } public void setMonitor ( Monitor monitor ) { this . monitor = monitor ; } } Ya hemos implementado nuestras clases que componen un Ordenador . Ahora vamos a ver como utilizarlas: public class Main { public static void main ( String [] args ) { Procesador procesador = new Procesador ( \"Intel\" , 2 , 3 ); Monitor monitor = new Monitor ( \"Philips\" , \"1024x900\" , 24 ); Teclado teclado = new Teclado ( \"Negror\" , 90 ); Ordenador ordenador = new Ordenador ( procesador , teclado , monitor ); } } Se ha creado un objeto de la clase Ordenador a partir de las otras clases. En herencia ten\u00edamos acceso a los atributos de la clase padre, pero ahora con composici\u00f3n para acceder a los m\u00e9todos o atributos de las partes a partir de Ordenador lo haremos usando los m\u00e9todos getters que tenemos en la clase y nos permite acceder a Teclado , Monitor y Procesador . public static void main ( String [] args ) { Procesador procesador = new Procesador ( \"Intel\" , 2 , 3 ); Monitor monitor = new Monitor ( \"Philips\" , \"1024x900\" , 24 ); Teclado teclado = new Teclado ( \"Negror\" , 90 ); Ordenador ordenador = new Ordenador ( procesador , teclado , monitor ); ordenador . getMonitor (). dibujarPixel ( 34 , 56 ); ordenador . getProcesador (). cargarPrograma ( \"Demo\" ); ordenador . getTeclado (). pushKey ( 'X' ); } Ocultar funcionalidad de los objetos parte Otro escenario viable es el cual nos permita ocultar la funcionalidad, y no le permitamos al programa acceder directamente a los objetos que componen el todo. Para ello, lo primero que haremos ser\u00e1 modificar la visibilidad de los getters y ponerlos private , de manera que no se pueda acceder desde fuera a Teclado , Monitor o Procesador pero si podamos acceder internamente. public class Ordenador { private Procesador procesador ; private Teclado teclado ; private Monitor monitor ; public Ordenador ( Procesador procesador , Teclado teclado , Monitor monitor ) { this . procesador = procesador ; this . teclado = teclado ; this . monitor = monitor ; } private Procesador getProcesador () { return procesador ; } private Teclado getTeclado () { return teclado ; } private Monitor getMonitor () { return monitor ; } } Una vez oculta la informaci\u00f3n veamos como podemos acceder a ella en el main. Creamos un m\u00e9todo en la clase Ordenador que acceder\u00e1 a las distintas partes. public class Ordenador { private Procesador procesador ; private Teclado teclado ; private Monitor monitor ; public Ordenador ( Procesador procesador , Teclado teclado , Monitor monitor ) { this . procesador = procesador ; this . teclado = teclado ; this . monitor = monitor ; } public void encender () { getProcesador (). presionarBotonEncendido (); dibujarLogo (); } private void dibujarLogo () { monitor . dibujarPixel ( 12 , 23 ); } private Procesador getProcesador () { return procesador ; } private Teclado getTeclado () { return teclado ; } private Monitor getMonitor () { return monitor ; } } En el main accederemos a este m\u00e9todo: public static void main ( String [] args ) { Procesador procesador = new Procesador ( \"Intel\" , 2 , 3 ); Monitor monitor = new Monitor ( \"Philips\" , \"1024x900\" , 24 ); Teclado teclado = new Teclado ( \"Negror\" , 90 ); Ordenador ordenador = new Ordenador ( procesador , teclado , monitor ); ordenador . encender (); }","title":"5.2 Composici\u00f3n"},{"location":"ud5/2composicion/#composicion","text":"La composici\u00f3n es otro componente de la programaci\u00f3n orientada a objetos y es muy utilizada. Es el mecanismo en el cual una clase se construye a partir de otros objetos de igual o distinto tipo, pudi\u00e9ndolos combinar para obtener la funcionalidad deseada. En la composici\u00f3n la nueva clase, mantiene una relaci\u00f3n \u201cUsa/Tiene un\u201d, con los objetos que son parte de la clase. Vamos a ver un ejemplo de la clase Car que extiende Vehicle : public class Vehicle { private String name ; } public class Car extends Vehicle { private int doors ; private int seats ; public Car ( int doors , int seats ) { this . doors = doors ; this . seats = seats ; } } Estas dos clases tienen una relaci\u00f3n de herencia, el significado es que un coche es un veh\u00edculo. Pero la composici\u00f3n es diferente a la herencia tambi\u00e9n es un tipo de relaci\u00f3n. Por ejemplo, pensemos en un ordenador. Un ordenador se compone de una CPU, pantalla, rat\u00f3n y teclado. Pero una pantalla no es un ordenador, un rat\u00f3n no es un ordenador. Decimos que un ordenador tiene una pantalla, un ordenador tiene un teclado, etc. Eso es la composici\u00f3n, un todo que se construye con partes. Vamos a ver como se implementa esto: public class Procesador { private String modelo ; private int ramSlots ; private int cardSlots ; public Procesador ( String modelo , int ramSlots , int cardSlots ) { this . modelo = modelo ; this . ramSlots = ramSlots ; this . cardSlots = cardSlots ; } public void presionarBotonEncendido () { System . out . println ( \"Iniciando el pc\" ); } public void cargarPrograma ( String nombre ) { System . out . println ( nombre ); } public String getModelo () { return modelo ; } public void setModelo ( String modelo ) { this . modelo = modelo ; } public int getRamSlots () { return ramSlots ; } public void setRamSlots ( int ramSlots ) { this . ramSlots = ramSlots ; } public int getCardSlots () { return cardSlots ; } public void setCardSlots ( int cardSlots ) { this . cardSlots = cardSlots ; } } public class Monitor { private String modelo ; private String resolucion ; private int tam ; public Monitor ( String modelo , String resolucion , int tam ) { this . modelo = modelo ; this . resolucion = resolucion ; this . tam = tam ; } public void dibujarPixel ( int x , int y ) { System . out . println ( \"Pixel en \" + x + y ); } public String getModelo () { return modelo ; } public void setModelo ( String modelo ) { this . modelo = modelo ; } public String getResolucion () { return resolucion ; } public void setResolucion ( String resolucion ) { this . resolucion = resolucion ; } public int getTam () { return tam ; } public void setTam ( int tam ) { this . tam = tam ; } } public class Teclado { private String color ; private int teclas ; public Teclado ( String color , int teclas ) { this . color = color ; this . teclas = teclas ; } public void pushKey ( char key ) { System . out . println ( \"Se ha presionado la tecla \" + key ); } public String getColor () { return color ; } public void setColor ( String color ) { this . color = color ; } public int getTeclas () { return teclas ; } public void setTeclas ( int teclas ) { this . teclas = teclas ; } } Hemos creado las clases Monitor , Teclado y Procesador . Ahora vamos a crear una clase Ordenador que se compondr\u00e1n de las otras tres clases de la forma: public class Ordenador { private Procesador procesador ; private Teclado teclado ; private Monitor monitor ; public Ordenador ( Procesador procesador , Teclado teclado , Monitor monitor ) { this . procesador = procesador ; this . teclado = teclado ; this . monitor = monitor ; } public Procesador getProcesador () { return procesador ; } public void setProcesador ( Procesador procesador ) { this . procesador = procesador ; } public Teclado getTeclado () { return teclado ; } public void setTeclado ( Teclado teclado ) { this . teclado = teclado ; } public Monitor getMonitor () { return monitor ; } public void setMonitor ( Monitor monitor ) { this . monitor = monitor ; } } Ya hemos implementado nuestras clases que componen un Ordenador . Ahora vamos a ver como utilizarlas: public class Main { public static void main ( String [] args ) { Procesador procesador = new Procesador ( \"Intel\" , 2 , 3 ); Monitor monitor = new Monitor ( \"Philips\" , \"1024x900\" , 24 ); Teclado teclado = new Teclado ( \"Negror\" , 90 ); Ordenador ordenador = new Ordenador ( procesador , teclado , monitor ); } } Se ha creado un objeto de la clase Ordenador a partir de las otras clases. En herencia ten\u00edamos acceso a los atributos de la clase padre, pero ahora con composici\u00f3n para acceder a los m\u00e9todos o atributos de las partes a partir de Ordenador lo haremos usando los m\u00e9todos getters que tenemos en la clase y nos permite acceder a Teclado , Monitor y Procesador . public static void main ( String [] args ) { Procesador procesador = new Procesador ( \"Intel\" , 2 , 3 ); Monitor monitor = new Monitor ( \"Philips\" , \"1024x900\" , 24 ); Teclado teclado = new Teclado ( \"Negror\" , 90 ); Ordenador ordenador = new Ordenador ( procesador , teclado , monitor ); ordenador . getMonitor (). dibujarPixel ( 34 , 56 ); ordenador . getProcesador (). cargarPrograma ( \"Demo\" ); ordenador . getTeclado (). pushKey ( 'X' ); }","title":"Composici\u00f3n"},{"location":"ud5/2composicion/#ocultar-funcionalidad-de-los-objetos-parte","text":"Otro escenario viable es el cual nos permita ocultar la funcionalidad, y no le permitamos al programa acceder directamente a los objetos que componen el todo. Para ello, lo primero que haremos ser\u00e1 modificar la visibilidad de los getters y ponerlos private , de manera que no se pueda acceder desde fuera a Teclado , Monitor o Procesador pero si podamos acceder internamente. public class Ordenador { private Procesador procesador ; private Teclado teclado ; private Monitor monitor ; public Ordenador ( Procesador procesador , Teclado teclado , Monitor monitor ) { this . procesador = procesador ; this . teclado = teclado ; this . monitor = monitor ; } private Procesador getProcesador () { return procesador ; } private Teclado getTeclado () { return teclado ; } private Monitor getMonitor () { return monitor ; } } Una vez oculta la informaci\u00f3n veamos como podemos acceder a ella en el main. Creamos un m\u00e9todo en la clase Ordenador que acceder\u00e1 a las distintas partes. public class Ordenador { private Procesador procesador ; private Teclado teclado ; private Monitor monitor ; public Ordenador ( Procesador procesador , Teclado teclado , Monitor monitor ) { this . procesador = procesador ; this . teclado = teclado ; this . monitor = monitor ; } public void encender () { getProcesador (). presionarBotonEncendido (); dibujarLogo (); } private void dibujarLogo () { monitor . dibujarPixel ( 12 , 23 ); } private Procesador getProcesador () { return procesador ; } private Teclado getTeclado () { return teclado ; } private Monitor getMonitor () { return monitor ; } } En el main accederemos a este m\u00e9todo: public static void main ( String [] args ) { Procesador procesador = new Procesador ( \"Intel\" , 2 , 3 ); Monitor monitor = new Monitor ( \"Philips\" , \"1024x900\" , 24 ); Teclado teclado = new Teclado ( \"Negror\" , 90 ); Ordenador ordenador = new Ordenador ( procesador , teclado , monitor ); ordenador . encender (); }","title":"Ocultar funcionalidad de los objetos parte"},{"location":"ud5/3encapsulacion/","text":"Encapsulaci\u00f3n El mecanismo que permite restringir el acceso a componentes en los objetos, es decir, ofrece protecci\u00f3n a los miembros de la clase de cualquier acceso externo no autorizado es la encapsulaci\u00f3n . No estamos hablando de seguridad, hablamos m\u00e1s bien, de restringir el acceso desde fuera al funcionamiento interno de una clase, es decir, ocultar el trabajo interno que se realiza en una clase. Veamos un ejemplo de una clase que no usa encapsulaci\u00f3n y as\u00ed nos permitir\u00e1 entender mejor porqu\u00e9 la encapsulaci\u00f3n en algo positivo. Luego veremos c\u00f3mo se har\u00eda con encapsulaci\u00f3n. Ejemplo de programa SIN encapsulaci\u00f3n Acceso a la clase y modificacion de funcionalidad Primero creamos una clase Player con los siguiente campos: public class Player { public String name ; public int health ; public String weapon ; public void applyDamage ( int damage ) { this . health -= damage ; if ( this . health <= 0 ) { System . out . println ( \"Player died\" ); } } public int getActualHealth () { return health ; } } Ahora implementamos el main en otra clase: public class Main { public static void main ( String [] args ) { Player player = new Player (); player . name = \"Patricia\" ; player . health = 50 ; player . weapon = \"flamethrower\" ; int damage = 30 ; player . applyDamage ( damage ); System . out . println ( \"The actual health is \" + player . getActualHealth ()); damage = 10 ; player . health = 100 ; player . applyDamage ( damage ); System . out . println ( \"The actual health is \" + player . getActualHealth ()); } } Observamos que podemos inicializar directamente los campos del objeto Player a trav\u00e9s de clase externa porque hemos establecido la visibilidad como public . Adem\u00e1s, vemos que podemos causar da\u00f1o al jugador, pero seguidamente podemos darle m\u00e1s vida puesto que tenemos control sobre los atributos del jugador. Por lo que, al poder acceder a esos campos directamente potencialmente estamos abriendo la aplicaci\u00f3n y permitiendo cambiar el comportamiento. Ya que nosotros no queremos que se le pueda dar vida. Solo aplicar da\u00f1o. Consecuencias de cambios internos de la clase Imaginar que la aplicaci\u00f3n evoluciona y queremos modificar un atributo de la clase Player , por ejemplo, ya no queremos el nombre, ahora vamos a tener en cuenta el nickname del jugador. Al hacer este cambio, el m\u00e9todo main que acced\u00eda a este campo, genera un error. Lo que significa que cualquier campo que hagamos en la clase de Player afectar\u00e1 a cualquier clase que lo haya usado. Sabiendo que, es un cambio interno de la clase y en teor\u00eda no deber\u00eda afectar a ninguna otra clase, porque hemos decidido que es se entiende mejor si el atributo se llama nickname que si se llama name . Garantizar la clase se crea con los valores correctos Como no hemos definido un constructor, puede ser que la clase externa que usa Player no defina las variables de forma v\u00e1lida. Por tanto, no podemos garantizar que el uso del objeto jugador sera correcto. Imagina que al crear un objeto de la clase Player nos olvidamos de darle valor al campo de health : Al intentar aplicar da\u00f1o no se aplicar\u00e1 de forma correcta. Por tanto, es conveniente definir un constructor para garantizar que el objeto se construye de forma correcta y adem\u00e1s si queremos agregar alg\u00fan tipo de validaci\u00f3n tambi\u00e9n podr\u00edamos realizarla en el constructor. Ejemplo de programa CON encapsulaci\u00f3n Vamos a ver cu\u00e1l es la forma correcta realizar el ejemplo anterior usando encapsulaci\u00f3n. public class PlayerOk { private String name ; private int health = 100 ; private String weapon ; public PlayerOk ( String name , int health , String weapon ) { this . name = name ; if ( health > 0 && health <= 100 ) { this . health = health ; } this . weapon = weapon ; } public void applyDamage ( int damage ) { this . health -= damage ; if ( this . health <= 0 ) { System . out . println ( \"Player died\" ); } } public int getActualHealth () { return health ; } } public class Main { public static void main ( String [] args ) { PlayerOk playerOk = new PlayerOk ( \"Patri\" , 50 , \"flamethrower\" ); PlayerOk playerOk2 = new PlayerOk ( \"Manu\" , 150 , \"sword\" ); } }","title":"5.3 Encapsulaci\u00f3n"},{"location":"ud5/3encapsulacion/#encapsulacion","text":"El mecanismo que permite restringir el acceso a componentes en los objetos, es decir, ofrece protecci\u00f3n a los miembros de la clase de cualquier acceso externo no autorizado es la encapsulaci\u00f3n . No estamos hablando de seguridad, hablamos m\u00e1s bien, de restringir el acceso desde fuera al funcionamiento interno de una clase, es decir, ocultar el trabajo interno que se realiza en una clase. Veamos un ejemplo de una clase que no usa encapsulaci\u00f3n y as\u00ed nos permitir\u00e1 entender mejor porqu\u00e9 la encapsulaci\u00f3n en algo positivo. Luego veremos c\u00f3mo se har\u00eda con encapsulaci\u00f3n.","title":"Encapsulaci\u00f3n"},{"location":"ud5/3encapsulacion/#ejemplo-de-programa-sin-encapsulacion","text":"","title":"Ejemplo de programa SIN encapsulaci\u00f3n"},{"location":"ud5/3encapsulacion/#acceso-a-la-clase-y-modificacion-de-funcionalidad","text":"Primero creamos una clase Player con los siguiente campos: public class Player { public String name ; public int health ; public String weapon ; public void applyDamage ( int damage ) { this . health -= damage ; if ( this . health <= 0 ) { System . out . println ( \"Player died\" ); } } public int getActualHealth () { return health ; } } Ahora implementamos el main en otra clase: public class Main { public static void main ( String [] args ) { Player player = new Player (); player . name = \"Patricia\" ; player . health = 50 ; player . weapon = \"flamethrower\" ; int damage = 30 ; player . applyDamage ( damage ); System . out . println ( \"The actual health is \" + player . getActualHealth ()); damage = 10 ; player . health = 100 ; player . applyDamage ( damage ); System . out . println ( \"The actual health is \" + player . getActualHealth ()); } } Observamos que podemos inicializar directamente los campos del objeto Player a trav\u00e9s de clase externa porque hemos establecido la visibilidad como public . Adem\u00e1s, vemos que podemos causar da\u00f1o al jugador, pero seguidamente podemos darle m\u00e1s vida puesto que tenemos control sobre los atributos del jugador. Por lo que, al poder acceder a esos campos directamente potencialmente estamos abriendo la aplicaci\u00f3n y permitiendo cambiar el comportamiento. Ya que nosotros no queremos que se le pueda dar vida. Solo aplicar da\u00f1o.","title":"Acceso a la clase y modificacion de funcionalidad"},{"location":"ud5/3encapsulacion/#consecuencias-de-cambios-internos-de-la-clase","text":"Imaginar que la aplicaci\u00f3n evoluciona y queremos modificar un atributo de la clase Player , por ejemplo, ya no queremos el nombre, ahora vamos a tener en cuenta el nickname del jugador. Al hacer este cambio, el m\u00e9todo main que acced\u00eda a este campo, genera un error. Lo que significa que cualquier campo que hagamos en la clase de Player afectar\u00e1 a cualquier clase que lo haya usado. Sabiendo que, es un cambio interno de la clase y en teor\u00eda no deber\u00eda afectar a ninguna otra clase, porque hemos decidido que es se entiende mejor si el atributo se llama nickname que si se llama name .","title":"Consecuencias de cambios internos de la clase"},{"location":"ud5/3encapsulacion/#garantizar-la-clase-se-crea-con-los-valores-correctos","text":"Como no hemos definido un constructor, puede ser que la clase externa que usa Player no defina las variables de forma v\u00e1lida. Por tanto, no podemos garantizar que el uso del objeto jugador sera correcto. Imagina que al crear un objeto de la clase Player nos olvidamos de darle valor al campo de health : Al intentar aplicar da\u00f1o no se aplicar\u00e1 de forma correcta. Por tanto, es conveniente definir un constructor para garantizar que el objeto se construye de forma correcta y adem\u00e1s si queremos agregar alg\u00fan tipo de validaci\u00f3n tambi\u00e9n podr\u00edamos realizarla en el constructor.","title":"Garantizar la clase se crea con los valores correctos"},{"location":"ud5/3encapsulacion/#ejemplo-de-programa-con-encapsulacion","text":"Vamos a ver cu\u00e1l es la forma correcta realizar el ejemplo anterior usando encapsulaci\u00f3n. public class PlayerOk { private String name ; private int health = 100 ; private String weapon ; public PlayerOk ( String name , int health , String weapon ) { this . name = name ; if ( health > 0 && health <= 100 ) { this . health = health ; } this . weapon = weapon ; } public void applyDamage ( int damage ) { this . health -= damage ; if ( this . health <= 0 ) { System . out . println ( \"Player died\" ); } } public int getActualHealth () { return health ; } } public class Main { public static void main ( String [] args ) { PlayerOk playerOk = new PlayerOk ( \"Patri\" , 50 , \"flamethrower\" ); PlayerOk playerOk2 = new PlayerOk ( \"Manu\" , 150 , \"sword\" ); } }","title":"Ejemplo de programa CON encapsulaci\u00f3n"},{"location":"ud5/4polimorfismo/","text":"Polimorfismo El Polimorfismo es uno de los 4 pilares de la programaci\u00f3n orientada a objetos (POO) junto con la Abstracci\u00f3n, Encapsulaci\u00f3n y Herencia. Para entender que es el polimorfismo es muy importante que teng\u00e1is bastante claro el concepto de la Herencia . Polimorfismo significa \"que tiene muchas formas\", es la capacidad que tienen los objetos de una clase en ofrecer respuesta distinta e independiente en funci\u00f3n de los par\u00e1metros (diferentes implementaciones) utilizados durante su invocaci\u00f3n. Veamos un ejemplo para entender de forma m\u00e1s clara c\u00f3mo funciona el polimorfismo. Crearemos unas clases que heredan de la clase padre Pelicula : class Pelicula { private String titulo ; public Pelicula ( String titulo ) { this . titulo = titulo ; } public String trama () { return \"No hay trama\" ; } } class Spiderman extends Pelicula { public Spiderman () { super ( \"Spiderman\" ); } @Override public String trama () { return \"Un hombre que le muerde una ara\u00f1a y adquiere sus poderes.\" ; } } class Batman extends Pelicula { public Batman () { super ( \"Batman\" ); } @Override public String trama () { return \"Un hombre que le muerde un murci\u00e9lago y adquiere sus poderes.\" ; } } class Zombieland extends Pelicula { public Zombieland () { super ( \"Zombieland\" ); } @Override public String trama () { return \"Un pu\u00f1ado de humanos convertidos en zombies tratan de hacerse con el mundo\" ; } } class StarWars extends Pelicula { public StarWars () { super ( \"StarWars\" ); } @Override public String trama () { return \"Las fuerzas imperiales tratan de hacerse con control del mundo\" ; } } class PeliRandom extends Pelicula { public PeliRandom () { super ( \"PeliRandom\" ); } } Ahora vamos a crear un m\u00e9todo est\u00e1tico que nos va a devolver un objeto de tipo Pelicula en la clase Main , es decir, nos devolver\u00e1 una pel\u00edcula de manera aleatoria: public static Pelicula peliculaAleatoria () { int numero = ( int ) ( Math . random () * 5 ) + 1 ; //genera un n\u00famero aleatorio entre 1 - 5 System . out . println ( numero ); switch ( numero ) { case 1 : return new Spiderman (); case 2 : return new Batman (); case 3 : return new Zombieland (); case 4 : return new StarWars (); case 5 : return new PeliRandom (); } return null ; } Gracias a la herencia, podemos devolver un tipo de la clase padre Pelicula aunque en realidad hayamos creado un objeto de una clase hija. Ahora vamos a ver el polimorfismo, para ello vamos a crear un bucle en el main de la siguiente forma: public static void main ( String [] args ) { for ( int i = 0 ; i < 10 ; i ++ ) { Pelicula pelicula = peliculaAleatoria (); System . out . println ( \"Pelicula \" + i + \" \" + pelicula . getTitulo () + \" \\n\" + pelicula . trama ()); } } Gracias al polimorfismo tenemos la capacidad de llamar al m\u00e9todo trama con el mismo tipo de objeto, en este caso de tipo Pelicula y obtener diferentes resultados, ya que Java autom\u00e1ticamente ve qu\u00e9 tipo de hijo es e imprime el correspondiente m\u00e9todo trama . Para el caso de que no se haya sobreescrito el m\u00e9todo llamar\u00e1 al de la clase padre Es decir, dependiendo del tipo de objeto invocado se realizan acciones diferentes, teniendo en cuenta, que todas las clases heredan de Pelicula eso es el polimorfismo .","title":"5.4 Polimorfismo"},{"location":"ud5/4polimorfismo/#polimorfismo","text":"El Polimorfismo es uno de los 4 pilares de la programaci\u00f3n orientada a objetos (POO) junto con la Abstracci\u00f3n, Encapsulaci\u00f3n y Herencia. Para entender que es el polimorfismo es muy importante que teng\u00e1is bastante claro el concepto de la Herencia . Polimorfismo significa \"que tiene muchas formas\", es la capacidad que tienen los objetos de una clase en ofrecer respuesta distinta e independiente en funci\u00f3n de los par\u00e1metros (diferentes implementaciones) utilizados durante su invocaci\u00f3n. Veamos un ejemplo para entender de forma m\u00e1s clara c\u00f3mo funciona el polimorfismo. Crearemos unas clases que heredan de la clase padre Pelicula : class Pelicula { private String titulo ; public Pelicula ( String titulo ) { this . titulo = titulo ; } public String trama () { return \"No hay trama\" ; } } class Spiderman extends Pelicula { public Spiderman () { super ( \"Spiderman\" ); } @Override public String trama () { return \"Un hombre que le muerde una ara\u00f1a y adquiere sus poderes.\" ; } } class Batman extends Pelicula { public Batman () { super ( \"Batman\" ); } @Override public String trama () { return \"Un hombre que le muerde un murci\u00e9lago y adquiere sus poderes.\" ; } } class Zombieland extends Pelicula { public Zombieland () { super ( \"Zombieland\" ); } @Override public String trama () { return \"Un pu\u00f1ado de humanos convertidos en zombies tratan de hacerse con el mundo\" ; } } class StarWars extends Pelicula { public StarWars () { super ( \"StarWars\" ); } @Override public String trama () { return \"Las fuerzas imperiales tratan de hacerse con control del mundo\" ; } } class PeliRandom extends Pelicula { public PeliRandom () { super ( \"PeliRandom\" ); } } Ahora vamos a crear un m\u00e9todo est\u00e1tico que nos va a devolver un objeto de tipo Pelicula en la clase Main , es decir, nos devolver\u00e1 una pel\u00edcula de manera aleatoria: public static Pelicula peliculaAleatoria () { int numero = ( int ) ( Math . random () * 5 ) + 1 ; //genera un n\u00famero aleatorio entre 1 - 5 System . out . println ( numero ); switch ( numero ) { case 1 : return new Spiderman (); case 2 : return new Batman (); case 3 : return new Zombieland (); case 4 : return new StarWars (); case 5 : return new PeliRandom (); } return null ; } Gracias a la herencia, podemos devolver un tipo de la clase padre Pelicula aunque en realidad hayamos creado un objeto de una clase hija. Ahora vamos a ver el polimorfismo, para ello vamos a crear un bucle en el main de la siguiente forma: public static void main ( String [] args ) { for ( int i = 0 ; i < 10 ; i ++ ) { Pelicula pelicula = peliculaAleatoria (); System . out . println ( \"Pelicula \" + i + \" \" + pelicula . getTitulo () + \" \\n\" + pelicula . trama ()); } } Gracias al polimorfismo tenemos la capacidad de llamar al m\u00e9todo trama con el mismo tipo de objeto, en este caso de tipo Pelicula y obtener diferentes resultados, ya que Java autom\u00e1ticamente ve qu\u00e9 tipo de hijo es e imprime el correspondiente m\u00e9todo trama . Para el caso de que no se haya sobreescrito el m\u00e9todo llamar\u00e1 al de la clase padre Es decir, dependiendo del tipo de objeto invocado se realizan acciones diferentes, teniendo en cuenta, que todas las clases heredan de Pelicula eso es el polimorfismo .","title":"Polimorfismo"},{"location":"ud5/5interfaces/","text":"Interfaces Definici\u00f3n Una interfaz es una clase que define m\u00e9todos pero no los implementa. La idea es proporcionar un comportamiento com\u00fan que pueda ser utilizado por varias clases que implemente una interfaz. Las interfaces son muy usadas, de hecho, muchas de las librer\u00edas de Java hacen un uso extensivo de las interfaces. Sabemos que Java tiene herencia \u00fanica, es decir, una clase hija hereda solo de una clase padre. Esto, por lo general, es suficiente para codificar nuestras aplicaciones. Aunque a veces ser\u00eda conveniente la herencia m\u00faltiple, donde una clase hija pudiera heredar caracter\u00edsticas de varias clases padres. Pero esto puede llegar a ser confuso. \u00bfQu\u00e9 sucede cuando dos padres tienen diferentes versiones del mismo m\u00e9todo? Las interfaces dan a Java algunas de las ventajas de la herencia m\u00faltiple sin las desventajas. Una interfaz describe aspectos de una clase distintos de los que hereda de su padre. Una interfaz es un conjunto de requisitos que la clase debe implementar . Una interfaz es una lista de constantes y signaturas de m\u00e9todos. Los m\u00e9todos no est\u00e1n implementados en la interfaz (no hay cuerpo de m\u00e9todo). Interfaz vs Herencia Una clase puede extender de una clase padre para heredar los m\u00e9todos y las variables de instancia de ese padre. Una clase tambi\u00e9n puede implementar una interfaz al incluir m\u00e9todos y constantes adicionales. Sin embargo, los m\u00e9todos en la interfaz deben escribirse expl\u00edcitamente como parte de la definici\u00f3n de la clase. La interfaz es una lista de requisitos que debe incluir la definici\u00f3n de clase (a trav\u00e9s de c\u00f3digo expl\u00edcito, no a trav\u00e9s de herencia). Por ejemplo, una clase Coche podr\u00eda extender de la clase Vehiculo . La herencia le da todos los m\u00e9todos y variables de instancia. Pero si Coche tambi\u00e9n implementa la interfaz Impuestos , entonces su definici\u00f3n debe contener c\u00f3digo para todos los m\u00e9todos enumerados en Impuestos . Una clase extiende de un solo padre, pero puede implementar varias interfaces. C\u00f3mo crear una interfaz Para crear una interfaz en IntelliJ, haremos lo siguiente: Bot\u00f3n derecho en el paquete de nuestra aplicaci\u00f3n --> New ---> Java class y seleccionamos Interface. Por convenci\u00f3n el nombre que se le da a la interfaz es siempre primera letra \"I\" (de interfaz) + nombre de la clase. Una vez creada la interfaz definiremos los m\u00e9todos que desarrollar\u00e1n las clases que implementen esta interfaz. Los m\u00e9todos de una interfaz son p\u00fablicos de forma predeterminada, por lo que puede omitirlos en los encabezados de los m\u00e9todos. Los m\u00e9todos no pueden ser private ni protected . Las constantes en una interfaz son public static final por defecto, por tanto podemos omitirlo. Se estructura de forma que primero se sit\u00faan las constantes y luego los En las interfaces poner public o private es innecesario, porque eso se har\u00e1 en la clase que implemente los m\u00e9todos. No hace falta a\u00f1adir el modificador de acceso en las interfaces, de manera que podriamos borrar public de los m\u00e9todos. IntelliJ nos ofrece la opci\u00f3n de hacerlo: Una vez creada la interfaz, necesitaremos clases que la implementen, para ello usaremos la palabra reservada implements en la nueva clase. Por ejemplo, vamos a crear la clase TelefonoMovil: Observamos que IntelliJ nos genera un error, ya que debemos definir o implementar los m\u00e9todos que hab\u00edamos declarado en la interfaz. Si hacemos click en el error, IntelliJ nos ofrece crearlos: IntelliJ nos ha creado TODOS los m\u00e9todos que hab\u00edamos definido en la interfaz, como vemos con la anotaci\u00f3n @Override , ya que los est\u00e1 sobreescribiendo puesto que estaban declarados en la interfaz. Con la interfaz lo que hacemos es obligar, es decir, para que una clase de tel\u00e9fono en nuestra aplicaci\u00f3n sea v\u00e1lidad ha de implementar los 4 m\u00e9todos que definimos en la interfaz ITelefono . Nota TODOS los m\u00e9todos definidos en la interfaz se han de implementar en la clase, no podr\u00edamos implementar solo algunos. Veamos como probar el c\u00f3digo en nuestra clase Main : public class MainTelefono { public static void main ( String [] args ) { ITelefono telefono ; telefono = new TelefonoMovil ( 1234567 ); telefono . encender (); telefono . llamar ( 1234567 ); telefono . apagar (); } } Warning Las interfaces no pueden instanciarse, tienes que usar una clase que haya implementado la funcionalidad definida por la interfaz. Ahora vamos a crear otro tipo de tel\u00e9fono:","title":"5.5 Interfaces"},{"location":"ud5/5interfaces/#interfaces","text":"","title":"Interfaces"},{"location":"ud5/5interfaces/#definicion","text":"Una interfaz es una clase que define m\u00e9todos pero no los implementa. La idea es proporcionar un comportamiento com\u00fan que pueda ser utilizado por varias clases que implemente una interfaz. Las interfaces son muy usadas, de hecho, muchas de las librer\u00edas de Java hacen un uso extensivo de las interfaces. Sabemos que Java tiene herencia \u00fanica, es decir, una clase hija hereda solo de una clase padre. Esto, por lo general, es suficiente para codificar nuestras aplicaciones. Aunque a veces ser\u00eda conveniente la herencia m\u00faltiple, donde una clase hija pudiera heredar caracter\u00edsticas de varias clases padres. Pero esto puede llegar a ser confuso. \u00bfQu\u00e9 sucede cuando dos padres tienen diferentes versiones del mismo m\u00e9todo? Las interfaces dan a Java algunas de las ventajas de la herencia m\u00faltiple sin las desventajas. Una interfaz describe aspectos de una clase distintos de los que hereda de su padre. Una interfaz es un conjunto de requisitos que la clase debe implementar . Una interfaz es una lista de constantes y signaturas de m\u00e9todos. Los m\u00e9todos no est\u00e1n implementados en la interfaz (no hay cuerpo de m\u00e9todo).","title":"Definici\u00f3n"},{"location":"ud5/5interfaces/#interfaz-vs-herencia","text":"Una clase puede extender de una clase padre para heredar los m\u00e9todos y las variables de instancia de ese padre. Una clase tambi\u00e9n puede implementar una interfaz al incluir m\u00e9todos y constantes adicionales. Sin embargo, los m\u00e9todos en la interfaz deben escribirse expl\u00edcitamente como parte de la definici\u00f3n de la clase. La interfaz es una lista de requisitos que debe incluir la definici\u00f3n de clase (a trav\u00e9s de c\u00f3digo expl\u00edcito, no a trav\u00e9s de herencia). Por ejemplo, una clase Coche podr\u00eda extender de la clase Vehiculo . La herencia le da todos los m\u00e9todos y variables de instancia. Pero si Coche tambi\u00e9n implementa la interfaz Impuestos , entonces su definici\u00f3n debe contener c\u00f3digo para todos los m\u00e9todos enumerados en Impuestos . Una clase extiende de un solo padre, pero puede implementar varias interfaces.","title":"Interfaz vs Herencia"},{"location":"ud5/5interfaces/#como-crear-una-interfaz","text":"Para crear una interfaz en IntelliJ, haremos lo siguiente: Bot\u00f3n derecho en el paquete de nuestra aplicaci\u00f3n --> New ---> Java class y seleccionamos Interface. Por convenci\u00f3n el nombre que se le da a la interfaz es siempre primera letra \"I\" (de interfaz) + nombre de la clase. Una vez creada la interfaz definiremos los m\u00e9todos que desarrollar\u00e1n las clases que implementen esta interfaz. Los m\u00e9todos de una interfaz son p\u00fablicos de forma predeterminada, por lo que puede omitirlos en los encabezados de los m\u00e9todos. Los m\u00e9todos no pueden ser private ni protected . Las constantes en una interfaz son public static final por defecto, por tanto podemos omitirlo. Se estructura de forma que primero se sit\u00faan las constantes y luego los En las interfaces poner public o private es innecesario, porque eso se har\u00e1 en la clase que implemente los m\u00e9todos. No hace falta a\u00f1adir el modificador de acceso en las interfaces, de manera que podriamos borrar public de los m\u00e9todos. IntelliJ nos ofrece la opci\u00f3n de hacerlo: Una vez creada la interfaz, necesitaremos clases que la implementen, para ello usaremos la palabra reservada implements en la nueva clase. Por ejemplo, vamos a crear la clase TelefonoMovil: Observamos que IntelliJ nos genera un error, ya que debemos definir o implementar los m\u00e9todos que hab\u00edamos declarado en la interfaz. Si hacemos click en el error, IntelliJ nos ofrece crearlos: IntelliJ nos ha creado TODOS los m\u00e9todos que hab\u00edamos definido en la interfaz, como vemos con la anotaci\u00f3n @Override , ya que los est\u00e1 sobreescribiendo puesto que estaban declarados en la interfaz. Con la interfaz lo que hacemos es obligar, es decir, para que una clase de tel\u00e9fono en nuestra aplicaci\u00f3n sea v\u00e1lidad ha de implementar los 4 m\u00e9todos que definimos en la interfaz ITelefono . Nota TODOS los m\u00e9todos definidos en la interfaz se han de implementar en la clase, no podr\u00edamos implementar solo algunos. Veamos como probar el c\u00f3digo en nuestra clase Main : public class MainTelefono { public static void main ( String [] args ) { ITelefono telefono ; telefono = new TelefonoMovil ( 1234567 ); telefono . encender (); telefono . llamar ( 1234567 ); telefono . apagar (); } } Warning Las interfaces no pueden instanciarse, tienes que usar una clase que haya implementado la funcionalidad definida por la interfaz. Ahora vamos a crear otro tipo de tel\u00e9fono:","title":"C\u00f3mo crear una interfaz"},{"location":"ud5/6abstraccion/","text":"Abstracci\u00f3n","title":"Abstracci\u00f3n"},{"location":"ud5/6abstraccion/#abstraccion","text":"","title":"Abstracci\u00f3n"}]}