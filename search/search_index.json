{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Programaci\u00f3n Aqu\u00ed puedes encontrar los apuntes del m\u00f3dulo de Programaci\u00f3n , que se imparte en el primer curso del ciclo formativo de grado superior de Desarrollo de Aplicaciones Multiplataforma. La duraci\u00f3n del m\u00f3dulo es de 256 horas lectivas, a raz\u00f3n de 8 horas semanales . Se ha planificado bas\u00e1ndose en 4 sesiones de 2 horas lectivas por semana. Resultados de aprendizaje Reconoce la estructura de un programa inform\u00e1tico, identificando y relacionando los elementos propios del lenguaje de programaci\u00f3n utilizado. Escribe y prueba programas sencillos, reconociendo y aplicando los fundamentos de la programaci\u00f3n orientada a objetos. Escribe y depura c\u00f3digo, analizando y utilizando las estructuras de control del lenguaje. Desarrolla programas organizados en clases analizando y aplicando los principios de la programaci\u00f3n orientada a objetos. Realiza operaciones de entrada y salida de informaci\u00f3n, utilizando procedimientos espec\u00edficos del lenguaje y librer\u00edas de clases. Escribe programas que manipulen informaci\u00f3n seleccionando y utilizando tipos avanzados de datos. Desarrolla programas aplicando caracter\u00edsticas avanzadas de los lenguajes orientados a objetos y del entorno de programaci\u00f3n. Utiliza bases de datos orientadas a objetos, analizando sus caracter\u00edsticas y aplicando t\u00e9cnicas para mantener la persistencia de la informaci\u00f3n. Gestiona informaci\u00f3n almacenada en bases de datos relacionales manteniendo la integridad y consistencia de los datos. Unidades did\u00e1cticas / Temporalizaci\u00f3n A continuaci\u00f3n se muestran las unidades did\u00e1cticas y una estimaci\u00f3n temporal de cada una de ellas. El curso est\u00e1 dividido en 10 unidades did\u00e1cticas distribuidas en tres trimestres. Primera evaluaci\u00f3n Compuesta por las 5 primeras unidades, donde se estudiar\u00e1n los aspectos b\u00e1sicos de la programaci\u00f3n orientada a objetos usando el lenguaje de programaci\u00f3n Java . Unidad T\u00edtulo Sesiones Horas 1 Elementos de un programa inform\u00e1tico 10 20 2 Estructuras b\u00e1sicas de control 13 26 3 Arrays 9 18 4 Programaci\u00f3n orientada a objetos. Clases y Objetos 12 24 5 Herencia y polimorfismo 14 28 Segunda evaluaci\u00f3n Incluye 3 unidades y se profundizar\u00e1 en aspectos de codificaci\u00f3n como colecciones de Java, interfaces de usuario, reflections, expresiones regulares, etc. Unidad T\u00edtulo Sesiones Horas 6 Colecciones 15 30 7 Programaci\u00f3n avanzada 10 20 8 Interfaces de usuario 16 32 Tercera evaluaci\u00f3n Por \u00faltimo se aprender\u00e1n t\u00e9cnicas de lectura y escritura y persistencia de la informaci\u00f3n en ficheros y bases de datos. Unidad T\u00edtulo Sesiones Horas 9 Persistencia de la informaci\u00f3n 13 26 10 Bases de datos 16 32 Instrumentos de calificaci\u00f3n La nota de cada evaluaci\u00f3n se calcula mediante: 30% Trabajo en Clase / Actividades Se eval\u00faan todas las actividades realizadas en clase y en casa. Las actividades se eval\u00faan mediante tareas de Aules con calificaciones comprendidas entre 0 y 3 puntos: 0: No entregada. 1: Entregada pero soluci\u00f3n err\u00f3nea o incompleta. 2: Entregada y soluci\u00f3n aceptable, aunque tiene alg\u00fan apartado incompleto. 3: Entregada y soluci\u00f3n correcta. Las actividades son de entrega obligatoria para realizar el examen. Cualquier actividad que se detecte copia ser\u00e1 puntuada con 0. 70% Actividad de evaluaci\u00f3n. La nota final se calcula mediante la media de cada una de las evaluaciones.","title":"Inicio"},{"location":"#programacion","text":"Aqu\u00ed puedes encontrar los apuntes del m\u00f3dulo de Programaci\u00f3n , que se imparte en el primer curso del ciclo formativo de grado superior de Desarrollo de Aplicaciones Multiplataforma. La duraci\u00f3n del m\u00f3dulo es de 256 horas lectivas, a raz\u00f3n de 8 horas semanales . Se ha planificado bas\u00e1ndose en 4 sesiones de 2 horas lectivas por semana.","title":"Programaci\u00f3n"},{"location":"#resultados-de-aprendizaje","text":"Reconoce la estructura de un programa inform\u00e1tico, identificando y relacionando los elementos propios del lenguaje de programaci\u00f3n utilizado. Escribe y prueba programas sencillos, reconociendo y aplicando los fundamentos de la programaci\u00f3n orientada a objetos. Escribe y depura c\u00f3digo, analizando y utilizando las estructuras de control del lenguaje. Desarrolla programas organizados en clases analizando y aplicando los principios de la programaci\u00f3n orientada a objetos. Realiza operaciones de entrada y salida de informaci\u00f3n, utilizando procedimientos espec\u00edficos del lenguaje y librer\u00edas de clases. Escribe programas que manipulen informaci\u00f3n seleccionando y utilizando tipos avanzados de datos. Desarrolla programas aplicando caracter\u00edsticas avanzadas de los lenguajes orientados a objetos y del entorno de programaci\u00f3n. Utiliza bases de datos orientadas a objetos, analizando sus caracter\u00edsticas y aplicando t\u00e9cnicas para mantener la persistencia de la informaci\u00f3n. Gestiona informaci\u00f3n almacenada en bases de datos relacionales manteniendo la integridad y consistencia de los datos.","title":"Resultados de aprendizaje"},{"location":"#unidades-didacticas-temporalizacion","text":"A continuaci\u00f3n se muestran las unidades did\u00e1cticas y una estimaci\u00f3n temporal de cada una de ellas. El curso est\u00e1 dividido en 10 unidades did\u00e1cticas distribuidas en tres trimestres.","title":"Unidades did\u00e1cticas / Temporalizaci\u00f3n"},{"location":"#primera-evaluacion","text":"Compuesta por las 5 primeras unidades, donde se estudiar\u00e1n los aspectos b\u00e1sicos de la programaci\u00f3n orientada a objetos usando el lenguaje de programaci\u00f3n Java . Unidad T\u00edtulo Sesiones Horas 1 Elementos de un programa inform\u00e1tico 10 20 2 Estructuras b\u00e1sicas de control 13 26 3 Arrays 9 18 4 Programaci\u00f3n orientada a objetos. Clases y Objetos 12 24 5 Herencia y polimorfismo 14 28","title":"Primera evaluaci\u00f3n"},{"location":"#segunda-evaluacion","text":"Incluye 3 unidades y se profundizar\u00e1 en aspectos de codificaci\u00f3n como colecciones de Java, interfaces de usuario, reflections, expresiones regulares, etc. Unidad T\u00edtulo Sesiones Horas 6 Colecciones 15 30 7 Programaci\u00f3n avanzada 10 20 8 Interfaces de usuario 16 32","title":"Segunda evaluaci\u00f3n"},{"location":"#tercera-evaluacion","text":"Por \u00faltimo se aprender\u00e1n t\u00e9cnicas de lectura y escritura y persistencia de la informaci\u00f3n en ficheros y bases de datos. Unidad T\u00edtulo Sesiones Horas 9 Persistencia de la informaci\u00f3n 13 26 10 Bases de datos 16 32","title":"Tercera evaluaci\u00f3n"},{"location":"#instrumentos-de-calificacion","text":"La nota de cada evaluaci\u00f3n se calcula mediante: 30% Trabajo en Clase / Actividades Se eval\u00faan todas las actividades realizadas en clase y en casa. Las actividades se eval\u00faan mediante tareas de Aules con calificaciones comprendidas entre 0 y 3 puntos: 0: No entregada. 1: Entregada pero soluci\u00f3n err\u00f3nea o incompleta. 2: Entregada y soluci\u00f3n aceptable, aunque tiene alg\u00fan apartado incompleto. 3: Entregada y soluci\u00f3n correcta. Las actividades son de entrega obligatoria para realizar el examen. Cualquier actividad que se detecte copia ser\u00e1 puntuada con 0. 70% Actividad de evaluaci\u00f3n. La nota final se calcula mediante la media de cada una de las evaluaciones.","title":"Instrumentos de calificaci\u00f3n"},{"location":"about/","text":"About Patricia Mart\u00ed marti_patgra@gva.es","title":"About"},{"location":"about/#about","text":"Patricia Mart\u00ed marti_patgra@gva.es","title":"About"},{"location":"shortcuts/","text":"Atajos de teclado para IntelliJ En proceso.","title":"Atajos de teclado para IntelliJ"},{"location":"shortcuts/#atajos-de-teclado-para-intellij","text":"En proceso.","title":"Atajos de teclado para IntelliJ"},{"location":"ud1/121conceptosbasicos/","text":"JAVA Java es un lenguaje de programaci\u00f3n orientado a objetos. Fue creado por James Gosling en 1995. Oracle lo compr\u00f3. Es un lenguaje indepediente de la plataforma donde va a ser ejecutado, esto significa, que una vez que se compila (.class tambi\u00e9n llamado bytecode) puede ser transportado a diferentes plataformas (Windows, MacOS, Linux) para ser ejecutado. \u00bfC\u00f3mo se hace esto? Utilizando la JVM (Java Virtual Machine). La JVM coge los bytecode compilados y los interpreta dependiendo del OS para poder ser ejecutado. Por tanto, el bytecode siempre es el mismo, pero lo que genera la JVM cambiar\u00e1 para cada SO. Tambi\u00e9n existen otros t\u00e9rminos muy famosos relacionados con Java como JRE y JDK. JRE Java Runtime Environment . La m\u00e1quina virtual de Java est\u00e1 incluida en el JRE. Se utiliza para ejecutar aplicaciones Java en el SO, por tanto si queremos desplegar una aplicaci\u00f3n en Java, necesitamos tener instalado previamente el JRE para esa m\u00e1quina y plataforma. JDK Java Development Kit . Es m\u00e1s pesado que el JRE, contiene todas las herramientas para programar y compilar las clases Java en bytecode, por tanto cuando desarrollamos clases Java necesitamos el JDK. Adem\u00e1s incluy el JRE. Versiones Java La \u00faltima versi\u00f3n de Java se conoce como LTS Release (Long Term Support), y es JAVA 11 LTS ( la LTS 17 estar\u00e1 disponible 14 de Septiembre 2021). Nosotros para el prop\u00f3sito de este curso usaremos Java 11. \u00bfPorqu\u00e9 Java? Naci\u00f3 en 1995 y todav\u00eda sigue siendo uno de los lenguajes m\u00e1s usados a nivel mundial. Su capacidad de escribirlo y ejecutarlo en cualquier plataforma: \"Write once, run anywhere\" . Desde que naci\u00f3 han salido muchas releases de gran importancia, el lenguaje sigue evolucionando con nuevas funcionalidades. Tiene un comunidad muy grande de c\u00f3digo abierto, documentaci\u00f3n y tutoriales. Es usado por muchas compa\u00f1\u00edas de software, por tanto se ofertan muchos empleos de desarrolladores Java.","title":"Conceptos b\u00e1sicos del lenguaje"},{"location":"ud1/121conceptosbasicos/#java","text":"Java es un lenguaje de programaci\u00f3n orientado a objetos. Fue creado por James Gosling en 1995. Oracle lo compr\u00f3. Es un lenguaje indepediente de la plataforma donde va a ser ejecutado, esto significa, que una vez que se compila (.class tambi\u00e9n llamado bytecode) puede ser transportado a diferentes plataformas (Windows, MacOS, Linux) para ser ejecutado. \u00bfC\u00f3mo se hace esto? Utilizando la JVM (Java Virtual Machine). La JVM coge los bytecode compilados y los interpreta dependiendo del OS para poder ser ejecutado. Por tanto, el bytecode siempre es el mismo, pero lo que genera la JVM cambiar\u00e1 para cada SO. Tambi\u00e9n existen otros t\u00e9rminos muy famosos relacionados con Java como JRE y JDK.","title":"JAVA "},{"location":"ud1/121conceptosbasicos/#jre","text":"Java Runtime Environment . La m\u00e1quina virtual de Java est\u00e1 incluida en el JRE. Se utiliza para ejecutar aplicaciones Java en el SO, por tanto si queremos desplegar una aplicaci\u00f3n en Java, necesitamos tener instalado previamente el JRE para esa m\u00e1quina y plataforma.","title":"JRE"},{"location":"ud1/121conceptosbasicos/#jdk","text":"Java Development Kit . Es m\u00e1s pesado que el JRE, contiene todas las herramientas para programar y compilar las clases Java en bytecode, por tanto cuando desarrollamos clases Java necesitamos el JDK. Adem\u00e1s incluy el JRE.","title":"JDK"},{"location":"ud1/121conceptosbasicos/#versiones-java","text":"La \u00faltima versi\u00f3n de Java se conoce como LTS Release (Long Term Support), y es JAVA 11 LTS ( la LTS 17 estar\u00e1 disponible 14 de Septiembre 2021). Nosotros para el prop\u00f3sito de este curso usaremos Java 11.","title":"Versiones Java"},{"location":"ud1/121conceptosbasicos/#porque-java","text":"Naci\u00f3 en 1995 y todav\u00eda sigue siendo uno de los lenguajes m\u00e1s usados a nivel mundial. Su capacidad de escribirlo y ejecutarlo en cualquier plataforma: \"Write once, run anywhere\" . Desde que naci\u00f3 han salido muchas releases de gran importancia, el lenguaje sigue evolucionando con nuevas funcionalidades. Tiene un comunidad muy grande de c\u00f3digo abierto, documentaci\u00f3n y tutoriales. Es usado por muchas compa\u00f1\u00edas de software, por tanto se ofertan muchos empleos de desarrolladores Java.","title":"\u00bfPorqu\u00e9 Java?"},{"location":"ud1/122setup/","text":"\u00bfQu\u00e9 se necesita para programar en Java? Instalar el JDK versi\u00f3n 11. Lo podemos descarga desde la p\u00e1gina oficial de Oracle. Instalar un IDE (Integrated Development Environment), es un programa que te ayudar a desarrollar aplicaciones. Hay muchas opciones disponibles de IDEs. Setup Java 11 y IntelliJ en Windows Vamos a la p\u00e1gina de Oracle y descargamos JDK 11. Instalamos el JDK. En linux usamos el siguiente comando para instalar el jdk: sudo apt-get install openjdk-11-jdk Windows: A\u00f1adimos en las variables de entorno del sistema dentro de la variable Path, la ruta donde se ha instalado java en nuestra m\u00e1quina (C:\\Program Files\\Java\\jdk-11\\bin) Windows: Agregamos tambi\u00e9n una nueva variable llamada JAVA_HOME --> C:\\Program Files\\Java\\jdk-11 (Ruta de nuestra m\u00e1quina). Verificamos que se ha instalado java, ejecutando desde l\u00ednea de comandos: java --version Descargamos e instalamos IntelliJ Community En File -> Settings, modificamos las siguientes opciones:","title":"Setup"},{"location":"ud1/122setup/#que-se-necesita-para-programar-en-java","text":"Instalar el JDK versi\u00f3n 11. Lo podemos descarga desde la p\u00e1gina oficial de Oracle. Instalar un IDE (Integrated Development Environment), es un programa que te ayudar a desarrollar aplicaciones. Hay muchas opciones disponibles de IDEs.","title":"\u00bfQu\u00e9 se necesita para programar en Java?"},{"location":"ud1/122setup/#setup-java-11-y-intellij-en-windows","text":"Vamos a la p\u00e1gina de Oracle y descargamos JDK 11. Instalamos el JDK. En linux usamos el siguiente comando para instalar el jdk: sudo apt-get install openjdk-11-jdk Windows: A\u00f1adimos en las variables de entorno del sistema dentro de la variable Path, la ruta donde se ha instalado java en nuestra m\u00e1quina (C:\\Program Files\\Java\\jdk-11\\bin) Windows: Agregamos tambi\u00e9n una nueva variable llamada JAVA_HOME --> C:\\Program Files\\Java\\jdk-11 (Ruta de nuestra m\u00e1quina). Verificamos que se ha instalado java, ejecutando desde l\u00ednea de comandos: java --version Descargamos e instalamos IntelliJ Community En File -> Settings, modificamos las siguientes opciones:","title":"Setup Java 11 y IntelliJ en Windows"},{"location":"ud1/123holamundo/","text":"Proyecto \"Hola Mundo\". Estructura de un programa Cada vez que est\u00e1s aprendiendo un nuevo lenguaje de programaci\u00f3n es una tradici\u00f3n crear un nuevo programa muy simple que genera el texto Hola mundo . Veamos como podemos hacer esto en IntelliJ. Hacemos click en crear nuevo proyecto y elegimos el JDK 11 que hemos instalado. Luego en Next, Next, a\u00f1adimos nombre al proyecto y Finish. Creamos una nueva clase Java llamada Hello.java Vamos a crear un m\u00e9todo para imprimir el mensaje Hola mundo . Usaremos un m\u00e9todo especial llamado main . El main es el primer m\u00e9todo que Java busca y ejecuta en el proyecto. Es el punto de entrada. Ejecutamos el programa mediante A\u00f1adimos y ejecutamos la siguiente sentencia dentro del m\u00e9todo main: System.out.println(\"Hello World\"); Challenge Question Modifica el programa para que imprima por pantalla Hello Teacher . Question Realizar las actividades 1 y 2.","title":"Proyecto Hola Mundo"},{"location":"ud1/123holamundo/#proyecto-hola-mundo-estructura-de-un-programa","text":"Cada vez que est\u00e1s aprendiendo un nuevo lenguaje de programaci\u00f3n es una tradici\u00f3n crear un nuevo programa muy simple que genera el texto Hola mundo . Veamos como podemos hacer esto en IntelliJ. Hacemos click en crear nuevo proyecto y elegimos el JDK 11 que hemos instalado. Luego en Next, Next, a\u00f1adimos nombre al proyecto y Finish. Creamos una nueva clase Java llamada Hello.java Vamos a crear un m\u00e9todo para imprimir el mensaje Hola mundo . Usaremos un m\u00e9todo especial llamado main . El main es el primer m\u00e9todo que Java busca y ejecuta en el proyecto. Es el punto de entrada. Ejecutamos el programa mediante A\u00f1adimos y ejecutamos la siguiente sentencia dentro del m\u00e9todo main: System.out.println(\"Hello World\");","title":"Proyecto \"Hola Mundo\". Estructura de un programa"},{"location":"ud1/123holamundo/#challenge","text":"Question Modifica el programa para que imprima por pantalla Hello Teacher . Question Realizar las actividades 1 y 2.","title":"Challenge"},{"location":"ud1/131variables/","text":"Variables Las variables en Java es una forma de almacenar informaci\u00f3n en nuestro ordenador. Definimos variables asign\u00e1ndoles un nombre. De igual manera se puede acceder a la informaci\u00f3n que guardar las variable, simplemente accediendo por el nombre que le hemos dado. Es el ordenador el que se encarga de averiguar d\u00f3nde se almacena internamente en la memoria RAM del ordenador. Como su nombre indica \"variable\", se puede modificar el contenido que \u00e9sta almacena, es decir, es variable. Lo \u00fanico que tenemos que hacer es decirle al PC qu\u00e9 tipo de informaci\u00f3n queremos guardar en nuestra variable y darle un nombre. Existe diferentes tipos de informaci\u00f3n que podemos utilizar para definir nuestras variables. Se les conoce como tipos de datos o data types. Los tipos de datos son palabras reservas keywords en Java, es decir, no podemos utilizarlas fuera del contexto de tipo de datos. Para definir una variable, necesitamos especificar el tipo de datos, luego darle un nombre a nuestra variable, y opcionalmente, podemos agregar una expresi\u00f3n para inicializar la variable con un valor. Reglas para el nombrado de variables Tiene que comenzar con una letra o '_', nunca con n\u00fameros. Puede contener n\u00fameros. No debe contener espacios en blanco. No debe ser muy largo y debe expresar algo en el contexto. No se pueden usar palabras reservadas. May\u00fasculas y min\u00fasculas se tratan diferente. Definimos nuestra primera variable en el programa de la siguiente forma: La l\u00ednea que acabamos de escribir se conoce como sentencia de declaraci\u00f3n . Keywords Son palabras reservadas del lenguaje. Es decir, son palabras que tienen un significado especial en Java y no puedes usarlas fuera de ese contexto. Ejemplos: public, class, void, static, etc. Existen 61 keywords en Java. Vida de las variables Las variables son memorias reservadas para almacenar valores en RAM. Estas posiciones de memoria se liberan tan pronto como termina la vida de la variable. Seg\u00fan la vida de las variables, hay tres tipos de Variables. 1. Variables locales : La vida permanece dentro de un bloque donde se ha declarado. 2. Variables de instancia : Declaradas dentro de la Clase pero fuera de los m\u00e9todos. No deber\u00eda ser est\u00e1tico. 3. Variables est\u00e1ticas : es como una variable global. Declarado como est\u00e1tico en la clase pero fuera de los m\u00e9todos. static int pi = 3.14 ; Visibilidad En las variables locales, su \u00e1mbito y uso se encuentra dentro del m\u00e9todo o bloque en el que se defini\u00f3 y se destruyen despu\u00e9s de la ejecuci\u00f3n del m\u00e9todo. Es decir, no se puede usar una variable local fuera del m\u00e9todo actual. A las variables de instancia se puede acceder solo a trav\u00e9s de objetos de la clase para la que se defini\u00f3. Un campo / variable est\u00e1tico pertenece a la clase y se cargar\u00e1 en la memoria junto con la clase. Se invocan sin crear un objeto. (Usando el nombre de la clase como referencia). Solo hay una copia de la variable est\u00e1tica disponible en toda la clase, es decir, el valor de la variable est\u00e1tica ser\u00e1 el mismo en todos los objetos. Puede definir una variable est\u00e1tica utilizando la palabra clave static .","title":"Variables"},{"location":"ud1/131variables/#variables","text":"Las variables en Java es una forma de almacenar informaci\u00f3n en nuestro ordenador. Definimos variables asign\u00e1ndoles un nombre. De igual manera se puede acceder a la informaci\u00f3n que guardar las variable, simplemente accediendo por el nombre que le hemos dado. Es el ordenador el que se encarga de averiguar d\u00f3nde se almacena internamente en la memoria RAM del ordenador. Como su nombre indica \"variable\", se puede modificar el contenido que \u00e9sta almacena, es decir, es variable. Lo \u00fanico que tenemos que hacer es decirle al PC qu\u00e9 tipo de informaci\u00f3n queremos guardar en nuestra variable y darle un nombre. Existe diferentes tipos de informaci\u00f3n que podemos utilizar para definir nuestras variables. Se les conoce como tipos de datos o data types. Los tipos de datos son palabras reservas keywords en Java, es decir, no podemos utilizarlas fuera del contexto de tipo de datos. Para definir una variable, necesitamos especificar el tipo de datos, luego darle un nombre a nuestra variable, y opcionalmente, podemos agregar una expresi\u00f3n para inicializar la variable con un valor.","title":"Variables"},{"location":"ud1/131variables/#reglas-para-el-nombrado-de-variables","text":"Tiene que comenzar con una letra o '_', nunca con n\u00fameros. Puede contener n\u00fameros. No debe contener espacios en blanco. No debe ser muy largo y debe expresar algo en el contexto. No se pueden usar palabras reservadas. May\u00fasculas y min\u00fasculas se tratan diferente. Definimos nuestra primera variable en el programa de la siguiente forma: La l\u00ednea que acabamos de escribir se conoce como sentencia de declaraci\u00f3n .","title":"Reglas para el nombrado de variables"},{"location":"ud1/131variables/#keywords","text":"Son palabras reservadas del lenguaje. Es decir, son palabras que tienen un significado especial en Java y no puedes usarlas fuera de ese contexto. Ejemplos: public, class, void, static, etc. Existen 61 keywords en Java.","title":"Keywords"},{"location":"ud1/131variables/#vida-de-las-variables","text":"Las variables son memorias reservadas para almacenar valores en RAM. Estas posiciones de memoria se liberan tan pronto como termina la vida de la variable. Seg\u00fan la vida de las variables, hay tres tipos de Variables. 1. Variables locales : La vida permanece dentro de un bloque donde se ha declarado. 2. Variables de instancia : Declaradas dentro de la Clase pero fuera de los m\u00e9todos. No deber\u00eda ser est\u00e1tico. 3. Variables est\u00e1ticas : es como una variable global. Declarado como est\u00e1tico en la clase pero fuera de los m\u00e9todos. static int pi = 3.14 ;","title":"Vida de las variables"},{"location":"ud1/131variables/#visibilidad","text":"En las variables locales, su \u00e1mbito y uso se encuentra dentro del m\u00e9todo o bloque en el que se defini\u00f3 y se destruyen despu\u00e9s de la ejecuci\u00f3n del m\u00e9todo. Es decir, no se puede usar una variable local fuera del m\u00e9todo actual. A las variables de instancia se puede acceder solo a trav\u00e9s de objetos de la clase para la que se defini\u00f3. Un campo / variable est\u00e1tico pertenece a la clase y se cargar\u00e1 en la memoria junto con la clase. Se invocan sin crear un objeto. (Usando el nombre de la clase como referencia). Solo hay una copia de la variable est\u00e1tica disponible en toda la clase, es decir, el valor de la variable est\u00e1tica ser\u00e1 el mismo en todos los objetos. Puede definir una variable est\u00e1tica utilizando la palabra clave static .","title":"Visibilidad"},{"location":"ud1/132sentencias/","text":"Sentencias Hemos comentado que un programa es un conjunto de instrucciones. Estas instrucciones se llaman sentencias o statements en ingl\u00e9s. Una sentencia es un segmento de c\u00f3digo que realiza una acci\u00f3n en el programa. A medida que se ejecuta un programa, decimos que ejecuta sentencias, lo que significa que lleva a cabo las acciones especificadas por esas sentencias. En nuestro programa Hello World, tenemos un statement en la l\u00ednea 4 y 6 . La regla en Java es que las sentencias deben terminar con un punto y coma. Si se olvida, se producir\u00eda un error de sintaxis. Sentencias de declaraci\u00f3n Se usan para definir una variable de un tipo de dato en particular. En Java, una variable debe declararse antes de que pueda usarse en un programa. De no hacerlo, se producir\u00eda un error de sintaxis. En su forma m\u00e1s simple una declaraci\u00f3n incluye el tipo de datos y el nombre de la variable. Opcionalmente se puede establecer la variable a cierto valor. Es decir, se dice que se ha inicializado. Ejemplos : int numero ; int a = 3 ; //se crea la variable a y se le asigna el valor 3 int dia ; Sentencias de asignaci\u00f3n Una sentencia de asignaci\u00f3n es una sentencia que almacena (asigna) un valor en una variable. Una sentencia de asignaci\u00f3n utiliza el signo igual (=) como operador de asignaci\u00f3n. En su forma m\u00e1s simple, tiene una variable en el lado izquierdo del signo igual y alg\u00fan tipo de valor en el lado derecho. Ejemplos : numero = 6 ; //asigno el valor 6 a la variable numero a = 0 ; dia = 22 ; En el siguiente ejemplo, hay variables tanto a la izquierda como a la derecha del operador de asignaci\u00f3n (=). Pero tienen un significado muy diferente. La variable de la derecha (num2) se trata como un valor. Si esa variable almacena 20, entonces ese es su valor. De hecho, cualquier cosa que ocurra en el lado derecho de un operador de asignaci\u00f3n se trata como un valor. La variable de la izquierda (num1) se trata como una ubicaci\u00f3n de memoria. Es donde se almacenar\u00e1 el valor 20 como resultado de la ejecuci\u00f3n de esta declaraci\u00f3n. El efecto de esta declaraci\u00f3n es copia el valor almacenado en num2 en num1, como se ilustra en la siguiente imagen. Ejemplo //se crean las variables int num1 = 10 ; int num2 = 20 ; num1 = num2 ; //se copia el valor de num2 a la variable num1 Challenge Question En el programa Hello World, imprime por pantalla la variable miPrimerEntero que hemos creado. Challenge2 Question En el programa Hello World, crea las siguientes variables adicionales justo debajo de la declaraci\u00f3n \"int miPrimerEntero = 7;\" en el programa: num1 de tipo int y con un valor de 10. num2 de tipo int y con un valor de 8. y una tercera total que sea la suma de las anteriores. imprime por pantalla la variable total. Paquetes en Java - Java Packages Un paquete es una forma de organizar nuestros proyectos Java. Se pueden ver como carpetas dentro de la estructuraci\u00f3n interna del proyecto. Los paquetes son el mecanismo que usa Java para facilitar la modularidad del c\u00f3digo. Un paquete puede contener una o m\u00e1s definiciones de interfaces y clases, distribuy\u00e9ndose habitualmente como un archivo. Para utilizar los elementos de un paquete es necesario importar este en el m\u00f3dulo de c\u00f3digo en curso, usando para ello la sentencia import . IntelliJ nos ofrece la opci\u00f3n de automatizar esto cuando creamos un proyecto, simplemente seleccionando la opci\u00f3n:","title":"Sentencias y paquetes"},{"location":"ud1/132sentencias/#sentencias","text":"Hemos comentado que un programa es un conjunto de instrucciones. Estas instrucciones se llaman sentencias o statements en ingl\u00e9s. Una sentencia es un segmento de c\u00f3digo que realiza una acci\u00f3n en el programa. A medida que se ejecuta un programa, decimos que ejecuta sentencias, lo que significa que lleva a cabo las acciones especificadas por esas sentencias. En nuestro programa Hello World, tenemos un statement en la l\u00ednea 4 y 6 . La regla en Java es que las sentencias deben terminar con un punto y coma. Si se olvida, se producir\u00eda un error de sintaxis.","title":"Sentencias"},{"location":"ud1/132sentencias/#sentencias-de-declaracion","text":"Se usan para definir una variable de un tipo de dato en particular. En Java, una variable debe declararse antes de que pueda usarse en un programa. De no hacerlo, se producir\u00eda un error de sintaxis. En su forma m\u00e1s simple una declaraci\u00f3n incluye el tipo de datos y el nombre de la variable. Opcionalmente se puede establecer la variable a cierto valor. Es decir, se dice que se ha inicializado. Ejemplos : int numero ; int a = 3 ; //se crea la variable a y se le asigna el valor 3 int dia ;","title":"Sentencias de declaraci\u00f3n"},{"location":"ud1/132sentencias/#sentencias-de-asignacion","text":"Una sentencia de asignaci\u00f3n es una sentencia que almacena (asigna) un valor en una variable. Una sentencia de asignaci\u00f3n utiliza el signo igual (=) como operador de asignaci\u00f3n. En su forma m\u00e1s simple, tiene una variable en el lado izquierdo del signo igual y alg\u00fan tipo de valor en el lado derecho. Ejemplos : numero = 6 ; //asigno el valor 6 a la variable numero a = 0 ; dia = 22 ; En el siguiente ejemplo, hay variables tanto a la izquierda como a la derecha del operador de asignaci\u00f3n (=). Pero tienen un significado muy diferente. La variable de la derecha (num2) se trata como un valor. Si esa variable almacena 20, entonces ese es su valor. De hecho, cualquier cosa que ocurra en el lado derecho de un operador de asignaci\u00f3n se trata como un valor. La variable de la izquierda (num1) se trata como una ubicaci\u00f3n de memoria. Es donde se almacenar\u00e1 el valor 20 como resultado de la ejecuci\u00f3n de esta declaraci\u00f3n. El efecto de esta declaraci\u00f3n es copia el valor almacenado en num2 en num1, como se ilustra en la siguiente imagen. Ejemplo //se crean las variables int num1 = 10 ; int num2 = 20 ; num1 = num2 ; //se copia el valor de num2 a la variable num1","title":"Sentencias de asignaci\u00f3n"},{"location":"ud1/132sentencias/#challenge","text":"Question En el programa Hello World, imprime por pantalla la variable miPrimerEntero que hemos creado.","title":"Challenge"},{"location":"ud1/132sentencias/#challenge2","text":"Question En el programa Hello World, crea las siguientes variables adicionales justo debajo de la declaraci\u00f3n \"int miPrimerEntero = 7;\" en el programa: num1 de tipo int y con un valor de 10. num2 de tipo int y con un valor de 8. y una tercera total que sea la suma de las anteriores. imprime por pantalla la variable total.","title":"Challenge2"},{"location":"ud1/132sentencias/#paquetes-en-java-java-packages","text":"Un paquete es una forma de organizar nuestros proyectos Java. Se pueden ver como carpetas dentro de la estructuraci\u00f3n interna del proyecto. Los paquetes son el mecanismo que usa Java para facilitar la modularidad del c\u00f3digo. Un paquete puede contener una o m\u00e1s definiciones de interfaces y clases, distribuy\u00e9ndose habitualmente como un archivo. Para utilizar los elementos de un paquete es necesario importar este en el m\u00f3dulo de c\u00f3digo en curso, usando para ello la sentencia import . IntelliJ nos ofrece la opci\u00f3n de automatizar esto cuando creamos un proyecto, simplemente seleccionando la opci\u00f3n:","title":"Paquetes en Java - Java Packages"},{"location":"ud1/142noprimitive/","text":"No primitivos u objetos En Java, los tipos de datos no primitivos son los tipos de datos de referencia o los tipos de datos creados por el usuario. Todos los tipos de datos no primitivos se implementan utilizando conceptos de objeto. Cada variable del tipo de datos no primitivo es un objeto. Los tipos de datos no primitivos pueden utilizar m\u00e9todos adicionales para realizar determinadas operaciones. El valor predeterminado de la variable de tipo de datos no primitivos es nulo. String - Cadena de caracteres String es una clase integrada en el lenguaje Java ampliamente utilizada y definido en el paquete java.lang. Representa cadenas de caracteres y se utilizan para almacenar varios atributos como nombre de usuario, contrase\u00f1a, etc. Los String son inmutables ; es decir, no se pueden modificar una vez creados. Siempre que se modifica un objeto String, en realidad se crea uno nuevo String. Existen varias formas para crear un String: String texto = \"Severo Ochoa\" ; String texto2 = new String ( \"Severo Ochoa\" ); Asignaci\u00f3n de memoria de objetos String La memoria se divide en dos partes, el String Pool y la memoria Heap. Veamos como funcionar\u00eda para la imagen anterior. Siempre que creamos un String con comillas dobles, se almacenan en String Pool. String Pool almacena el \u00fanico valor en \u00e9l. Es por eso que, String s1 = \"blogs\" se almacenan como el primer valor en el String Pool. Siempre que creamos un objeto usando la palabra clave new , se almacena en la memoria Heap pero fuera del String Pool. Aqu\u00ed se puede almacenar valores duplicados ya que pertenece a diferentes objetos. Entonces, para la declaraci\u00f3n String s2 = new String(\u201cblogs\u201d), aunque el valor de s1 y s2 es el mismo, s2 se almacenar\u00e1 fuera del String Pool. Cuando creamos otro String usando comillas dobles, primero verifica todos los valores en el String Pool y si coincide con alguno se asigna la misma ubicaci\u00f3n asignada a otro objeto de referencia. Por lo tanto, String s3 = \u201dblogs\u201d no agregar\u00e1 una nueva entrada en el String Pool. Pero si creamos otro objeto con un valor existente usando la palabra clave new . Asignar\u00e1 nueva memoria al nuevo objeto en el Heap. Por lo tanto, a String s4 = new String (\"blogs\") se le asignar\u00e1 nueva memoria. Ahora, si manipulamos el valor en s1 usando s1 = \u201dNew\u201c + s1, no actualizar\u00e1 la entrada o referencia existente de s1. Este proceso crear\u00e1 una nueva entrada en el String Pool con el valor \"New blogs\" y la referencia de memoria cambiar\u00eda para el objeto s1. Java String Class Methods La clase java.lang.String proporciona muchos m\u00e9todos \u00fatiles para realizar operaciones en la secuencia de valores char. Date En sus inicios se crearon las clases java.util.Date y java.sql.Date para almacenar y manejar fechas. Pero ambas clases son defectuosas en dise\u00f1o e implementaci\u00f3n. Por ejemplo, las clases existentes (como java.util.Date y SimpleDateFormatter ) no son thread-safe, lo que genera posibles problemas de concurrencia para los usuarios. Por tanto, desde Java 8 y posteriores se ha desarrollado una nueva API java.time que resuelve los problemas que presentaban las librer\u00edas anteriores. More information Why do we need a new date and time library? Ejemplo de c\u00f3digo para mostara la fecha y la hora: //mostrar fecha LocalDate ld = LocalDate . now (); System . out . println ( ld ); //mostrar hora LocalTime lt = LocalTime . now (); System . out . println ( lt ); //mostrar fecha y hora LocalDateTime ldt = LocalDateTime . now (); System . out . println ( ldt ); //formatear la fecha con un formato dado DateTimeFormatter formatter = DateTimeFormatter . ofPattern ( \"dd-MM-yyyy HH:mm:ss\" ); String formatted = formatter . format ( ldt ); System . out . println ( formatted );","title":"Datos no primitivos"},{"location":"ud1/142noprimitive/#no-primitivos-u-objetos","text":"En Java, los tipos de datos no primitivos son los tipos de datos de referencia o los tipos de datos creados por el usuario. Todos los tipos de datos no primitivos se implementan utilizando conceptos de objeto. Cada variable del tipo de datos no primitivo es un objeto. Los tipos de datos no primitivos pueden utilizar m\u00e9todos adicionales para realizar determinadas operaciones. El valor predeterminado de la variable de tipo de datos no primitivos es nulo.","title":"No primitivos u objetos"},{"location":"ud1/142noprimitive/#string-cadena-de-caracteres","text":"String es una clase integrada en el lenguaje Java ampliamente utilizada y definido en el paquete java.lang. Representa cadenas de caracteres y se utilizan para almacenar varios atributos como nombre de usuario, contrase\u00f1a, etc. Los String son inmutables ; es decir, no se pueden modificar una vez creados. Siempre que se modifica un objeto String, en realidad se crea uno nuevo String. Existen varias formas para crear un String: String texto = \"Severo Ochoa\" ; String texto2 = new String ( \"Severo Ochoa\" );","title":"String - Cadena de caracteres"},{"location":"ud1/142noprimitive/#asignacion-de-memoria-de-objetos-string","text":"La memoria se divide en dos partes, el String Pool y la memoria Heap. Veamos como funcionar\u00eda para la imagen anterior. Siempre que creamos un String con comillas dobles, se almacenan en String Pool. String Pool almacena el \u00fanico valor en \u00e9l. Es por eso que, String s1 = \"blogs\" se almacenan como el primer valor en el String Pool. Siempre que creamos un objeto usando la palabra clave new , se almacena en la memoria Heap pero fuera del String Pool. Aqu\u00ed se puede almacenar valores duplicados ya que pertenece a diferentes objetos. Entonces, para la declaraci\u00f3n String s2 = new String(\u201cblogs\u201d), aunque el valor de s1 y s2 es el mismo, s2 se almacenar\u00e1 fuera del String Pool. Cuando creamos otro String usando comillas dobles, primero verifica todos los valores en el String Pool y si coincide con alguno se asigna la misma ubicaci\u00f3n asignada a otro objeto de referencia. Por lo tanto, String s3 = \u201dblogs\u201d no agregar\u00e1 una nueva entrada en el String Pool. Pero si creamos otro objeto con un valor existente usando la palabra clave new . Asignar\u00e1 nueva memoria al nuevo objeto en el Heap. Por lo tanto, a String s4 = new String (\"blogs\") se le asignar\u00e1 nueva memoria. Ahora, si manipulamos el valor en s1 usando s1 = \u201dNew\u201c + s1, no actualizar\u00e1 la entrada o referencia existente de s1. Este proceso crear\u00e1 una nueva entrada en el String Pool con el valor \"New blogs\" y la referencia de memoria cambiar\u00eda para el objeto s1.","title":"Asignaci\u00f3n de memoria de objetos String"},{"location":"ud1/142noprimitive/#java-string-class-methods","text":"La clase java.lang.String proporciona muchos m\u00e9todos \u00fatiles para realizar operaciones en la secuencia de valores char.","title":"Java String Class Methods"},{"location":"ud1/142noprimitive/#date","text":"En sus inicios se crearon las clases java.util.Date y java.sql.Date para almacenar y manejar fechas. Pero ambas clases son defectuosas en dise\u00f1o e implementaci\u00f3n. Por ejemplo, las clases existentes (como java.util.Date y SimpleDateFormatter ) no son thread-safe, lo que genera posibles problemas de concurrencia para los usuarios. Por tanto, desde Java 8 y posteriores se ha desarrollado una nueva API java.time que resuelve los problemas que presentaban las librer\u00edas anteriores. More information Why do we need a new date and time library? Ejemplo de c\u00f3digo para mostara la fecha y la hora: //mostrar fecha LocalDate ld = LocalDate . now (); System . out . println ( ld ); //mostrar hora LocalTime lt = LocalTime . now (); System . out . println ( lt ); //mostrar fecha y hora LocalDateTime ldt = LocalDateTime . now (); System . out . println ( ldt ); //formatear la fecha con un formato dado DateTimeFormatter formatter = DateTimeFormatter . ofPattern ( \"dd-MM-yyyy HH:mm:ss\" ); String formatted = formatter . format ( ldt ); System . out . println ( formatted );","title":"Date"},{"location":"ud1/14datatypejava/","text":"Tipos de datos Un tipo de datos es un conjunto de valores y un conjunto de operaciones definidas en ellos. Se pueden clasificar en primitivos y objetos. Primitivos Los primitivos son los m\u00e1s b\u00e1sicos y fundamentales, vienen integrados en Java. Especifican el tipo de valor almacenado en una variable y el tama\u00f1o de la memoria. Hay 8 tipos primitivos de datos integrados en el lenguaje Java. Estos incluyen: int, byte, short, long, float, double, boolean y char. Primitive data type Wrapper class byte Byte short Short int Integer long Long float Float double Double boolean Boolean char Character byte Como su propio nombre denota, emplea un solo byte (8 bits) de almacenamiento. Esto permite almacenar valores en el rango [-128, 127]. Raramente se usa. Ocupa menos memoria y puede ser m\u00e1s r\u00e1pido accedido. byte b = 2 ; short Usa el doble de almacenamiento que el anterior, es decir, ocupa 16 bits [-32.768, 32.767]. short s = 3467 ; int emplea 4 bytes (32 bits) de almacenamiento y es el tipo de dato entero m\u00e1s empleado. Necesita cuatro veces el espacio que ocupa un byte. Es el entero predeterminado usado en Java. int maxValor = 2147483647 ; // after java 7 and higher int maxValue = 2_147_483_647 ; long es el tipo entero de mayor tama\u00f1o, 8 bytes (64 bits). Para definir un long, tenemos que hacerlo de la siguiente forma: long myLongNumber = 500L ; float tiene una parte flotante que sirve para expresar n\u00fameros decimales. Es de simple precisi\u00f3n (formato y cantidad de espacio que ocupa) porque ocupa 32 bits. No se recomienda mucho su uso. float f = 4 ; float f = 4f ; //tambi\u00e9n v\u00e1lida double es un n\u00famero de precisi\u00f3n doble y ocupa 64 bits. Es el flotante predeterminado en Java. Se recomienda su uso. Muchas librer\u00edas internas de Java, relacionadas con operaciones matem\u00e1ticas, usan double. double d = 5 ; double d = 5d ; //tambi\u00e9n v\u00e1lida char se utiliza para almacenar caracteres (letras, n\u00fameros, signos, etc.) individuales. Ocupa 2 bytes en memoria (16 bits). Permite almacenar caracteres Unicode. Unicode es un est\u00e1ndar de codificaci\u00f3n internacional que nos permite representar diferentes idiomas; y la forma en que funciona es usando una combinaci\u00f3n de los dos bytes que un char ocupa en la memoria, que puede representar hasta 65535 diferentes tipos de caracteres. Unicode table. char c = 'P' ; char u = '\\u00A2' ; //print unicode character Un car\u00e1cter precedido por una barra invertida () es una secuencia de escape y tiene un significado especial para el compilador. La siguiente tabla muestra las secuencias de escape de Java: boolean solo permite almacenar dos posibles valores que son true o false . Tiene la finalidad de facilitar el trabajo con valores \"verdadero/falso\" (booleanos), resultantes por regla general de evaluar expresiones. Este tipo de datos representa un bit de informaci\u00f3n, pero su \"tama\u00f1o\" no es algo que est\u00e9 definido con precisi\u00f3n. boolean isMyNamePatri = true ; Wrapper classes (clases contenedores) Las clases contenedoras proporcionan una forma de utilizar tipos de datos primitivos como objetos. En Java, tenemos una Wrapper class para cada uno de los 8 tipos de datos primitivos. Gracias a esto, podemos realizar operaciones en un dato primitivo como por ejemplo en un int: int minimoValorInt = Integer . MIN_VALUE ;","title":"Datos primitivos"},{"location":"ud1/14datatypejava/#tipos-de-datos","text":"Un tipo de datos es un conjunto de valores y un conjunto de operaciones definidas en ellos. Se pueden clasificar en primitivos y objetos.","title":"Tipos de datos"},{"location":"ud1/14datatypejava/#primitivos","text":"Los primitivos son los m\u00e1s b\u00e1sicos y fundamentales, vienen integrados en Java. Especifican el tipo de valor almacenado en una variable y el tama\u00f1o de la memoria. Hay 8 tipos primitivos de datos integrados en el lenguaje Java. Estos incluyen: int, byte, short, long, float, double, boolean y char. Primitive data type Wrapper class byte Byte short Short int Integer long Long float Float double Double boolean Boolean char Character","title":"Primitivos"},{"location":"ud1/14datatypejava/#byte","text":"Como su propio nombre denota, emplea un solo byte (8 bits) de almacenamiento. Esto permite almacenar valores en el rango [-128, 127]. Raramente se usa. Ocupa menos memoria y puede ser m\u00e1s r\u00e1pido accedido. byte b = 2 ;","title":"byte"},{"location":"ud1/14datatypejava/#short","text":"Usa el doble de almacenamiento que el anterior, es decir, ocupa 16 bits [-32.768, 32.767]. short s = 3467 ;","title":"short"},{"location":"ud1/14datatypejava/#int","text":"emplea 4 bytes (32 bits) de almacenamiento y es el tipo de dato entero m\u00e1s empleado. Necesita cuatro veces el espacio que ocupa un byte. Es el entero predeterminado usado en Java. int maxValor = 2147483647 ; // after java 7 and higher int maxValue = 2_147_483_647 ;","title":"int"},{"location":"ud1/14datatypejava/#long","text":"es el tipo entero de mayor tama\u00f1o, 8 bytes (64 bits). Para definir un long, tenemos que hacerlo de la siguiente forma: long myLongNumber = 500L ;","title":"long"},{"location":"ud1/14datatypejava/#float","text":"tiene una parte flotante que sirve para expresar n\u00fameros decimales. Es de simple precisi\u00f3n (formato y cantidad de espacio que ocupa) porque ocupa 32 bits. No se recomienda mucho su uso. float f = 4 ; float f = 4f ; //tambi\u00e9n v\u00e1lida","title":"float"},{"location":"ud1/14datatypejava/#double","text":"es un n\u00famero de precisi\u00f3n doble y ocupa 64 bits. Es el flotante predeterminado en Java. Se recomienda su uso. Muchas librer\u00edas internas de Java, relacionadas con operaciones matem\u00e1ticas, usan double. double d = 5 ; double d = 5d ; //tambi\u00e9n v\u00e1lida","title":"double"},{"location":"ud1/14datatypejava/#char","text":"se utiliza para almacenar caracteres (letras, n\u00fameros, signos, etc.) individuales. Ocupa 2 bytes en memoria (16 bits). Permite almacenar caracteres Unicode. Unicode es un est\u00e1ndar de codificaci\u00f3n internacional que nos permite representar diferentes idiomas; y la forma en que funciona es usando una combinaci\u00f3n de los dos bytes que un char ocupa en la memoria, que puede representar hasta 65535 diferentes tipos de caracteres. Unicode table. char c = 'P' ; char u = '\\u00A2' ; //print unicode character Un car\u00e1cter precedido por una barra invertida () es una secuencia de escape y tiene un significado especial para el compilador. La siguiente tabla muestra las secuencias de escape de Java:","title":"char"},{"location":"ud1/14datatypejava/#boolean","text":"solo permite almacenar dos posibles valores que son true o false . Tiene la finalidad de facilitar el trabajo con valores \"verdadero/falso\" (booleanos), resultantes por regla general de evaluar expresiones. Este tipo de datos representa un bit de informaci\u00f3n, pero su \"tama\u00f1o\" no es algo que est\u00e9 definido con precisi\u00f3n. boolean isMyNamePatri = true ;","title":"boolean"},{"location":"ud1/14datatypejava/#wrapper-classes-clases-contenedores","text":"Las clases contenedoras proporcionan una forma de utilizar tipos de datos primitivos como objetos. En Java, tenemos una Wrapper class para cada uno de los 8 tipos de datos primitivos. Gracias a esto, podemos realizar operaciones en un dato primitivo como por ejemplo en un int: int minimoValorInt = Integer . MIN_VALUE ;","title":"Wrapper classes (clases contenedores)"},{"location":"ud1/15operators/","text":"Operadores Los operadores son s\u00edmbolos especiales en Java que realizan operaciones entre uno o varios operandos y devuelve un resultado. Uno de los m\u00e1s usados es el operador suma (+) como hemos visto en clases anteriores. Operando Es cualquier t\u00e9rmino, que puede ser una variable o valor y que es manipulado por un operador. int valor = 8 ; int numero = valor + 12 ; En el ejemplo anterior, + es el operador y valor y 12 son los operandos. valor + 12 es una expresi\u00f3n que devuelve el resultado de 20. Expresiones Una expresi\u00f3n es una combinaci\u00f3n de literales, operadores, nombres de variables y par\u00e9ntesis que se utilizan para calcular un valor. int miPrimerEntero = 7 + 5 ; int resultado = 0 ; resultado = ( miPrimerEntero * 10 ) / ( 32 + 12 ); Java examina la expresi\u00f3n de la derecha del signo igual y realiza el c\u00e1lculo de una expresi\u00f3n matem\u00e1tica. Despu\u00e9s asigna ese valor a la variable resultado. Podr\u00edamos complicar m\u00e1s la expresi\u00f3n utilizando operadores como par\u00e9ntesis, multiplicaciones, divisiones, etc. Las partes de una expresi\u00f3n deben estar ordenadas correctamente. Las reglas para las expresiones Java correctas son casi las mismas que las del \u00e1lgebra: Cada operador debe tener el n\u00famero correcto de operandos. Multiplicaci\u00f3n *, Divisi\u00f3n /, Suma +, Resta: debe tener dos operandos, uno en cada lado. La negaci\u00f3n - y unario m\u00e1s + deben ir seguidos de un operando. Los par\u00e9ntesis () pueden rodear una expresi\u00f3n legal para convertirla en operando. Expresiones mixtas con int y double Si ambos operandos de un operador aritm\u00e9tico son de tipo int, entonces la operaci\u00f3n es una operaci\u00f3n entera. Si alg\u00fan operando es de punto flotante, entonces la operaci\u00f3n es de punto flotante. Tipos de operadores en Java Java proporciona muchos tipos de operadores que se pueden usar seg\u00fan la necesidad. Se clasifican seg\u00fan la funcionalidad que brindan. Algunos de los tipos son los siguientes: Operadores aritm\u00e9ticos, unarios, de asignaci\u00f3n, relacionales, l\u00f3gicos, etc. Operador de asignaci\u00f3n (=) Es uno de los operadores m\u00e1s usados. Se usa para asignar un valor a cualquier variable. Tiene una asociaci\u00f3n de derecha a izquierda, es decir, el valor dado en el lado derecho del operador se asigna a la variable de la izquierda y, por lo tanto, el valor del lado derecho debe declararse antes de usarlo o debe ser una constante. Operadores aritm\u00e9ticos Se utilizan para realizar operaciones aritm\u00e9ticas simples. S\u00edmbolo Operaci\u00f3n Descripci\u00f3n + Suma Realiza la suma de los operandos. - Resta Realiza la resta de los operandos. * Producto Multiplica los operandos. / Divisi\u00f3n Realiza la divisi\u00f3n. % M\u00f3dulo Calcula el resto. Operadores unarios Los operadores unarios solo necesitan un operando. Se usan para incrementar, disminuir o negar un valor. S\u00edmbolo Operaci\u00f3n Descripci\u00f3n ++ Incremento Incrementa el valor en 1 unidad. -- Decremento El valor disminuye en 1 unidad. ! NOT l\u00f3gico Invierte un valor booleano. Existen dos versiones de estos operadores: Pre-incremento y pre-decremento. El valor se aumenta/disminuye primero y luego se calcula el resultado. int a = 8 , b = 1 ; b = ++ a ; //b=9, a=9 Post-Incremento y post-decremento: el valor se usa por primera vez para calcular el resultado y luego se incrementa/decrementa. int a = 8 , b = 1 ; b = a ++ ; //b = 8, a = 9 Operadores relacionales Estos operadores se utilizan para verificar relaciones como igualdad, mayor que, menor que. Devuelven el resultado booleano despu\u00e9s de la comparaci\u00f3n. S\u00edmbolo Operaci\u00f3n Descripci\u00f3n == Igual a Devuelve verdadero si el valor de la izquierda del s\u00edmbolo es igual al de la derecha. != Distinto a Devuelve verdadero si el valor de la izquierda es distinto al de la derecha. < Menor que Devuelve verdadero si el valor de la izquierda es menor que el de la derecha. <= Menor o igual que Devuelve verdadero si el valor de la izquierda es menor o igual que el de la derecha. > Mayor que Devuelve verdadero si el valor de la izquierda es mayor que el de la derecha. >= Mayor o igual que Devuelve verdadero si el valor de la izquierda es mayor o igual al de la derecha. int a = 20 , b = 10 ; System . out . println ( \"a == b :\" + ( a == b )); //Devuelve falso, porque a no es igual a b Operadores l\u00f3gicos Estos operadores se utilizan para realizar operaciones l\u00f3gicas AND y OR . Se usa ampliamente en sentencias if-then o bucles para verificar condiciones, establecer un punto de salida de un bucle o la toma de decisiones. Los operadores condicionales son: S\u00edmbolo Operaci\u00f3n Descripci\u00f3n && AND l\u00f3gico Devuelve verdadero cuando ambas condiciones son ciertas. || OR l\u00f3gico Devuelve verdadero si al menos una condici\u00f3n es cierta. int a = 20 , b = 10 , c = 10 ; System . out . println (( b == c && a == c )); //False System . out . println (( a == c && b == c )); //False System . out . println (( a == b || b == c )); //True Operadores de bits S\u00edmbolo Operaci\u00f3n Descripci\u00f3n & AND Si ambos bits de entrada son 1, establece como resultado 1. De lo contrario 0. | OR Si por lo menos uno de los bits de entrada es 1, establece como resultado 1. De lo contrario 0. ^ XOR Si uno de los bits de entrada es 1 y el otro 0, establece como resultado 1. Si los bits son iguales establece 0. ~ NOT Invierte todos los bits y devuelve el resultado en complemento a 2. Operador ternario (?:) Ternario es una versi\u00f3n abreviada de la sentencia if-else. Tiene tres operandos y de ah\u00ed el nombre ternario. El formato general es: La declaraci\u00f3n anterior significa que si la condici\u00f3n se eval\u00faa como verdadera, entonces ejecuta las instrucciones despu\u00e9s del \u2018?\u2018 de lo contrario, ejecuta las instrucciones despu\u00e9s de \u2018:\u2018. int nota = 7 ; String notaFinal = ( nota >= 5 ) ? \"Aprobado\" : \"Suspendido\" ; System . out . println ( notaFinal ); //muestra Aprobado Abreviaciones En muchos casos, el operador de asignaci\u00f3n se puede combinar con otros operadores para construir una versi\u00f3n m\u00e1s corta de la declaraci\u00f3n llamada Declaraci\u00f3n Compuesta (Compound Statement). += , para sumar el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda. int a = 5 ; a += 5 ; // a = a + 5; \u2013 = , para restar el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda. int a = 5 ; a -= 5 ; // a = a - 5; *= , para multiplicar el operando izquierdo con el operando derecho y luego asign\u00e1ndolo a la variable de la izquierda. int a = 5 ; a *= 5 ; // a = a * 5; / = , para dividir el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda. int a = 5 ; a /= 5 ; // a = a / 5; % = , para asignar el m\u00f3dulo del operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda. int a = 5 ; a %= 5 ; // a = a % 5; Precedencia de operadores El orden de precedencia, es decir, como Java decide la prioridad al evaluar los operadores en una expresi\u00f3n, se puede ver en Java Operator Precedence Table Conversiones de tipo Conversiones por defecto Las reglas de Java para saber el tipo de datos resultante de una expresi\u00f3n se siguen las siguientes reglas: Si alg\u00fan operando es El otro operando se transforma a double double float float long long byte or short int Si se aplican dos regla, se elige la que aparece primero en la tabla. Conversiones forzosas (casting entre tipos nativos) Es una forma de convertir un n\u00famero de un tipo a otro tipo de dato. Para hacerlo ponemos en par\u00e9ntesis el tipo de dato al que queremos convertirlo. byte miByte = ( byte ) ( 14 / 2 ); //conviero la operaci\u00f3n divisi\u00f3n que devuelve un int a byte //Otra forma float a = 8.0f ; int b = 10 ; b = ( int ) a ; //convierto el tipo float a int Otros operadores Existen m\u00e1s operadores que no se han mencionado en el curso. Si se desea consultar todos los operadores de Java se pueden ver en su documentaci\u00f3n oficial. More information","title":"1.5.- Operadores y expresiones"},{"location":"ud1/15operators/#operadores","text":"Los operadores son s\u00edmbolos especiales en Java que realizan operaciones entre uno o varios operandos y devuelve un resultado. Uno de los m\u00e1s usados es el operador suma (+) como hemos visto en clases anteriores.","title":"Operadores"},{"location":"ud1/15operators/#operando","text":"Es cualquier t\u00e9rmino, que puede ser una variable o valor y que es manipulado por un operador. int valor = 8 ; int numero = valor + 12 ; En el ejemplo anterior, + es el operador y valor y 12 son los operandos. valor + 12 es una expresi\u00f3n que devuelve el resultado de 20.","title":"Operando"},{"location":"ud1/15operators/#expresiones","text":"Una expresi\u00f3n es una combinaci\u00f3n de literales, operadores, nombres de variables y par\u00e9ntesis que se utilizan para calcular un valor. int miPrimerEntero = 7 + 5 ; int resultado = 0 ; resultado = ( miPrimerEntero * 10 ) / ( 32 + 12 ); Java examina la expresi\u00f3n de la derecha del signo igual y realiza el c\u00e1lculo de una expresi\u00f3n matem\u00e1tica. Despu\u00e9s asigna ese valor a la variable resultado. Podr\u00edamos complicar m\u00e1s la expresi\u00f3n utilizando operadores como par\u00e9ntesis, multiplicaciones, divisiones, etc. Las partes de una expresi\u00f3n deben estar ordenadas correctamente. Las reglas para las expresiones Java correctas son casi las mismas que las del \u00e1lgebra: Cada operador debe tener el n\u00famero correcto de operandos. Multiplicaci\u00f3n *, Divisi\u00f3n /, Suma +, Resta: debe tener dos operandos, uno en cada lado. La negaci\u00f3n - y unario m\u00e1s + deben ir seguidos de un operando. Los par\u00e9ntesis () pueden rodear una expresi\u00f3n legal para convertirla en operando.","title":"Expresiones"},{"location":"ud1/15operators/#expresiones-mixtas-con-int-y-double","text":"Si ambos operandos de un operador aritm\u00e9tico son de tipo int, entonces la operaci\u00f3n es una operaci\u00f3n entera. Si alg\u00fan operando es de punto flotante, entonces la operaci\u00f3n es de punto flotante.","title":"Expresiones mixtas con int y double"},{"location":"ud1/15operators/#tipos-de-operadores-en-java","text":"Java proporciona muchos tipos de operadores que se pueden usar seg\u00fan la necesidad. Se clasifican seg\u00fan la funcionalidad que brindan. Algunos de los tipos son los siguientes: Operadores aritm\u00e9ticos, unarios, de asignaci\u00f3n, relacionales, l\u00f3gicos, etc.","title":"Tipos de operadores en Java"},{"location":"ud1/15operators/#operador-de-asignacion","text":"Es uno de los operadores m\u00e1s usados. Se usa para asignar un valor a cualquier variable. Tiene una asociaci\u00f3n de derecha a izquierda, es decir, el valor dado en el lado derecho del operador se asigna a la variable de la izquierda y, por lo tanto, el valor del lado derecho debe declararse antes de usarlo o debe ser una constante.","title":"Operador de asignaci\u00f3n (=)"},{"location":"ud1/15operators/#operadores-aritmeticos","text":"Se utilizan para realizar operaciones aritm\u00e9ticas simples. S\u00edmbolo Operaci\u00f3n Descripci\u00f3n + Suma Realiza la suma de los operandos. - Resta Realiza la resta de los operandos. * Producto Multiplica los operandos. / Divisi\u00f3n Realiza la divisi\u00f3n. % M\u00f3dulo Calcula el resto.","title":"Operadores aritm\u00e9ticos"},{"location":"ud1/15operators/#operadores-unarios","text":"Los operadores unarios solo necesitan un operando. Se usan para incrementar, disminuir o negar un valor. S\u00edmbolo Operaci\u00f3n Descripci\u00f3n ++ Incremento Incrementa el valor en 1 unidad. -- Decremento El valor disminuye en 1 unidad. ! NOT l\u00f3gico Invierte un valor booleano. Existen dos versiones de estos operadores: Pre-incremento y pre-decremento. El valor se aumenta/disminuye primero y luego se calcula el resultado. int a = 8 , b = 1 ; b = ++ a ; //b=9, a=9 Post-Incremento y post-decremento: el valor se usa por primera vez para calcular el resultado y luego se incrementa/decrementa. int a = 8 , b = 1 ; b = a ++ ; //b = 8, a = 9","title":"Operadores unarios"},{"location":"ud1/15operators/#operadores-relacionales","text":"Estos operadores se utilizan para verificar relaciones como igualdad, mayor que, menor que. Devuelven el resultado booleano despu\u00e9s de la comparaci\u00f3n. S\u00edmbolo Operaci\u00f3n Descripci\u00f3n == Igual a Devuelve verdadero si el valor de la izquierda del s\u00edmbolo es igual al de la derecha. != Distinto a Devuelve verdadero si el valor de la izquierda es distinto al de la derecha. < Menor que Devuelve verdadero si el valor de la izquierda es menor que el de la derecha. <= Menor o igual que Devuelve verdadero si el valor de la izquierda es menor o igual que el de la derecha. > Mayor que Devuelve verdadero si el valor de la izquierda es mayor que el de la derecha. >= Mayor o igual que Devuelve verdadero si el valor de la izquierda es mayor o igual al de la derecha. int a = 20 , b = 10 ; System . out . println ( \"a == b :\" + ( a == b )); //Devuelve falso, porque a no es igual a b","title":"Operadores relacionales"},{"location":"ud1/15operators/#operadores-logicos","text":"Estos operadores se utilizan para realizar operaciones l\u00f3gicas AND y OR . Se usa ampliamente en sentencias if-then o bucles para verificar condiciones, establecer un punto de salida de un bucle o la toma de decisiones. Los operadores condicionales son: S\u00edmbolo Operaci\u00f3n Descripci\u00f3n && AND l\u00f3gico Devuelve verdadero cuando ambas condiciones son ciertas. || OR l\u00f3gico Devuelve verdadero si al menos una condici\u00f3n es cierta. int a = 20 , b = 10 , c = 10 ; System . out . println (( b == c && a == c )); //False System . out . println (( a == c && b == c )); //False System . out . println (( a == b || b == c )); //True","title":"Operadores l\u00f3gicos"},{"location":"ud1/15operators/#operadores-de-bits","text":"S\u00edmbolo Operaci\u00f3n Descripci\u00f3n & AND Si ambos bits de entrada son 1, establece como resultado 1. De lo contrario 0. | OR Si por lo menos uno de los bits de entrada es 1, establece como resultado 1. De lo contrario 0. ^ XOR Si uno de los bits de entrada es 1 y el otro 0, establece como resultado 1. Si los bits son iguales establece 0. ~ NOT Invierte todos los bits y devuelve el resultado en complemento a 2.","title":"Operadores de bits"},{"location":"ud1/15operators/#operador-ternario","text":"Ternario es una versi\u00f3n abreviada de la sentencia if-else. Tiene tres operandos y de ah\u00ed el nombre ternario. El formato general es: La declaraci\u00f3n anterior significa que si la condici\u00f3n se eval\u00faa como verdadera, entonces ejecuta las instrucciones despu\u00e9s del \u2018?\u2018 de lo contrario, ejecuta las instrucciones despu\u00e9s de \u2018:\u2018. int nota = 7 ; String notaFinal = ( nota >= 5 ) ? \"Aprobado\" : \"Suspendido\" ; System . out . println ( notaFinal ); //muestra Aprobado","title":"Operador ternario (?:)"},{"location":"ud1/15operators/#abreviaciones","text":"En muchos casos, el operador de asignaci\u00f3n se puede combinar con otros operadores para construir una versi\u00f3n m\u00e1s corta de la declaraci\u00f3n llamada Declaraci\u00f3n Compuesta (Compound Statement). += , para sumar el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda. int a = 5 ; a += 5 ; // a = a + 5; \u2013 = , para restar el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda. int a = 5 ; a -= 5 ; // a = a - 5; *= , para multiplicar el operando izquierdo con el operando derecho y luego asign\u00e1ndolo a la variable de la izquierda. int a = 5 ; a *= 5 ; // a = a * 5; / = , para dividir el operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda. int a = 5 ; a /= 5 ; // a = a / 5; % = , para asignar el m\u00f3dulo del operando izquierdo con el operando derecho y luego asignarlo a la variable de la izquierda. int a = 5 ; a %= 5 ; // a = a % 5;","title":"Abreviaciones"},{"location":"ud1/15operators/#precedencia-de-operadores","text":"El orden de precedencia, es decir, como Java decide la prioridad al evaluar los operadores en una expresi\u00f3n, se puede ver en Java Operator Precedence Table","title":"Precedencia de operadores"},{"location":"ud1/15operators/#conversiones-de-tipo","text":"","title":"Conversiones de tipo"},{"location":"ud1/15operators/#conversiones-por-defecto","text":"Las reglas de Java para saber el tipo de datos resultante de una expresi\u00f3n se siguen las siguientes reglas: Si alg\u00fan operando es El otro operando se transforma a double double float float long long byte or short int Si se aplican dos regla, se elige la que aparece primero en la tabla.","title":"Conversiones por defecto"},{"location":"ud1/15operators/#conversiones-forzosas-casting-entre-tipos-nativos","text":"Es una forma de convertir un n\u00famero de un tipo a otro tipo de dato. Para hacerlo ponemos en par\u00e9ntesis el tipo de dato al que queremos convertirlo. byte miByte = ( byte ) ( 14 / 2 ); //conviero la operaci\u00f3n divisi\u00f3n que devuelve un int a byte //Otra forma float a = 8.0f ; int b = 10 ; b = ( int ) a ; //convierto el tipo float a int Otros operadores Existen m\u00e1s operadores que no se han mencionado en el curso. Si se desea consultar todos los operadores de Java se pueden ver en su documentaci\u00f3n oficial. More information","title":"Conversiones forzosas (casting entre tipos nativos)"},{"location":"ud1/16comments/","text":"Comentarios en Java Los comentarios son ignorados por el ordenador y se usan en el programa para ayudar a describir alguna funcionalidad o explicaci\u00f3n del c\u00f3digo fuente. Existen dos tipos de comentarios. Comentarios de una l\u00ednea Usamos la doble barra // para realizar un comentario de una sola l\u00ednea. Lo podemos usar en una l\u00ednea en blanco o detr\u00e1s del c\u00f3digo. int gravity ; //variable para calcular la gravedad Comentarios multil\u00ednea Usamos la barra con asterisco doble para realizar comentarios que afecten a m\u00e1s de una l\u00ednea. De forma que cuando abramos un comentario usaremos /** , para cerrarlo **/ , y entre medio de las l\u00edneas *. /** * Clase que almacena en la base de datos * los datos de una persona. **/ public class Persona { ... }","title":"1.6.- Comentarios en Java"},{"location":"ud1/16comments/#comentarios-en-java","text":"Los comentarios son ignorados por el ordenador y se usan en el programa para ayudar a describir alguna funcionalidad o explicaci\u00f3n del c\u00f3digo fuente. Existen dos tipos de comentarios.","title":"Comentarios en Java"},{"location":"ud1/16comments/#comentarios-de-una-linea","text":"Usamos la doble barra // para realizar un comentario de una sola l\u00ednea. Lo podemos usar en una l\u00ednea en blanco o detr\u00e1s del c\u00f3digo. int gravity ; //variable para calcular la gravedad","title":"Comentarios de una l\u00ednea"},{"location":"ud1/16comments/#comentarios-multilinea","text":"Usamos la barra con asterisco doble para realizar comentarios que afecten a m\u00e1s de una l\u00ednea. De forma que cuando abramos un comentario usaremos /** , para cerrarlo **/ , y entre medio de las l\u00edneas *. /** * Clase que almacena en la base de datos * los datos de una persona. **/ public class Persona { ... }","title":"Comentarios multil\u00ednea"},{"location":"ud1/17constantesliterales/","text":"Constantes y literales Las constantes Un programa puede contener ciertos valores que no deben cambiar durante su ejecuci\u00f3n. Estos valores se llaman constantes. Definici\u00f3n: Una constante es una zona de memoria que se referencia con un identificador, conocido como nombre de la constante, donde se almacena un valor que no puede cambiar durante la ejecuci\u00f3n del programa. La nomenclatura para definiar las constantes es la siguiente: Todas las letras de cada palabra deben estar en may\u00fasculas Se separa cada palabra con un _ Se declaran similar a las variables, con la diferencia de que el tipo de dato va despu\u00e9s de la palabra reservada final final double PI = 3.141591 ; final int MIN_WIDTH = 4 ; final double TASAS = 0.045 ; Las constantes hacen que el programa sea m\u00e1s f\u00e1cil de leer y verificar que sea correcto. Si es necesario cambiar una constante (por ejemplo, si cambian las tasas), todo lo que tendremos que hacer es cambiar la declaraci\u00f3n de la constante. No ser\u00e1 necesario buscar en todo el programa cada aparici\u00f3n de ese n\u00famero espec\u00edfico. Los literales Un literal Java es un valor de tipo entero, real, l\u00f3gico, car\u00e1cter, cadena de caracteres o un valor nulo (null) que puede aparecer dentro de un programa. Por ejemplo: 150, 12.4, \u201cANA\u201d, null, \u2018t\u2019. Los literales suelen aparecer en la asignaci\u00f3n de valores a las variables o formando parte de expresiones aritm\u00e9ticas o l\u00f3gicas.","title":"1.7.- Constantes y literales"},{"location":"ud1/17constantesliterales/#constantes-y-literales","text":"","title":"Constantes y literales"},{"location":"ud1/17constantesliterales/#las-constantes","text":"Un programa puede contener ciertos valores que no deben cambiar durante su ejecuci\u00f3n. Estos valores se llaman constantes. Definici\u00f3n: Una constante es una zona de memoria que se referencia con un identificador, conocido como nombre de la constante, donde se almacena un valor que no puede cambiar durante la ejecuci\u00f3n del programa. La nomenclatura para definiar las constantes es la siguiente: Todas las letras de cada palabra deben estar en may\u00fasculas Se separa cada palabra con un _ Se declaran similar a las variables, con la diferencia de que el tipo de dato va despu\u00e9s de la palabra reservada final final double PI = 3.141591 ; final int MIN_WIDTH = 4 ; final double TASAS = 0.045 ; Las constantes hacen que el programa sea m\u00e1s f\u00e1cil de leer y verificar que sea correcto. Si es necesario cambiar una constante (por ejemplo, si cambian las tasas), todo lo que tendremos que hacer es cambiar la declaraci\u00f3n de la constante. No ser\u00e1 necesario buscar en todo el programa cada aparici\u00f3n de ese n\u00famero espec\u00edfico.","title":"Las constantes"},{"location":"ud1/17constantesliterales/#los-literales","text":"Un literal Java es un valor de tipo entero, real, l\u00f3gico, car\u00e1cter, cadena de caracteres o un valor nulo (null) que puede aparecer dentro de un programa. Por ejemplo: 150, 12.4, \u201cANA\u201d, null, \u2018t\u2019. Los literales suelen aparecer en la asignaci\u00f3n de valores a las variables o formando parte de expresiones aritm\u00e9ticas o l\u00f3gicas.","title":"Los literales"},{"location":"ud1/18inputoutputconsole/","text":"Programaci\u00f3n de la consola: entrada y salida de informaci\u00f3n (I/O input/output) Java viene con una biblioteca de clases que se puede usar para realizar tareas comunes. La biblioteca de clases de Java est\u00e1 organizada en un conjunto de paquetes, donde cada paquete contiene una colecci\u00f3n de clases relacionadas. En esta secci\u00f3n presentamos las clases System y Scanner que se utilizan para imprimir la salida y leer la entrada de un programa. El tipo m\u00e1s simple de interfaz de usuario es la interfaz de l\u00ednea de comandos, en la que la entrada se toma de la l\u00ednea de comandos a trav\u00e9s del teclado y la salida se muestra en la consola. Algunas aplicaciones Java utilizan este tipo de interfaz otros usan interfaz gr\u00e1fica como veremos m\u00e1s adelante. Salida de la informaci\u00f3n En Java, cualquier origen o destino de I/O se considera un flujo de bytes o caracteres. Para realizar la salida, insertamos bytes o caracteres en la secuencia. Para realizar la entrada, extraemos bytes o caracteres del flujo (stream). Incluso los caracteres introducidos en un teclado, si se consideran como una secuencia de pulsaciones de teclas, se pueden representar como un stream. En Java, la I/O se maneja a trav\u00e9s de m\u00e9todos que pertenecen a clases contenidas en el paquete java.io. Ya hemos visto c\u00f3mo se usa el m\u00e9todo de salida println() para enviar una cadena a la consola. Por ejemplo: System . out . println ( \"Hola mundo\" ); imprime el texto Hola mundo por la consola. Los objetos System.out y System.err se pueden usar para escribir la salida en la consola. Como sugiere su nombre, el flujo de errores se usa principalmente para mensajes de error, mientras que el flujo de salida se usa para otras salidas impresas. System . err . println ( \"Fallo al abrir el fichero\" ); De manera similar, como sugiere su nombre, el objeto System.in se puede usar para manejar la entrada, que se trata en el siguiente punto. La \u00fanica diferencia entre los m\u00e9todos print() y println() es que println() tambi\u00e9n imprimir\u00e1 un retorno de carro y un avance de l\u00ednea despu\u00e9s de imprimir sus datos, lo que permitir\u00e1 que la salida posterior se imprima en una nueva l\u00ednea. Por ejemplo: System . out . print ( \"Hola\" ); System . out . print ( \"mundo\" ): System . out . println ( \"Texto con salto de l\u00ednea\" ); System . out . println ( \"adi\u00f3s\" ); HolamundoTexto con salto de l\u00ednea adi\u00f3s Entrada de la informaci\u00f3n java.util.Scanner Se ha agregado la clase Scanner al paquete java.util que permite la entrada de teclado sin forzar el programador para manejar las excepciones. La clase Scanner est\u00e1 dise\u00f1ada para ser una forma muy flexible de reconocer fragmentos de datos que se ajustan a patrones espec\u00edficos de cualquier flujo de entrada. Para usar la clase Scanner para la entrada de teclado, debemos crear una instancia de Scanner y asociarla con System.in. La clase tiene un constructor para este prop\u00f3sito, por lo que la declaraci\u00f3n Scanner sc = new Scanner ( System . in ); declara y crea una instancia de un objeto que se puede utilizar para la entrada del teclado. Despu\u00e9s de crear un objeto Scanner, podemos hacer una llamada a nextInt(), nextDouble(), o next() para leer, respectivamente, un entero, un n\u00famero real, o String del teclado. public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); System . out . print ( \"Introduce un n\u00famero: \" ); int num = sc . nextInt (); //Read the integer System . out . println ( \"El n\u00famero introducido es: \" + num ); } Cuando se ejecuta el m\u00e9todo nextInt() , no se ejecutan m\u00e1s declaraciones hasta que el m\u00e9todo devuelve un valor int. Normalmente, esto no sucede hasta que el usuario ha escrito los d\u00edgitos de un n\u00famero entero y presiona la tecla Intro o Intro. Para leer un String utilizamos el m\u00e9todo next() . public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); System . out . print ( \"Introduce una palabra: \" ); String str = sc . next (); System . out . println ( str ); } Un objeto Scanner tiene un conjunto de cadenas de caracteres que separan o delimitan los fragmentos de datos que est\u00e1 buscando. De forma predeterminada, este conjunto de delimitadores consta de cualquier secuencia no vac\u00eda de caracteres en blanco, es decir, los caracteres de espacio, tabulaci\u00f3n, retorno y nueva l\u00ednea. Esto permitir\u00e1 al usuario ingresar varios n\u00fameros enteros separados por espacios antes de presionar la tecla Enter. En c\u00f3digo ser\u00eda: System . out . print ( \"Introduce dos n\u00fameros: \" ); int num = sc . nextInt (); int num2 = sc . nextInt (); Los espacios en blanco como delimitadores tambi\u00e9n significan que el m\u00e9todo next() no puede devolver una cadena vac\u00eda ni puede devolver una cadena que contenga espacios. Por ejemplo, considere el c\u00f3digo: System . out . print ( \"Introduce un texto separado por espacio en blanco: \" ); String str = sc . next (); Si se escribe \"Hola mundo\" y se presiona la tecla enter, la cadena str almacenar\u00e1 s\u00f3lo \"Hola\". Para que un objeto Scanner lea cadenas que contienen espacios, debemos usar el m\u00e9todo nextLine() : String str = sc . nextLine ();","title":"1.8.- Entrada y salida de informaci\u00f3n por consola"},{"location":"ud1/18inputoutputconsole/#programacion-de-la-consola-entrada-y-salida-de-informacion-io-inputoutput","text":"Java viene con una biblioteca de clases que se puede usar para realizar tareas comunes. La biblioteca de clases de Java est\u00e1 organizada en un conjunto de paquetes, donde cada paquete contiene una colecci\u00f3n de clases relacionadas. En esta secci\u00f3n presentamos las clases System y Scanner que se utilizan para imprimir la salida y leer la entrada de un programa. El tipo m\u00e1s simple de interfaz de usuario es la interfaz de l\u00ednea de comandos, en la que la entrada se toma de la l\u00ednea de comandos a trav\u00e9s del teclado y la salida se muestra en la consola. Algunas aplicaciones Java utilizan este tipo de interfaz otros usan interfaz gr\u00e1fica como veremos m\u00e1s adelante.","title":"Programaci\u00f3n de la consola: entrada y salida de informaci\u00f3n (I/O input/output)"},{"location":"ud1/18inputoutputconsole/#salida-de-la-informacion","text":"En Java, cualquier origen o destino de I/O se considera un flujo de bytes o caracteres. Para realizar la salida, insertamos bytes o caracteres en la secuencia. Para realizar la entrada, extraemos bytes o caracteres del flujo (stream). Incluso los caracteres introducidos en un teclado, si se consideran como una secuencia de pulsaciones de teclas, se pueden representar como un stream. En Java, la I/O se maneja a trav\u00e9s de m\u00e9todos que pertenecen a clases contenidas en el paquete java.io. Ya hemos visto c\u00f3mo se usa el m\u00e9todo de salida println() para enviar una cadena a la consola. Por ejemplo: System . out . println ( \"Hola mundo\" ); imprime el texto Hola mundo por la consola. Los objetos System.out y System.err se pueden usar para escribir la salida en la consola. Como sugiere su nombre, el flujo de errores se usa principalmente para mensajes de error, mientras que el flujo de salida se usa para otras salidas impresas. System . err . println ( \"Fallo al abrir el fichero\" ); De manera similar, como sugiere su nombre, el objeto System.in se puede usar para manejar la entrada, que se trata en el siguiente punto. La \u00fanica diferencia entre los m\u00e9todos print() y println() es que println() tambi\u00e9n imprimir\u00e1 un retorno de carro y un avance de l\u00ednea despu\u00e9s de imprimir sus datos, lo que permitir\u00e1 que la salida posterior se imprima en una nueva l\u00ednea. Por ejemplo: System . out . print ( \"Hola\" ); System . out . print ( \"mundo\" ): System . out . println ( \"Texto con salto de l\u00ednea\" ); System . out . println ( \"adi\u00f3s\" ); HolamundoTexto con salto de l\u00ednea adi\u00f3s","title":"Salida de la informaci\u00f3n"},{"location":"ud1/18inputoutputconsole/#entrada-de-la-informacion-javautilscanner","text":"Se ha agregado la clase Scanner al paquete java.util que permite la entrada de teclado sin forzar el programador para manejar las excepciones. La clase Scanner est\u00e1 dise\u00f1ada para ser una forma muy flexible de reconocer fragmentos de datos que se ajustan a patrones espec\u00edficos de cualquier flujo de entrada. Para usar la clase Scanner para la entrada de teclado, debemos crear una instancia de Scanner y asociarla con System.in. La clase tiene un constructor para este prop\u00f3sito, por lo que la declaraci\u00f3n Scanner sc = new Scanner ( System . in ); declara y crea una instancia de un objeto que se puede utilizar para la entrada del teclado. Despu\u00e9s de crear un objeto Scanner, podemos hacer una llamada a nextInt(), nextDouble(), o next() para leer, respectivamente, un entero, un n\u00famero real, o String del teclado. public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); System . out . print ( \"Introduce un n\u00famero: \" ); int num = sc . nextInt (); //Read the integer System . out . println ( \"El n\u00famero introducido es: \" + num ); } Cuando se ejecuta el m\u00e9todo nextInt() , no se ejecutan m\u00e1s declaraciones hasta que el m\u00e9todo devuelve un valor int. Normalmente, esto no sucede hasta que el usuario ha escrito los d\u00edgitos de un n\u00famero entero y presiona la tecla Intro o Intro. Para leer un String utilizamos el m\u00e9todo next() . public static void main ( String [] args ) { Scanner sc = new Scanner ( System . in ); System . out . print ( \"Introduce una palabra: \" ); String str = sc . next (); System . out . println ( str ); } Un objeto Scanner tiene un conjunto de cadenas de caracteres que separan o delimitan los fragmentos de datos que est\u00e1 buscando. De forma predeterminada, este conjunto de delimitadores consta de cualquier secuencia no vac\u00eda de caracteres en blanco, es decir, los caracteres de espacio, tabulaci\u00f3n, retorno y nueva l\u00ednea. Esto permitir\u00e1 al usuario ingresar varios n\u00fameros enteros separados por espacios antes de presionar la tecla Enter. En c\u00f3digo ser\u00eda: System . out . print ( \"Introduce dos n\u00fameros: \" ); int num = sc . nextInt (); int num2 = sc . nextInt (); Los espacios en blanco como delimitadores tambi\u00e9n significan que el m\u00e9todo next() no puede devolver una cadena vac\u00eda ni puede devolver una cadena que contenga espacios. Por ejemplo, considere el c\u00f3digo: System . out . print ( \"Introduce un texto separado por espacio en blanco: \" ); String str = sc . next (); Si se escribe \"Hola mundo\" y se presiona la tecla enter, la cadena str almacenar\u00e1 s\u00f3lo \"Hola\". Para que un objeto Scanner lea cadenas que contienen espacios, debemos usar el m\u00e9todo nextLine() : String str = sc . nextLine ();","title":"Entrada de la informaci\u00f3n java.util.Scanner"},{"location":"ud1/19poo/","text":"Introducci\u00f3n a la programaci\u00f3n orientada a objetos La programaci\u00f3n modular es un paradigma que consiste en dividir un programa en m\u00f3dulos con el fin de hacerlo m\u00e1s legible y manejable. Enfatiza este concepto mediante la construcci\u00f3n de aplicaciones a partir de su divisi\u00f3n en componentes independientes que llevan a cabo tareas concretas. Al aplicar programaci\u00f3n modular, un problema complejo debe ser dividido en otros subproblemas m\u00e1s simples a\u00fan. Un m\u00f3dulo es cada una de las partes de un programa que resuelve uno de los subproblemas. La programaci\u00f3n orientada a objetos (POO) se basa en la programaci\u00f3n modular, aunque supone una ruptura respecto a \u00e9sta al introducir el concepto de objeto, lo que supone un gran avance en t\u00e9rminos de modularizaci\u00f3n y reutilizaci\u00f3n de c\u00f3digo. Fundamentos de la POO Abstracci\u00f3n : es el pilar de la POO, un principio por el cual se a\u00edsla toda aquella informaci\u00f3n que no resulta relevante a un determinado nivel de conocimiento. Consiste en captar las caracter\u00edsticas esenciales de un objeto, asi como su comportamiento. Encapsulaci\u00f3n : se centra en ocultad la complejidad de la clase. Significa proteger a los miembros de una clase de un acceso ilegal o no autorizado. Herencia : es el pilar m\u00e1s fuerte que asegura la reutilizaci\u00f3n de c\u00f3digo. Permite la definici\u00f3n de nuevas clases a partir de otras ya existentes. Polimorfismo : posibilita que una misma operaci\u00f3n pueda realizar tareas diferentes, dependiendo del tipo de objeto sobre el cual se ha invocado. Concepto de objeto Entonces, \u00bfqu\u00e9 es un objeto? Al igual que en el mundo real, un objeto es cualquier cosa. Un objeto puede ser una cosa f\u00edsica, como un coche, o una cosa mental, como una idea. Puede ser algo natural, como un animal, o algo artificial hecho por el hombre, como un cajero autom\u00e1tico. Un programa que administra un cajero autom\u00e1tico involucrar\u00eda cuentas bancarias y objetos de cliente. Un programa de ajedrez involucrar\u00eda un objeto tablero y objetos piezas de ajedrez. Atributos y acciones Atributos Al igual que con los objetos reales, los objetos de nuestros programas tienen ciertos atributos o propiedades caracter\u00edsticos. Por ejemplo, un objeto de cajero autom\u00e1tico tendr\u00eda una cantidad actual de efectivo que podr\u00eda dispensar. Un objeto pieza ajedrez puede tener un par de atributos de fila y columna que especifiquen su posici\u00f3n en el tablero de ajedrez. Observe que los atributos de un objeto son en s\u00ed mismos objetos. El atributo de efectivo del cajero autom\u00e1tico y los atributos de fila y columna de la pieza de ajedrez son n\u00fameros. A veces nos referimos a la colecci\u00f3n de atributos y valores de un objeto como su estado . Acciones o M\u00e9todos Adem\u00e1s de sus atributos o propiedades, los objetos tambi\u00e9n tienen acciones o comportamientos caracter\u00edsticos. Como ya dijimos, los objetos en los programas son din\u00e1micos. Hacen cosas o les hacen cosas. Por ejemplo, en un programa de ajedrez, ChessPieces tiene la capacidad de moveTo () a una nueva posici\u00f3n en el tablero de ajedrez. De manera similar, cuando un cliente presiona el bot\u00f3n \"Saldo actual\" en un cajero autom\u00e1tico, esto le est\u00e1 diciendo al cajero autom\u00e1tico que informe () el saldo bancario actual del cliente. (Observe c\u00f3mo usamos par\u00e9ntesis para distinguir acciones de objetos y atributos). Las acciones asociadas con un objeto se pueden utilizar para enviar mensajes a los objetos y recuperar informaci\u00f3n de los objetos. Un mensaje es el paso de informaci\u00f3n o datos de un objeto a otro. En este ejemplo, le decimos a pe\u00f3n1: Pieza de ajedrez que se mueva a (3,4). chessPiece . move ( 3 , 4 ); Los n\u00fameros 3 y 4 en este caso son argumentos que le dicen al pe\u00f3n a qu\u00e9 casilla moverse. (Un tablero de ajedrez tiene 8 filas y 8 columnas y cada cuadrado se identifica por sus coordenadas de fila y columna). En general, un argumento es un valor de datos que especializa el contenido de un mensaje de alguna manera. Responder a un mensaje o realizar una acci\u00f3n a veces provoca un cambio en el estado de un objeto. Por ejemplo, despu\u00e9s de realizar moveTo (3,4), el pe\u00f3n estar\u00e1 en una casilla diferente. Su posici\u00f3n habr\u00e1 cambiado. Por otro lado, algunos mensajes (o acciones) no modifican el estado del objeto. Informar el saldo de la cuenta bancaria del cliente no cambia el saldo. Caracter\u00edsticas b\u00e1sicas Estado : est\u00e1 representado por atributos de un objeto. Comportamiento : se representa mediante m\u00e9todos de un objeto. Tambi\u00e9n refleja la respuesta de un objeto con otros objetos. Identidad : le da un nombre \u00fanico a un objeto y permite que un objeto interact\u00fae con otros objetos. Creaci\u00f3n y destrucci\u00f3n de objetos Creaci\u00f3n Para crear un objeto utilizamos la palabra reservada new , que asigna memoria del Heap. Se usa el nombre de la clase (constructor) seguido por par\u00e9ntesis. Se le llama instanciar un objeto. ATM atm = new ATM (); Destrucci\u00f3n En Java no es posible destruir objetos de forma expl\u00edcita, los objetos se destruyen de forma autom\u00e1tica por el recolector de basura. Java busca objetos inalcanzables y los destruye, normalmente cuando falta memoria. Los convierte de nuevo en memoria binaria no utilizada. Uso de objetos: acceso a atributos y m\u00e9todos Para acceder a los atributos y m\u00e9todos de un objeto utilizamos la notaci\u00f3n \".\" detr\u00e1s del nombre del objeto. El objeto debe ser creado previamente sino dar\u00e1 error de compilaci\u00f3n. double cantidad = atm . efectivo ; atm . mostrarEfectivo (); M\u00e1s adelante veremos la visibilidad de los m\u00e9todos y atributos de los objetos.","title":"1.9.- Introducci\u00f3n a la programaci\u00f3n orientada a objetos"},{"location":"ud1/19poo/#introduccion-a-la-programacion-orientada-a-objetos","text":"La programaci\u00f3n modular es un paradigma que consiste en dividir un programa en m\u00f3dulos con el fin de hacerlo m\u00e1s legible y manejable. Enfatiza este concepto mediante la construcci\u00f3n de aplicaciones a partir de su divisi\u00f3n en componentes independientes que llevan a cabo tareas concretas. Al aplicar programaci\u00f3n modular, un problema complejo debe ser dividido en otros subproblemas m\u00e1s simples a\u00fan. Un m\u00f3dulo es cada una de las partes de un programa que resuelve uno de los subproblemas. La programaci\u00f3n orientada a objetos (POO) se basa en la programaci\u00f3n modular, aunque supone una ruptura respecto a \u00e9sta al introducir el concepto de objeto, lo que supone un gran avance en t\u00e9rminos de modularizaci\u00f3n y reutilizaci\u00f3n de c\u00f3digo.","title":"Introducci\u00f3n a la programaci\u00f3n orientada a objetos"},{"location":"ud1/19poo/#fundamentos-de-la-poo","text":"Abstracci\u00f3n : es el pilar de la POO, un principio por el cual se a\u00edsla toda aquella informaci\u00f3n que no resulta relevante a un determinado nivel de conocimiento. Consiste en captar las caracter\u00edsticas esenciales de un objeto, asi como su comportamiento. Encapsulaci\u00f3n : se centra en ocultad la complejidad de la clase. Significa proteger a los miembros de una clase de un acceso ilegal o no autorizado. Herencia : es el pilar m\u00e1s fuerte que asegura la reutilizaci\u00f3n de c\u00f3digo. Permite la definici\u00f3n de nuevas clases a partir de otras ya existentes. Polimorfismo : posibilita que una misma operaci\u00f3n pueda realizar tareas diferentes, dependiendo del tipo de objeto sobre el cual se ha invocado.","title":"Fundamentos de la POO"},{"location":"ud1/19poo/#concepto-de-objeto","text":"Entonces, \u00bfqu\u00e9 es un objeto? Al igual que en el mundo real, un objeto es cualquier cosa. Un objeto puede ser una cosa f\u00edsica, como un coche, o una cosa mental, como una idea. Puede ser algo natural, como un animal, o algo artificial hecho por el hombre, como un cajero autom\u00e1tico. Un programa que administra un cajero autom\u00e1tico involucrar\u00eda cuentas bancarias y objetos de cliente. Un programa de ajedrez involucrar\u00eda un objeto tablero y objetos piezas de ajedrez.","title":"Concepto de objeto"},{"location":"ud1/19poo/#atributos-y-acciones","text":"","title":"Atributos y acciones"},{"location":"ud1/19poo/#atributos","text":"Al igual que con los objetos reales, los objetos de nuestros programas tienen ciertos atributos o propiedades caracter\u00edsticos. Por ejemplo, un objeto de cajero autom\u00e1tico tendr\u00eda una cantidad actual de efectivo que podr\u00eda dispensar. Un objeto pieza ajedrez puede tener un par de atributos de fila y columna que especifiquen su posici\u00f3n en el tablero de ajedrez. Observe que los atributos de un objeto son en s\u00ed mismos objetos. El atributo de efectivo del cajero autom\u00e1tico y los atributos de fila y columna de la pieza de ajedrez son n\u00fameros. A veces nos referimos a la colecci\u00f3n de atributos y valores de un objeto como su estado .","title":"Atributos"},{"location":"ud1/19poo/#acciones-o-metodos","text":"Adem\u00e1s de sus atributos o propiedades, los objetos tambi\u00e9n tienen acciones o comportamientos caracter\u00edsticos. Como ya dijimos, los objetos en los programas son din\u00e1micos. Hacen cosas o les hacen cosas. Por ejemplo, en un programa de ajedrez, ChessPieces tiene la capacidad de moveTo () a una nueva posici\u00f3n en el tablero de ajedrez. De manera similar, cuando un cliente presiona el bot\u00f3n \"Saldo actual\" en un cajero autom\u00e1tico, esto le est\u00e1 diciendo al cajero autom\u00e1tico que informe () el saldo bancario actual del cliente. (Observe c\u00f3mo usamos par\u00e9ntesis para distinguir acciones de objetos y atributos). Las acciones asociadas con un objeto se pueden utilizar para enviar mensajes a los objetos y recuperar informaci\u00f3n de los objetos. Un mensaje es el paso de informaci\u00f3n o datos de un objeto a otro. En este ejemplo, le decimos a pe\u00f3n1: Pieza de ajedrez que se mueva a (3,4). chessPiece . move ( 3 , 4 ); Los n\u00fameros 3 y 4 en este caso son argumentos que le dicen al pe\u00f3n a qu\u00e9 casilla moverse. (Un tablero de ajedrez tiene 8 filas y 8 columnas y cada cuadrado se identifica por sus coordenadas de fila y columna). En general, un argumento es un valor de datos que especializa el contenido de un mensaje de alguna manera. Responder a un mensaje o realizar una acci\u00f3n a veces provoca un cambio en el estado de un objeto. Por ejemplo, despu\u00e9s de realizar moveTo (3,4), el pe\u00f3n estar\u00e1 en una casilla diferente. Su posici\u00f3n habr\u00e1 cambiado. Por otro lado, algunos mensajes (o acciones) no modifican el estado del objeto. Informar el saldo de la cuenta bancaria del cliente no cambia el saldo.","title":"Acciones o M\u00e9todos"},{"location":"ud1/19poo/#caracteristicas-basicas","text":"Estado : est\u00e1 representado por atributos de un objeto. Comportamiento : se representa mediante m\u00e9todos de un objeto. Tambi\u00e9n refleja la respuesta de un objeto con otros objetos. Identidad : le da un nombre \u00fanico a un objeto y permite que un objeto interact\u00fae con otros objetos.","title":"Caracter\u00edsticas b\u00e1sicas"},{"location":"ud1/19poo/#creacion-y-destruccion-de-objetos","text":"","title":"Creaci\u00f3n y destrucci\u00f3n de objetos"},{"location":"ud1/19poo/#creacion","text":"Para crear un objeto utilizamos la palabra reservada new , que asigna memoria del Heap. Se usa el nombre de la clase (constructor) seguido por par\u00e9ntesis. Se le llama instanciar un objeto. ATM atm = new ATM ();","title":"Creaci\u00f3n"},{"location":"ud1/19poo/#destruccion","text":"En Java no es posible destruir objetos de forma expl\u00edcita, los objetos se destruyen de forma autom\u00e1tica por el recolector de basura. Java busca objetos inalcanzables y los destruye, normalmente cuando falta memoria. Los convierte de nuevo en memoria binaria no utilizada.","title":"Destrucci\u00f3n"},{"location":"ud1/19poo/#uso-de-objetos-acceso-a-atributos-y-metodos","text":"Para acceder a los atributos y m\u00e9todos de un objeto utilizamos la notaci\u00f3n \".\" detr\u00e1s del nombre del objeto. El objeto debe ser creado previamente sino dar\u00e1 error de compilaci\u00f3n. double cantidad = atm . efectivo ; atm . mostrarEfectivo (); M\u00e1s adelante veremos la visibilidad de los m\u00e9todos y atributos de los objetos.","title":"Uso de objetos: acceso a atributos y m\u00e9todos"},{"location":"ud1/1elementos/","text":"Elementos de un programa inform\u00e1tico Un programa es una secuencia de instrucciones que un ordenador ejecuta para realizar alguna tarea. Parece una idea bastante simple, pero para que el ordenador pueda hacer uso de las instrucciones, deben estar escritas de forma que las pueda usar. Esto significa que los programas deben estar escritos en lenguajes de programaci\u00f3n. Los lenguajes de programaci\u00f3n se diferencian de los lenguajes humanos ordinarios en que son completamente inequ\u00edvocos y muy estrictos sobre lo que est\u00e1 y no est\u00e1 permitido en un programa. Las reglas que determinan lo que est\u00e1 permitido se denominan sintaxis del lenguaje. Las reglas de sintaxis especifican el vocabulario b\u00e1sico del lenguaje y c\u00f3mo se pueden construir los programas. Lenguajes de programaci\u00f3n Se trata de un conjunto de instrucciones que permite la comunicaci\u00f3n de los humanos con los ordenadores. C --> bases de datos, videojuegos, kernel linux, IOT, dispositivos inteligentes, etc. Python --> inteligencia artificial, big data, etc. Java --> puntos de ventas, aplicaciones de escritorio, cajeros autom\u00e1ticos, dispositivos m\u00f3viles, ... \u00bfCon qu\u00e9 lenguaje de programaci\u00f3n debo empezar? En realidad, no existe el mejor lenguaje de programaci\u00f3n para empezar, y el lenguaje que elijas pr\u00e1cticamente no tendr\u00e1 un efecto duradero en tu carrera. Los lenguajes de programaci\u00f3n pueden verse muy diferentes en la superficie, pero la mayor\u00eda de los conceptos fundamentales se transferir\u00e1n de un lenguaje a otro. Aprender un nuevo idioma tambi\u00e9n ser\u00e1 m\u00e1s f\u00e1cil con el tiempo; un principiante puede tardar meses antes de que se sienta c\u00f3modo con su primer lenguaje; un programador experimentado puede familiarizarse con un nuevo idioma en cuesti\u00f3n de d\u00edas. 7 Tips para aprender a programar con \u00e9xito 1 . Learn by doing. Always play with the code while learning 2 . Grasp the fundamentals for long-term benefits 3 . Code by hand. It sharpens proficiency and you\u2019ll need it to get a job 4 . Ask for help. You\u2019ll need it 5 . Seek out more online resources. There\u2019s a wealth of content 6 . Don\u2019t just read the sample code. Tinker with it! 7 . Take breaks when debugging Fuente: Coding dojo Tip S\u00e9 persistente, no te rindas!","title":"1.1.- Programa y lenguajes de programaci\u00f3n"},{"location":"ud1/1elementos/#elementos-de-un-programa-informatico","text":"Un programa es una secuencia de instrucciones que un ordenador ejecuta para realizar alguna tarea. Parece una idea bastante simple, pero para que el ordenador pueda hacer uso de las instrucciones, deben estar escritas de forma que las pueda usar. Esto significa que los programas deben estar escritos en lenguajes de programaci\u00f3n. Los lenguajes de programaci\u00f3n se diferencian de los lenguajes humanos ordinarios en que son completamente inequ\u00edvocos y muy estrictos sobre lo que est\u00e1 y no est\u00e1 permitido en un programa. Las reglas que determinan lo que est\u00e1 permitido se denominan sintaxis del lenguaje. Las reglas de sintaxis especifican el vocabulario b\u00e1sico del lenguaje y c\u00f3mo se pueden construir los programas.","title":"Elementos de un programa inform\u00e1tico"},{"location":"ud1/1elementos/#lenguajes-de-programacion","text":"Se trata de un conjunto de instrucciones que permite la comunicaci\u00f3n de los humanos con los ordenadores. C --> bases de datos, videojuegos, kernel linux, IOT, dispositivos inteligentes, etc. Python --> inteligencia artificial, big data, etc. Java --> puntos de ventas, aplicaciones de escritorio, cajeros autom\u00e1ticos, dispositivos m\u00f3viles, ...","title":"Lenguajes de programaci\u00f3n"},{"location":"ud1/1elementos/#con-que-lenguaje-de-programacion-debo-empezar","text":"En realidad, no existe el mejor lenguaje de programaci\u00f3n para empezar, y el lenguaje que elijas pr\u00e1cticamente no tendr\u00e1 un efecto duradero en tu carrera. Los lenguajes de programaci\u00f3n pueden verse muy diferentes en la superficie, pero la mayor\u00eda de los conceptos fundamentales se transferir\u00e1n de un lenguaje a otro. Aprender un nuevo idioma tambi\u00e9n ser\u00e1 m\u00e1s f\u00e1cil con el tiempo; un principiante puede tardar meses antes de que se sienta c\u00f3modo con su primer lenguaje; un programador experimentado puede familiarizarse con un nuevo idioma en cuesti\u00f3n de d\u00edas.","title":"\u00bfCon qu\u00e9 lenguaje de programaci\u00f3n debo empezar?"},{"location":"ud1/1elementos/#7-tips-para-aprender-a-programar-con-exito","text":"1 . Learn by doing. Always play with the code while learning 2 . Grasp the fundamentals for long-term benefits 3 . Code by hand. It sharpens proficiency and you\u2019ll need it to get a job 4 . Ask for help. You\u2019ll need it 5 . Seek out more online resources. There\u2019s a wealth of content 6 . Don\u2019t just read the sample code. Tinker with it! 7 . Take breaks when debugging Fuente: Coding dojo Tip S\u00e9 persistente, no te rindas!","title":"7 Tips para aprender a programar con \u00e9xito"},{"location":"ud2/11booleanexpressions/","text":"Expresiones booleanas Las sentencias if del cap\u00edtulo anterior inclu\u00edan preguntas simples de verdadero / falso (expresiones booleanas) como num<10 o jugadores==1. A menudo, las expresiones booleanas simples no son suficientes. Este cap\u00edtulo trata sobre expresiones booleanas m\u00e1s complicadas. && El operador AND && es un operador l\u00f3gico. Un operador l\u00f3gico examina dos valores verdadero / falso y genera un \u00fanico valor verdadero / falso. Por ejemplo cuando necesitas verificar m\u00e1s de una expresi\u00f3n. if ( harina == 100 && azucar >= 65 ) { } Cada parte es una expresi\u00f3n relacional. Una expresi\u00f3n relacional es un tipo de expresi\u00f3n booleana que usa un operador relacional para calcular un valor verdadero o falso. Las expresiones se eval\u00faan de izquierda a derecha, as\u00ed, tan pronto se detecta el primer false, la expresi\u00f3n entera se convierte en false y no se eval\u00faa el resto de expresiones. || El operador OR || se usa en una expresi\u00f3n booleana para verificar que haya al menos una verdadera. Si solo un lado es verdadero, toda la expresi\u00f3n es verdadera. Si ambos lados son falsos, toda la expresi\u00f3n es falsa. if ( ahorrosMensuales > 1000 || pr\u00e9stamo == 3000 ) { } ! El operador NOT ! cambia de verdadero a falso y de falso a verdadero. Esto puede parecer una tonter\u00eda, pero a menudo es \u00fatil. A veces es m\u00e1s natural expresar una condici\u00f3n de una manera particular, pero la l\u00f3gica del programa requiere lo contrario de lo que ha escrito. if ( ! ( precio < 35 )) { }","title":"Expresiones booleanas"},{"location":"ud2/11booleanexpressions/#expresiones-booleanas","text":"Las sentencias if del cap\u00edtulo anterior inclu\u00edan preguntas simples de verdadero / falso (expresiones booleanas) como num<10 o jugadores==1. A menudo, las expresiones booleanas simples no son suficientes. Este cap\u00edtulo trata sobre expresiones booleanas m\u00e1s complicadas.","title":"Expresiones booleanas"},{"location":"ud2/11booleanexpressions/#_1","text":"El operador AND && es un operador l\u00f3gico. Un operador l\u00f3gico examina dos valores verdadero / falso y genera un \u00fanico valor verdadero / falso. Por ejemplo cuando necesitas verificar m\u00e1s de una expresi\u00f3n. if ( harina == 100 && azucar >= 65 ) { } Cada parte es una expresi\u00f3n relacional. Una expresi\u00f3n relacional es un tipo de expresi\u00f3n booleana que usa un operador relacional para calcular un valor verdadero o falso. Las expresiones se eval\u00faan de izquierda a derecha, as\u00ed, tan pronto se detecta el primer false, la expresi\u00f3n entera se convierte en false y no se eval\u00faa el resto de expresiones.","title":"&amp;&amp;"},{"location":"ud2/11booleanexpressions/#_2","text":"El operador OR || se usa en una expresi\u00f3n booleana para verificar que haya al menos una verdadera. Si solo un lado es verdadero, toda la expresi\u00f3n es verdadera. Si ambos lados son falsos, toda la expresi\u00f3n es falsa. if ( ahorrosMensuales > 1000 || pr\u00e9stamo == 3000 ) { }","title":"||"},{"location":"ud2/11booleanexpressions/#_3","text":"El operador NOT ! cambia de verdadero a falso y de falso a verdadero. Esto puede parecer una tonter\u00eda, pero a menudo es \u00fatil. A veces es m\u00e1s natural expresar una condici\u00f3n de una manera particular, pero la l\u00f3gica del programa requiere lo contrario de lo que ha escrito. if ( ! ( precio < 35 )) { }","title":"!"},{"location":"ud2/1seleccion/","text":"Sentencia IF Este apartado analiza c\u00f3mo los programas del ordenador toman decisiones utilizando la sentencia if . Esta sentencia es uno de los bloques de construcci\u00f3n fundamentales de la programaci\u00f3n. Veamos c\u00f3mo funciona. Los limpiaparabrisas se controlan con un interruptor de encendido y apagado. El diagrama de flujo de la derecha muestra c\u00f3mo se toma esta decisi\u00f3n. Comience en la parte superior del gr\u00e1fico y luego siga la l\u00ednea hasta la pregunta: \u00bfesta lloviendo? La respuesta es verdadera o falsa. Si la respuesta es verdadera, siga la l\u00ednea etiquetada como Verdadero, siga las instrucciones en el cuadro \"Activo limpiaparabrisas , siga la l\u00ednea para \"Continuar\". Si la respuesta es falsa, siga la l\u00ednea etiquetada como Falso, siga las instrucciones en el cuadro \"limpiaparabrisas desactivados\", siga la l\u00ednea para \"Continuar\". Ejemplo del programa en c\u00f3digo public static void main(String[] args) { Scanner scan = new Scanner( System.in ); String respuesta; System.out.print(\"\u00bfEst\u00e1 lloviendo? (Y or N): \"); respuesta = scan.nextLine(); if (respuesta.equals(\"Y\")) { System.out.println(\"Activa limpiaparabrisas\"); } else { System.out.println(\"Desactiva limpiaparabrisas\"); } } Sentencia simple condicional if La declaraci\u00f3n if es la m\u00e1s b\u00e1sica de todas las declaraciones de flujo de control. Le dice a su programa que ejecute una determinada secci\u00f3n de c\u00f3digo solo si una prueba en particular se eval\u00faa como verdadera. La sentencia simple condicional if tiene la siguiente estructura: if ( * condici\u00f3n * ) { //sentencias } Condicion es una expresi\u00f3n booleana. Recuerde que una expresi\u00f3n es una combinaci\u00f3n de literales, operadores, nombres de variables y par\u00e9ntesis que se utilizan para calcular un valor, o incluso una llamada a un m\u00e9todo. Una expresi\u00f3n booleana es una expresi\u00f3n que se eval\u00faa como verdadera o falsa. Dada esta descripci\u00f3n de la sintaxis de la sentencia if, los siguientes son ejemplos de sentencias if v\u00e1lidas: if ( true ) { System . out . println ( \"expresi\u00f3n if\" ); } int num = 6 ; if ( num > 0 ) { System . out . println ( \"El n\u00famero es positivo.\" ); } Sentencia condicional compuesta if-else Una segunda versi\u00f3n de la sentencia if incorpora una cl\u00e1usula else en la estructura. Esto nos permite ejecutar cualquiera de dos declaraciones separadas (simple o compuesta) como resultado de un booleano expresi\u00f3n. if ( * condici\u00f3n * ) { //sentencias 1 } else { //sentencias 2 } Ejemplo: int numJugadores = 2 ; if ( numJugadores == 1 ) { System . out . println ( \"Single player\" ); } else { System . out . println ( \"Multiplayer\" ); } Sentencia condicional if-else m\u00faltiple Lo que se ejecuta dentro de los if or else, es decir las sentencias pueden ser a su vez sentencias if-else. En otras palabras, es posible incrustar una o m\u00e1s sentencias if-else dentro de otra sentencia if-else, creando as\u00ed una estructura de control anidada. Como ocurre con la mayor\u00eda de las cosas, hacer una estructura de control demasiado compleja no es una buena idea, pero existe una estructura de control est\u00e1ndar anidada ifelse que es muy \u00fatil. Se conoce como selecci\u00f3n de m\u00faltiples v\u00edas. if ( * condici\u00f3n * ) { //sentencias 1 } else if ( * condici\u00f3n * ) { //sentencias 2 } else if ( * condici\u00f3n * ) { ... } else { //sentencias } Ejemplo: if ( numJugadores == 1 ) { System . out . println ( \"Single player\" ); } else if ( numJugadores == 2 ) { System . out . println ( \"Two player\" ); } else if ( numJugadores == 3 ) { System . out . println ( \"Multiplayer\" ); } else { System . out . println ( \"Not possible, too many players\" ); }","title":"If Statement"},{"location":"ud2/1seleccion/#sentencia-if","text":"Este apartado analiza c\u00f3mo los programas del ordenador toman decisiones utilizando la sentencia if . Esta sentencia es uno de los bloques de construcci\u00f3n fundamentales de la programaci\u00f3n. Veamos c\u00f3mo funciona. Los limpiaparabrisas se controlan con un interruptor de encendido y apagado. El diagrama de flujo de la derecha muestra c\u00f3mo se toma esta decisi\u00f3n. Comience en la parte superior del gr\u00e1fico y luego siga la l\u00ednea hasta la pregunta: \u00bfesta lloviendo? La respuesta es verdadera o falsa. Si la respuesta es verdadera, siga la l\u00ednea etiquetada como Verdadero, siga las instrucciones en el cuadro \"Activo limpiaparabrisas , siga la l\u00ednea para \"Continuar\". Si la respuesta es falsa, siga la l\u00ednea etiquetada como Falso, siga las instrucciones en el cuadro \"limpiaparabrisas desactivados\", siga la l\u00ednea para \"Continuar\". Ejemplo del programa en c\u00f3digo public static void main(String[] args) { Scanner scan = new Scanner( System.in ); String respuesta; System.out.print(\"\u00bfEst\u00e1 lloviendo? (Y or N): \"); respuesta = scan.nextLine(); if (respuesta.equals(\"Y\")) { System.out.println(\"Activa limpiaparabrisas\"); } else { System.out.println(\"Desactiva limpiaparabrisas\"); } }","title":"Sentencia IF"},{"location":"ud2/1seleccion/#sentencia-simple-condicional-if","text":"La declaraci\u00f3n if es la m\u00e1s b\u00e1sica de todas las declaraciones de flujo de control. Le dice a su programa que ejecute una determinada secci\u00f3n de c\u00f3digo solo si una prueba en particular se eval\u00faa como verdadera. La sentencia simple condicional if tiene la siguiente estructura: if ( * condici\u00f3n * ) { //sentencias } Condicion es una expresi\u00f3n booleana. Recuerde que una expresi\u00f3n es una combinaci\u00f3n de literales, operadores, nombres de variables y par\u00e9ntesis que se utilizan para calcular un valor, o incluso una llamada a un m\u00e9todo. Una expresi\u00f3n booleana es una expresi\u00f3n que se eval\u00faa como verdadera o falsa. Dada esta descripci\u00f3n de la sintaxis de la sentencia if, los siguientes son ejemplos de sentencias if v\u00e1lidas: if ( true ) { System . out . println ( \"expresi\u00f3n if\" ); } int num = 6 ; if ( num > 0 ) { System . out . println ( \"El n\u00famero es positivo.\" ); }","title":"Sentencia simple condicional if"},{"location":"ud2/1seleccion/#sentencia-condicional-compuesta-if-else","text":"Una segunda versi\u00f3n de la sentencia if incorpora una cl\u00e1usula else en la estructura. Esto nos permite ejecutar cualquiera de dos declaraciones separadas (simple o compuesta) como resultado de un booleano expresi\u00f3n. if ( * condici\u00f3n * ) { //sentencias 1 } else { //sentencias 2 } Ejemplo: int numJugadores = 2 ; if ( numJugadores == 1 ) { System . out . println ( \"Single player\" ); } else { System . out . println ( \"Multiplayer\" ); }","title":"Sentencia condicional compuesta if-else"},{"location":"ud2/1seleccion/#sentencia-condicional-if-else-multiple","text":"Lo que se ejecuta dentro de los if or else, es decir las sentencias pueden ser a su vez sentencias if-else. En otras palabras, es posible incrustar una o m\u00e1s sentencias if-else dentro de otra sentencia if-else, creando as\u00ed una estructura de control anidada. Como ocurre con la mayor\u00eda de las cosas, hacer una estructura de control demasiado compleja no es una buena idea, pero existe una estructura de control est\u00e1ndar anidada ifelse que es muy \u00fatil. Se conoce como selecci\u00f3n de m\u00faltiples v\u00edas. if ( * condici\u00f3n * ) { //sentencias 1 } else if ( * condici\u00f3n * ) { //sentencias 2 } else if ( * condici\u00f3n * ) { ... } else { //sentencias } Ejemplo: if ( numJugadores == 1 ) { System . out . println ( \"Single player\" ); } else if ( numJugadores == 2 ) { System . out . println ( \"Two player\" ); } else if ( numJugadores == 3 ) { System . out . println ( \"Multiplayer\" ); } else { System . out . println ( \"Not possible, too many players\" ); }","title":"Sentencia condicional if-else m\u00faltiple"},{"location":"ud2/22while/","text":"","title":"Bucle while"},{"location":"ud2/23breakcontinue/","text":"","title":"Sentencias break y continue"},{"location":"ud2/24exceptions/","text":"","title":"2.4.- Control de excepciones"},{"location":"ud2/25fallos/","text":"","title":"Fallos de software"},{"location":"ud2/26comentarios/","text":"","title":"2.6.- Comentarios estructurados en programas"},{"location":"ud2/2switch/","text":"Sentencia SWITCH Otra estructura de selecci\u00f3n o alternativa para agregar a nuestro repertorio es la estructura switch . La expresi\u00f3n switch se eval\u00faa una vez. El valor de la expresi\u00f3n se compara con los valores de cada caso. Si hay una coincidencia, se ejecuta el bloque de c\u00f3digo asociado. Las palabras clave break y default son opcionales. Es una forma abreviada de codificar la estructura de selecci\u00f3n m\u00faltiple que vimos en el cap\u00edtulo anterior. De forma que el siguiente c\u00f3digo expresado con if-else m\u00faltiple: if ( numJugadores == 1 ) { System . out . println ( \"Single player\" ); } else if ( numJugadores == 2 ) { System . out . println ( \"Two player\" ); } else if ( numJugadores == 3 ) { System . out . println ( \"Multiplayer\" ); } else { System . out . println ( \"Not possible, too many players\" ); } Es equivalente a: switch ( numJugadores ) { case 1 : System . out . println ( \"Single player\" ); break ; case 2 : System . out . println ( \"Two player\" ); break ; case 3 : System . out . println ( \"Multiplayer\" ); break ; default : System . out . println ( \"Not possible, too many players\" ); } BREAK Cuando el programa Java alcanza la palabra break, se sale del bloque switch. Es decir, ya no se sigue ejecutando m\u00e1s c\u00f3digo dentro del switch ni ning\u00fan case. Un break puede ahorrar mucho tiempo de ejecuci\u00f3n porque \"ignora\" la ejecuci\u00f3n de todo el resto del c\u00f3digo switch. DEFAULT La palabra default se usa para ejecutar c\u00f3digo cuando no hay ninguna coincidencia con ning\u00fan caso ( case ). Siempre se pone al final, por tanto no necesita de la instrucci\u00f3n break .","title":"Switch Statement"},{"location":"ud2/2switch/#sentencia-switch","text":"Otra estructura de selecci\u00f3n o alternativa para agregar a nuestro repertorio es la estructura switch . La expresi\u00f3n switch se eval\u00faa una vez. El valor de la expresi\u00f3n se compara con los valores de cada caso. Si hay una coincidencia, se ejecuta el bloque de c\u00f3digo asociado. Las palabras clave break y default son opcionales. Es una forma abreviada de codificar la estructura de selecci\u00f3n m\u00faltiple que vimos en el cap\u00edtulo anterior. De forma que el siguiente c\u00f3digo expresado con if-else m\u00faltiple: if ( numJugadores == 1 ) { System . out . println ( \"Single player\" ); } else if ( numJugadores == 2 ) { System . out . println ( \"Two player\" ); } else if ( numJugadores == 3 ) { System . out . println ( \"Multiplayer\" ); } else { System . out . println ( \"Not possible, too many players\" ); } Es equivalente a: switch ( numJugadores ) { case 1 : System . out . println ( \"Single player\" ); break ; case 2 : System . out . println ( \"Two player\" ); break ; case 3 : System . out . println ( \"Multiplayer\" ); break ; default : System . out . println ( \"Not possible, too many players\" ); }","title":"Sentencia SWITCH"},{"location":"ud2/2switch/#break","text":"Cuando el programa Java alcanza la palabra break, se sale del bloque switch. Es decir, ya no se sigue ejecutando m\u00e1s c\u00f3digo dentro del switch ni ning\u00fan case. Un break puede ahorrar mucho tiempo de ejecuci\u00f3n porque \"ignora\" la ejecuci\u00f3n de todo el resto del c\u00f3digo switch.","title":"BREAK"},{"location":"ud2/2switch/#default","text":"La palabra default se usa para ejecutar c\u00f3digo cuando no hay ninguna coincidencia con ning\u00fan caso ( case ). Siempre se pone al final, por tanto no necesita de la instrucci\u00f3n break .","title":"DEFAULT"}]}